
// This file is generated by pre_generator.py
#include "spine_types.h"


bool convertToJson(const MessagingTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case MessagingTypeEnumType::logging:
		 enumName = "logging";
		break;
	case MessagingTypeEnumType::information:
		 enumName = "information";
		break;
	case MessagingTypeEnumType::warning:
		 enumName = "warning";
		break;
	case MessagingTypeEnumType::alarm:
		 enumName = "alarm";
		break;
	case MessagingTypeEnumType::emergency:
		 enumName = "emergency";
		break;
	case MessagingTypeEnumType::obsolete:
		 enumName = "obsolete";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, MessagingTypeEnumType &dst) {
	if (src == "logging") {
		dst = MessagingTypeEnumType::logging;
		return;
	}
	if (src == "information") {
		dst = MessagingTypeEnumType::information;
		return;
	}
	if (src == "warning") {
		dst = MessagingTypeEnumType::warning;
		return;
	}
	if (src == "alarm") {
		dst = MessagingTypeEnumType::alarm;
		return;
	}
	if (src == "emergency") {
		dst = MessagingTypeEnumType::emergency;
		return;
	}
	if (src == "obsolete") {
		dst = MessagingTypeEnumType::obsolete;
		return;
	}
	 return;
}
bool convertToJson(const RecurringIntervalEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case RecurringIntervalEnumType::yearly:
		 enumName = "yearly";
		break;
	case RecurringIntervalEnumType::monthly:
		 enumName = "monthly";
		break;
	case RecurringIntervalEnumType::weekly:
		 enumName = "weekly";
		break;
	case RecurringIntervalEnumType::daily:
		 enumName = "daily";
		break;
	case RecurringIntervalEnumType::hourly:
		 enumName = "hourly";
		break;
	case RecurringIntervalEnumType::everyMinute:
		 enumName = "everyMinute";
		break;
	case RecurringIntervalEnumType::everySecond:
		 enumName = "everySecond";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, RecurringIntervalEnumType &dst) {
	if (src == "yearly") {
		dst = RecurringIntervalEnumType::yearly;
		return;
	}
	if (src == "monthly") {
		dst = RecurringIntervalEnumType::monthly;
		return;
	}
	if (src == "weekly") {
		dst = RecurringIntervalEnumType::weekly;
		return;
	}
	if (src == "daily") {
		dst = RecurringIntervalEnumType::daily;
		return;
	}
	if (src == "hourly") {
		dst = RecurringIntervalEnumType::hourly;
		return;
	}
	if (src == "everyMinute") {
		dst = RecurringIntervalEnumType::everyMinute;
		return;
	}
	if (src == "everySecond") {
		dst = RecurringIntervalEnumType::everySecond;
		return;
	}
	 return;
}
bool convertToJson(const MonthType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case MonthType::january:
		 enumName = "january";
		break;
	case MonthType::february:
		 enumName = "february";
		break;
	case MonthType::march:
		 enumName = "march";
		break;
	case MonthType::april:
		 enumName = "april";
		break;
	case MonthType::may:
		 enumName = "may";
		break;
	case MonthType::june:
		 enumName = "june";
		break;
	case MonthType::july:
		 enumName = "july";
		break;
	case MonthType::august:
		 enumName = "august";
		break;
	case MonthType::september:
		 enumName = "september";
		break;
	case MonthType::october:
		 enumName = "october";
		break;
	case MonthType::november:
		 enumName = "november";
		break;
	case MonthType::december:
		 enumName = "december";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, MonthType &dst) {
	if (src == "january") {
		dst = MonthType::january;
		return;
	}
	if (src == "february") {
		dst = MonthType::february;
		return;
	}
	if (src == "march") {
		dst = MonthType::march;
		return;
	}
	if (src == "april") {
		dst = MonthType::april;
		return;
	}
	if (src == "may") {
		dst = MonthType::may;
		return;
	}
	if (src == "june") {
		dst = MonthType::june;
		return;
	}
	if (src == "july") {
		dst = MonthType::july;
		return;
	}
	if (src == "august") {
		dst = MonthType::august;
		return;
	}
	if (src == "september") {
		dst = MonthType::september;
		return;
	}
	if (src == "october") {
		dst = MonthType::october;
		return;
	}
	if (src == "november") {
		dst = MonthType::november;
		return;
	}
	if (src == "december") {
		dst = MonthType::december;
		return;
	}
	 return;
}
bool convertToJson(const DayOfWeekType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case DayOfWeekType::monday:
		 enumName = "monday";
		break;
	case DayOfWeekType::tuesday:
		 enumName = "tuesday";
		break;
	case DayOfWeekType::wednesday:
		 enumName = "wednesday";
		break;
	case DayOfWeekType::thursday:
		 enumName = "thursday";
		break;
	case DayOfWeekType::friday:
		 enumName = "friday";
		break;
	case DayOfWeekType::saturday:
		 enumName = "saturday";
		break;
	case DayOfWeekType::sunday:
		 enumName = "sunday";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, DayOfWeekType &dst) {
	if (src == "monday") {
		dst = DayOfWeekType::monday;
		return;
	}
	if (src == "tuesday") {
		dst = DayOfWeekType::tuesday;
		return;
	}
	if (src == "wednesday") {
		dst = DayOfWeekType::wednesday;
		return;
	}
	if (src == "thursday") {
		dst = DayOfWeekType::thursday;
		return;
	}
	if (src == "friday") {
		dst = DayOfWeekType::friday;
		return;
	}
	if (src == "saturday") {
		dst = DayOfWeekType::saturday;
		return;
	}
	if (src == "sunday") {
		dst = DayOfWeekType::sunday;
		return;
	}
	 return;
}
bool convertToJson(const OccurrenceEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case OccurrenceEnumType::first:
		 enumName = "first";
		break;
	case OccurrenceEnumType::second:
		 enumName = "second";
		break;
	case OccurrenceEnumType::third:
		 enumName = "third";
		break;
	case OccurrenceEnumType::fourth:
		 enumName = "fourth";
		break;
	case OccurrenceEnumType::last:
		 enumName = "last";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, OccurrenceEnumType &dst) {
	if (src == "first") {
		dst = OccurrenceEnumType::first;
		return;
	}
	if (src == "second") {
		dst = OccurrenceEnumType::second;
		return;
	}
	if (src == "third") {
		dst = OccurrenceEnumType::third;
		return;
	}
	if (src == "fourth") {
		dst = OccurrenceEnumType::fourth;
		return;
	}
	if (src == "last") {
		dst = OccurrenceEnumType::last;
		return;
	}
	 return;
}
bool convertToJson(const CommodityTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case CommodityTypeEnumType::electricity:
		 enumName = "electricity";
		break;
	case CommodityTypeEnumType::gas:
		 enumName = "gas";
		break;
	case CommodityTypeEnumType::oil:
		 enumName = "oil";
		break;
	case CommodityTypeEnumType::water:
		 enumName = "water";
		break;
	case CommodityTypeEnumType::wasteWater:
		 enumName = "wasteWater";
		break;
	case CommodityTypeEnumType::domesticHotWater:
		 enumName = "domesticHotWater";
		break;
	case CommodityTypeEnumType::heatingWater:
		 enumName = "heatingWater";
		break;
	case CommodityTypeEnumType::steam:
		 enumName = "steam";
		break;
	case CommodityTypeEnumType::heat:
		 enumName = "heat";
		break;
	case CommodityTypeEnumType::coolingLoad:
		 enumName = "coolingLoad";
		break;
	case CommodityTypeEnumType::air:
		 enumName = "air";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, CommodityTypeEnumType &dst) {
	if (src == "electricity") {
		dst = CommodityTypeEnumType::electricity;
		return;
	}
	if (src == "gas") {
		dst = CommodityTypeEnumType::gas;
		return;
	}
	if (src == "oil") {
		dst = CommodityTypeEnumType::oil;
		return;
	}
	if (src == "water") {
		dst = CommodityTypeEnumType::water;
		return;
	}
	if (src == "wasteWater") {
		dst = CommodityTypeEnumType::wasteWater;
		return;
	}
	if (src == "domesticHotWater") {
		dst = CommodityTypeEnumType::domesticHotWater;
		return;
	}
	if (src == "heatingWater") {
		dst = CommodityTypeEnumType::heatingWater;
		return;
	}
	if (src == "steam") {
		dst = CommodityTypeEnumType::steam;
		return;
	}
	if (src == "heat") {
		dst = CommodityTypeEnumType::heat;
		return;
	}
	if (src == "coolingLoad") {
		dst = CommodityTypeEnumType::coolingLoad;
		return;
	}
	if (src == "air") {
		dst = CommodityTypeEnumType::air;
		return;
	}
	 return;
}
bool convertToJson(const EnergyDirectionEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case EnergyDirectionEnumType::consume:
		 enumName = "consume";
		break;
	case EnergyDirectionEnumType::produce:
		 enumName = "produce";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, EnergyDirectionEnumType &dst) {
	if (src == "consume") {
		dst = EnergyDirectionEnumType::consume;
		return;
	}
	if (src == "produce") {
		dst = EnergyDirectionEnumType::produce;
		return;
	}
	 return;
}
bool convertToJson(const EnergyModeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case EnergyModeEnumType::consume:
		 enumName = "consume";
		break;
	case EnergyModeEnumType::produce:
		 enumName = "produce";
		break;
	case EnergyModeEnumType::idle:
		 enumName = "idle";
		break;
	case EnergyModeEnumType::var_auto:
		 enumName = "auto";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, EnergyModeEnumType &dst) {
	if (src == "consume") {
		dst = EnergyModeEnumType::consume;
		return;
	}
	if (src == "produce") {
		dst = EnergyModeEnumType::produce;
		return;
	}
	if (src == "idle") {
		dst = EnergyModeEnumType::idle;
		return;
	}
	if (src == "auto") {
		dst = EnergyModeEnumType::var_auto;
		return;
	}
	 return;
}
bool convertToJson(const UnitOfMeasurementEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case UnitOfMeasurementEnumType::unknown:
		 enumName = "unknown";
		break;
	case UnitOfMeasurementEnumType::var_1:
		 enumName = "1";
		break;
	case UnitOfMeasurementEnumType::m:
		 enumName = "m";
		break;
	case UnitOfMeasurementEnumType::kg:
		 enumName = "kg";
		break;
	case UnitOfMeasurementEnumType::s:
		 enumName = "s";
		break;
	case UnitOfMeasurementEnumType::A:
		 enumName = "A";
		break;
	case UnitOfMeasurementEnumType::K:
		 enumName = "K";
		break;
	case UnitOfMeasurementEnumType::mol:
		 enumName = "mol";
		break;
	case UnitOfMeasurementEnumType::cd:
		 enumName = "cd";
		break;
	case UnitOfMeasurementEnumType::V:
		 enumName = "V";
		break;
	case UnitOfMeasurementEnumType::W:
		 enumName = "W";
		break;
	case UnitOfMeasurementEnumType::Wh:
		 enumName = "Wh";
		break;
	case UnitOfMeasurementEnumType::VA:
		 enumName = "VA";
		break;
	case UnitOfMeasurementEnumType::VAh:
		 enumName = "VAh";
		break;
	case UnitOfMeasurementEnumType::var:
		 enumName = "var";
		break;
	case UnitOfMeasurementEnumType::varh:
		 enumName = "varh";
		break;
	case UnitOfMeasurementEnumType::degC:
		 enumName = "degC";
		break;
	case UnitOfMeasurementEnumType::degF:
		 enumName = "degF";
		break;
	case UnitOfMeasurementEnumType::Lm:
		 enumName = "Lm";
		break;
	case UnitOfMeasurementEnumType::lx:
		 enumName = "lx";
		break;
	case UnitOfMeasurementEnumType::Ohm:
		 enumName = "Ohm";
		break;
	case UnitOfMeasurementEnumType::Hz:
		 enumName = "Hz";
		break;
	case UnitOfMeasurementEnumType::dB:
		 enumName = "dB";
		break;
	case UnitOfMeasurementEnumType::dBm:
		 enumName = "dBm";
		break;
	case UnitOfMeasurementEnumType::pct:
		 enumName = "pct";
		break;
	case UnitOfMeasurementEnumType::ppm:
		 enumName = "ppm";
		break;
	case UnitOfMeasurementEnumType::l:
		 enumName = "l";
		break;
	case UnitOfMeasurementEnumType::l_s:
		 enumName = "l/s";
		break;
	case UnitOfMeasurementEnumType::l_h:
		 enumName = "l/h";
		break;
	case UnitOfMeasurementEnumType::deg:
		 enumName = "deg";
		break;
	case UnitOfMeasurementEnumType::rad:
		 enumName = "rad";
		break;
	case UnitOfMeasurementEnumType::rad_s:
		 enumName = "rad/s";
		break;
	case UnitOfMeasurementEnumType::sr:
		 enumName = "sr";
		break;
	case UnitOfMeasurementEnumType::Gy:
		 enumName = "Gy";
		break;
	case UnitOfMeasurementEnumType::Bq:
		 enumName = "Bq";
		break;
	case UnitOfMeasurementEnumType::Bq_m_3:
		 enumName = "Bq/m^3";
		break;
	case UnitOfMeasurementEnumType::Sv:
		 enumName = "Sv";
		break;
	case UnitOfMeasurementEnumType::Rd:
		 enumName = "Rd";
		break;
	case UnitOfMeasurementEnumType::C:
		 enumName = "C";
		break;
	case UnitOfMeasurementEnumType::F:
		 enumName = "F";
		break;
	case UnitOfMeasurementEnumType::H:
		 enumName = "H";
		break;
	case UnitOfMeasurementEnumType::J:
		 enumName = "J";
		break;
	case UnitOfMeasurementEnumType::N:
		 enumName = "N";
		break;
	case UnitOfMeasurementEnumType::N_m:
		 enumName = "N_m";
		break;
	case UnitOfMeasurementEnumType::N_s:
		 enumName = "N_s";
		break;
	case UnitOfMeasurementEnumType::Wb:
		 enumName = "Wb";
		break;
	case UnitOfMeasurementEnumType::T:
		 enumName = "T";
		break;
	case UnitOfMeasurementEnumType::Pa:
		 enumName = "Pa";
		break;
	case UnitOfMeasurementEnumType::bar:
		 enumName = "bar";
		break;
	case UnitOfMeasurementEnumType::atm:
		 enumName = "atm";
		break;
	case UnitOfMeasurementEnumType::psi:
		 enumName = "psi";
		break;
	case UnitOfMeasurementEnumType::mmHg:
		 enumName = "mmHg";
		break;
	case UnitOfMeasurementEnumType::m_2:
		 enumName = "m^2";
		break;
	case UnitOfMeasurementEnumType::m_3:
		 enumName = "m^3";
		break;
	case UnitOfMeasurementEnumType::m_3_h:
		 enumName = "m^3/h";
		break;
	case UnitOfMeasurementEnumType::m_s:
		 enumName = "m/s";
		break;
	case UnitOfMeasurementEnumType::m_s_2:
		 enumName = "m/s^2";
		break;
	case UnitOfMeasurementEnumType::m_3_s:
		 enumName = "m^3/s";
		break;
	case UnitOfMeasurementEnumType::m_m_3:
		 enumName = "m/m^3";
		break;
	case UnitOfMeasurementEnumType::kg_m_3:
		 enumName = "kg/m^3";
		break;
	case UnitOfMeasurementEnumType::kg_m:
		 enumName = "kg_m";
		break;
	case UnitOfMeasurementEnumType::m_2_s:
		 enumName = "m^2/s";
		break;
	case UnitOfMeasurementEnumType::W_m_K:
		 enumName = "W/m_K";
		break;
	case UnitOfMeasurementEnumType::J_K:
		 enumName = "J/K";
		break;
	case UnitOfMeasurementEnumType::var_1_s:
		 enumName = "1/s";
		break;
	case UnitOfMeasurementEnumType::W_m_2:
		 enumName = "W/m^2";
		break;
	case UnitOfMeasurementEnumType::J_m_2:
		 enumName = "J/m^2";
		break;
	case UnitOfMeasurementEnumType::S:
		 enumName = "S";
		break;
	case UnitOfMeasurementEnumType::S_m:
		 enumName = "S/m";
		break;
	case UnitOfMeasurementEnumType::K_s:
		 enumName = "K/s";
		break;
	case UnitOfMeasurementEnumType::Pa_s:
		 enumName = "Pa/s";
		break;
	case UnitOfMeasurementEnumType::J_kg_K:
		 enumName = "J/kg_K";
		break;
	case UnitOfMeasurementEnumType::Vs:
		 enumName = "Vs";
		break;
	case UnitOfMeasurementEnumType::V_m:
		 enumName = "V/m";
		break;
	case UnitOfMeasurementEnumType::V_Hz:
		 enumName = "V/Hz";
		break;
	case UnitOfMeasurementEnumType::As:
		 enumName = "As";
		break;
	case UnitOfMeasurementEnumType::A_m:
		 enumName = "A/m";
		break;
	case UnitOfMeasurementEnumType::Hz_s:
		 enumName = "Hz/s";
		break;
	case UnitOfMeasurementEnumType::kg_s:
		 enumName = "kg/s";
		break;
	case UnitOfMeasurementEnumType::kg_m_2:
		 enumName = "kg_m^2";
		break;
	case UnitOfMeasurementEnumType::J_Wh:
		 enumName = "J/Wh";
		break;
	case UnitOfMeasurementEnumType::W_s:
		 enumName = "W/s";
		break;
	case UnitOfMeasurementEnumType::ft_3:
		 enumName = "ft^3";
		break;
	case UnitOfMeasurementEnumType::ft_3_h:
		 enumName = "ft^3/h";
		break;
	case UnitOfMeasurementEnumType::ccf:
		 enumName = "ccf";
		break;
	case UnitOfMeasurementEnumType::ccf_h:
		 enumName = "ccf/h";
		break;
	case UnitOfMeasurementEnumType::US_liq_gal:
		 enumName = "US.liq.gal";
		break;
	case UnitOfMeasurementEnumType::US_liq_gal_h:
		 enumName = "US.liq.gal/h";
		break;
	case UnitOfMeasurementEnumType::Imp_gal:
		 enumName = "Imp.gal";
		break;
	case UnitOfMeasurementEnumType::Imp_gal_h:
		 enumName = "Imp.gal/h";
		break;
	case UnitOfMeasurementEnumType::Btu:
		 enumName = "Btu";
		break;
	case UnitOfMeasurementEnumType::Btu_h:
		 enumName = "Btu/h";
		break;
	case UnitOfMeasurementEnumType::Ah:
		 enumName = "Ah";
		break;
	case UnitOfMeasurementEnumType::kg_Wh:
		 enumName = "kg/Wh";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, UnitOfMeasurementEnumType &dst) {
	if (src == "unknown") {
		dst = UnitOfMeasurementEnumType::unknown;
		return;
	}
	if (src == "1") {
		dst = UnitOfMeasurementEnumType::var_1;
		return;
	}
	if (src == "m") {
		dst = UnitOfMeasurementEnumType::m;
		return;
	}
	if (src == "kg") {
		dst = UnitOfMeasurementEnumType::kg;
		return;
	}
	if (src == "s") {
		dst = UnitOfMeasurementEnumType::s;
		return;
	}
	if (src == "A") {
		dst = UnitOfMeasurementEnumType::A;
		return;
	}
	if (src == "K") {
		dst = UnitOfMeasurementEnumType::K;
		return;
	}
	if (src == "mol") {
		dst = UnitOfMeasurementEnumType::mol;
		return;
	}
	if (src == "cd") {
		dst = UnitOfMeasurementEnumType::cd;
		return;
	}
	if (src == "V") {
		dst = UnitOfMeasurementEnumType::V;
		return;
	}
	if (src == "W") {
		dst = UnitOfMeasurementEnumType::W;
		return;
	}
	if (src == "Wh") {
		dst = UnitOfMeasurementEnumType::Wh;
		return;
	}
	if (src == "VA") {
		dst = UnitOfMeasurementEnumType::VA;
		return;
	}
	if (src == "VAh") {
		dst = UnitOfMeasurementEnumType::VAh;
		return;
	}
	if (src == "var") {
		dst = UnitOfMeasurementEnumType::var;
		return;
	}
	if (src == "varh") {
		dst = UnitOfMeasurementEnumType::varh;
		return;
	}
	if (src == "degC") {
		dst = UnitOfMeasurementEnumType::degC;
		return;
	}
	if (src == "degF") {
		dst = UnitOfMeasurementEnumType::degF;
		return;
	}
	if (src == "Lm") {
		dst = UnitOfMeasurementEnumType::Lm;
		return;
	}
	if (src == "lx") {
		dst = UnitOfMeasurementEnumType::lx;
		return;
	}
	if (src == "Ohm") {
		dst = UnitOfMeasurementEnumType::Ohm;
		return;
	}
	if (src == "Hz") {
		dst = UnitOfMeasurementEnumType::Hz;
		return;
	}
	if (src == "dB") {
		dst = UnitOfMeasurementEnumType::dB;
		return;
	}
	if (src == "dBm") {
		dst = UnitOfMeasurementEnumType::dBm;
		return;
	}
	if (src == "pct") {
		dst = UnitOfMeasurementEnumType::pct;
		return;
	}
	if (src == "ppm") {
		dst = UnitOfMeasurementEnumType::ppm;
		return;
	}
	if (src == "l") {
		dst = UnitOfMeasurementEnumType::l;
		return;
	}
	if (src == "l/s") {
		dst = UnitOfMeasurementEnumType::l_s;
		return;
	}
	if (src == "l/h") {
		dst = UnitOfMeasurementEnumType::l_h;
		return;
	}
	if (src == "deg") {
		dst = UnitOfMeasurementEnumType::deg;
		return;
	}
	if (src == "rad") {
		dst = UnitOfMeasurementEnumType::rad;
		return;
	}
	if (src == "rad/s") {
		dst = UnitOfMeasurementEnumType::rad_s;
		return;
	}
	if (src == "sr") {
		dst = UnitOfMeasurementEnumType::sr;
		return;
	}
	if (src == "Gy") {
		dst = UnitOfMeasurementEnumType::Gy;
		return;
	}
	if (src == "Bq") {
		dst = UnitOfMeasurementEnumType::Bq;
		return;
	}
	if (src == "Bq/m^3") {
		dst = UnitOfMeasurementEnumType::Bq_m_3;
		return;
	}
	if (src == "Sv") {
		dst = UnitOfMeasurementEnumType::Sv;
		return;
	}
	if (src == "Rd") {
		dst = UnitOfMeasurementEnumType::Rd;
		return;
	}
	if (src == "C") {
		dst = UnitOfMeasurementEnumType::C;
		return;
	}
	if (src == "F") {
		dst = UnitOfMeasurementEnumType::F;
		return;
	}
	if (src == "H") {
		dst = UnitOfMeasurementEnumType::H;
		return;
	}
	if (src == "J") {
		dst = UnitOfMeasurementEnumType::J;
		return;
	}
	if (src == "N") {
		dst = UnitOfMeasurementEnumType::N;
		return;
	}
	if (src == "N_m") {
		dst = UnitOfMeasurementEnumType::N_m;
		return;
	}
	if (src == "N_s") {
		dst = UnitOfMeasurementEnumType::N_s;
		return;
	}
	if (src == "Wb") {
		dst = UnitOfMeasurementEnumType::Wb;
		return;
	}
	if (src == "T") {
		dst = UnitOfMeasurementEnumType::T;
		return;
	}
	if (src == "Pa") {
		dst = UnitOfMeasurementEnumType::Pa;
		return;
	}
	if (src == "bar") {
		dst = UnitOfMeasurementEnumType::bar;
		return;
	}
	if (src == "atm") {
		dst = UnitOfMeasurementEnumType::atm;
		return;
	}
	if (src == "psi") {
		dst = UnitOfMeasurementEnumType::psi;
		return;
	}
	if (src == "mmHg") {
		dst = UnitOfMeasurementEnumType::mmHg;
		return;
	}
	if (src == "m^2") {
		dst = UnitOfMeasurementEnumType::m_2;
		return;
	}
	if (src == "m^3") {
		dst = UnitOfMeasurementEnumType::m_3;
		return;
	}
	if (src == "m^3/h") {
		dst = UnitOfMeasurementEnumType::m_3_h;
		return;
	}
	if (src == "m/s") {
		dst = UnitOfMeasurementEnumType::m_s;
		return;
	}
	if (src == "m/s^2") {
		dst = UnitOfMeasurementEnumType::m_s_2;
		return;
	}
	if (src == "m^3/s") {
		dst = UnitOfMeasurementEnumType::m_3_s;
		return;
	}
	if (src == "m/m^3") {
		dst = UnitOfMeasurementEnumType::m_m_3;
		return;
	}
	if (src == "kg/m^3") {
		dst = UnitOfMeasurementEnumType::kg_m_3;
		return;
	}
	if (src == "kg_m") {
		dst = UnitOfMeasurementEnumType::kg_m;
		return;
	}
	if (src == "m^2/s") {
		dst = UnitOfMeasurementEnumType::m_2_s;
		return;
	}
	if (src == "W/m_K") {
		dst = UnitOfMeasurementEnumType::W_m_K;
		return;
	}
	if (src == "J/K") {
		dst = UnitOfMeasurementEnumType::J_K;
		return;
	}
	if (src == "1/s") {
		dst = UnitOfMeasurementEnumType::var_1_s;
		return;
	}
	if (src == "W/m^2") {
		dst = UnitOfMeasurementEnumType::W_m_2;
		return;
	}
	if (src == "J/m^2") {
		dst = UnitOfMeasurementEnumType::J_m_2;
		return;
	}
	if (src == "S") {
		dst = UnitOfMeasurementEnumType::S;
		return;
	}
	if (src == "S/m") {
		dst = UnitOfMeasurementEnumType::S_m;
		return;
	}
	if (src == "K/s") {
		dst = UnitOfMeasurementEnumType::K_s;
		return;
	}
	if (src == "Pa/s") {
		dst = UnitOfMeasurementEnumType::Pa_s;
		return;
	}
	if (src == "J/kg_K") {
		dst = UnitOfMeasurementEnumType::J_kg_K;
		return;
	}
	if (src == "Vs") {
		dst = UnitOfMeasurementEnumType::Vs;
		return;
	}
	if (src == "V/m") {
		dst = UnitOfMeasurementEnumType::V_m;
		return;
	}
	if (src == "V/Hz") {
		dst = UnitOfMeasurementEnumType::V_Hz;
		return;
	}
	if (src == "As") {
		dst = UnitOfMeasurementEnumType::As;
		return;
	}
	if (src == "A/m") {
		dst = UnitOfMeasurementEnumType::A_m;
		return;
	}
	if (src == "Hz/s") {
		dst = UnitOfMeasurementEnumType::Hz_s;
		return;
	}
	if (src == "kg/s") {
		dst = UnitOfMeasurementEnumType::kg_s;
		return;
	}
	if (src == "kg_m^2") {
		dst = UnitOfMeasurementEnumType::kg_m_2;
		return;
	}
	if (src == "J/Wh") {
		dst = UnitOfMeasurementEnumType::J_Wh;
		return;
	}
	if (src == "W/s") {
		dst = UnitOfMeasurementEnumType::W_s;
		return;
	}
	if (src == "ft^3") {
		dst = UnitOfMeasurementEnumType::ft_3;
		return;
	}
	if (src == "ft^3/h") {
		dst = UnitOfMeasurementEnumType::ft_3_h;
		return;
	}
	if (src == "ccf") {
		dst = UnitOfMeasurementEnumType::ccf;
		return;
	}
	if (src == "ccf/h") {
		dst = UnitOfMeasurementEnumType::ccf_h;
		return;
	}
	if (src == "US.liq.gal") {
		dst = UnitOfMeasurementEnumType::US_liq_gal;
		return;
	}
	if (src == "US.liq.gal/h") {
		dst = UnitOfMeasurementEnumType::US_liq_gal_h;
		return;
	}
	if (src == "Imp.gal") {
		dst = UnitOfMeasurementEnumType::Imp_gal;
		return;
	}
	if (src == "Imp.gal/h") {
		dst = UnitOfMeasurementEnumType::Imp_gal_h;
		return;
	}
	if (src == "Btu") {
		dst = UnitOfMeasurementEnumType::Btu;
		return;
	}
	if (src == "Btu/h") {
		dst = UnitOfMeasurementEnumType::Btu_h;
		return;
	}
	if (src == "Ah") {
		dst = UnitOfMeasurementEnumType::Ah;
		return;
	}
	if (src == "kg/Wh") {
		dst = UnitOfMeasurementEnumType::kg_Wh;
		return;
	}
	 return;
}
bool convertToJson(const CurrencyEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case CurrencyEnumType::AED:
		 enumName = "AED";
		break;
	case CurrencyEnumType::AFN:
		 enumName = "AFN";
		break;
	case CurrencyEnumType::ALL:
		 enumName = "ALL";
		break;
	case CurrencyEnumType::AMD:
		 enumName = "AMD";
		break;
	case CurrencyEnumType::ANG:
		 enumName = "ANG";
		break;
	case CurrencyEnumType::AOA:
		 enumName = "AOA";
		break;
	case CurrencyEnumType::ARS:
		 enumName = "ARS";
		break;
	case CurrencyEnumType::AUD:
		 enumName = "AUD";
		break;
	case CurrencyEnumType::AWG:
		 enumName = "AWG";
		break;
	case CurrencyEnumType::AZN:
		 enumName = "AZN";
		break;
	case CurrencyEnumType::BAM:
		 enumName = "BAM";
		break;
	case CurrencyEnumType::BBD:
		 enumName = "BBD";
		break;
	case CurrencyEnumType::BDT:
		 enumName = "BDT";
		break;
	case CurrencyEnumType::BGN:
		 enumName = "BGN";
		break;
	case CurrencyEnumType::BHD:
		 enumName = "BHD";
		break;
	case CurrencyEnumType::BIF:
		 enumName = "BIF";
		break;
	case CurrencyEnumType::BMD:
		 enumName = "BMD";
		break;
	case CurrencyEnumType::BND:
		 enumName = "BND";
		break;
	case CurrencyEnumType::BOB:
		 enumName = "BOB";
		break;
	case CurrencyEnumType::BOV:
		 enumName = "BOV";
		break;
	case CurrencyEnumType::BRL:
		 enumName = "BRL";
		break;
	case CurrencyEnumType::BSD:
		 enumName = "BSD";
		break;
	case CurrencyEnumType::BTN:
		 enumName = "BTN";
		break;
	case CurrencyEnumType::BWP:
		 enumName = "BWP";
		break;
	case CurrencyEnumType::BYR:
		 enumName = "BYR";
		break;
	case CurrencyEnumType::BZD:
		 enumName = "BZD";
		break;
	case CurrencyEnumType::CAD:
		 enumName = "CAD";
		break;
	case CurrencyEnumType::CDF:
		 enumName = "CDF";
		break;
	case CurrencyEnumType::CHE:
		 enumName = "CHE";
		break;
	case CurrencyEnumType::CHF:
		 enumName = "CHF";
		break;
	case CurrencyEnumType::CHW:
		 enumName = "CHW";
		break;
	case CurrencyEnumType::CLF:
		 enumName = "CLF";
		break;
	case CurrencyEnumType::CLP:
		 enumName = "CLP";
		break;
	case CurrencyEnumType::CNY:
		 enumName = "CNY";
		break;
	case CurrencyEnumType::COP:
		 enumName = "COP";
		break;
	case CurrencyEnumType::COU:
		 enumName = "COU";
		break;
	case CurrencyEnumType::CRC:
		 enumName = "CRC";
		break;
	case CurrencyEnumType::CUC:
		 enumName = "CUC";
		break;
	case CurrencyEnumType::CUP:
		 enumName = "CUP";
		break;
	case CurrencyEnumType::CVE:
		 enumName = "CVE";
		break;
	case CurrencyEnumType::CZK:
		 enumName = "CZK";
		break;
	case CurrencyEnumType::DJF:
		 enumName = "DJF";
		break;
	case CurrencyEnumType::DKK:
		 enumName = "DKK";
		break;
	case CurrencyEnumType::DOP:
		 enumName = "DOP";
		break;
	case CurrencyEnumType::DZD:
		 enumName = "DZD";
		break;
	case CurrencyEnumType::EGP:
		 enumName = "EGP";
		break;
	case CurrencyEnumType::ERN:
		 enumName = "ERN";
		break;
	case CurrencyEnumType::ETB:
		 enumName = "ETB";
		break;
	case CurrencyEnumType::EUR:
		 enumName = "EUR";
		break;
	case CurrencyEnumType::FJD:
		 enumName = "FJD";
		break;
	case CurrencyEnumType::FKP:
		 enumName = "FKP";
		break;
	case CurrencyEnumType::GBP:
		 enumName = "GBP";
		break;
	case CurrencyEnumType::GEL:
		 enumName = "GEL";
		break;
	case CurrencyEnumType::GHS:
		 enumName = "GHS";
		break;
	case CurrencyEnumType::GIP:
		 enumName = "GIP";
		break;
	case CurrencyEnumType::GMD:
		 enumName = "GMD";
		break;
	case CurrencyEnumType::GNF:
		 enumName = "GNF";
		break;
	case CurrencyEnumType::GTQ:
		 enumName = "GTQ";
		break;
	case CurrencyEnumType::GYD:
		 enumName = "GYD";
		break;
	case CurrencyEnumType::HKD:
		 enumName = "HKD";
		break;
	case CurrencyEnumType::HNL:
		 enumName = "HNL";
		break;
	case CurrencyEnumType::HRK:
		 enumName = "HRK";
		break;
	case CurrencyEnumType::HTG:
		 enumName = "HTG";
		break;
	case CurrencyEnumType::HUF:
		 enumName = "HUF";
		break;
	case CurrencyEnumType::IDR:
		 enumName = "IDR";
		break;
	case CurrencyEnumType::ILS:
		 enumName = "ILS";
		break;
	case CurrencyEnumType::INR:
		 enumName = "INR";
		break;
	case CurrencyEnumType::IQD:
		 enumName = "IQD";
		break;
	case CurrencyEnumType::IRR:
		 enumName = "IRR";
		break;
	case CurrencyEnumType::ISK:
		 enumName = "ISK";
		break;
	case CurrencyEnumType::JMD:
		 enumName = "JMD";
		break;
	case CurrencyEnumType::JOD:
		 enumName = "JOD";
		break;
	case CurrencyEnumType::JPY:
		 enumName = "JPY";
		break;
	case CurrencyEnumType::KES:
		 enumName = "KES";
		break;
	case CurrencyEnumType::KGS:
		 enumName = "KGS";
		break;
	case CurrencyEnumType::KHR:
		 enumName = "KHR";
		break;
	case CurrencyEnumType::KMF:
		 enumName = "KMF";
		break;
	case CurrencyEnumType::KPW:
		 enumName = "KPW";
		break;
	case CurrencyEnumType::KRW:
		 enumName = "KRW";
		break;
	case CurrencyEnumType::KWD:
		 enumName = "KWD";
		break;
	case CurrencyEnumType::KYD:
		 enumName = "KYD";
		break;
	case CurrencyEnumType::KZT:
		 enumName = "KZT";
		break;
	case CurrencyEnumType::LAK:
		 enumName = "LAK";
		break;
	case CurrencyEnumType::LBP:
		 enumName = "LBP";
		break;
	case CurrencyEnumType::LKR:
		 enumName = "LKR";
		break;
	case CurrencyEnumType::LRD:
		 enumName = "LRD";
		break;
	case CurrencyEnumType::LSL:
		 enumName = "LSL";
		break;
	case CurrencyEnumType::LYD:
		 enumName = "LYD";
		break;
	case CurrencyEnumType::MAD:
		 enumName = "MAD";
		break;
	case CurrencyEnumType::MDL:
		 enumName = "MDL";
		break;
	case CurrencyEnumType::MGA:
		 enumName = "MGA";
		break;
	case CurrencyEnumType::MKD:
		 enumName = "MKD";
		break;
	case CurrencyEnumType::MMK:
		 enumName = "MMK";
		break;
	case CurrencyEnumType::MNT:
		 enumName = "MNT";
		break;
	case CurrencyEnumType::MOP:
		 enumName = "MOP";
		break;
	case CurrencyEnumType::MRO:
		 enumName = "MRO";
		break;
	case CurrencyEnumType::MUR:
		 enumName = "MUR";
		break;
	case CurrencyEnumType::MVR:
		 enumName = "MVR";
		break;
	case CurrencyEnumType::MWK:
		 enumName = "MWK";
		break;
	case CurrencyEnumType::MXN:
		 enumName = "MXN";
		break;
	case CurrencyEnumType::MXV:
		 enumName = "MXV";
		break;
	case CurrencyEnumType::MYR:
		 enumName = "MYR";
		break;
	case CurrencyEnumType::MZN:
		 enumName = "MZN";
		break;
	case CurrencyEnumType::NAD:
		 enumName = "NAD";
		break;
	case CurrencyEnumType::NGN:
		 enumName = "NGN";
		break;
	case CurrencyEnumType::NIO:
		 enumName = "NIO";
		break;
	case CurrencyEnumType::NOK:
		 enumName = "NOK";
		break;
	case CurrencyEnumType::NPR:
		 enumName = "NPR";
		break;
	case CurrencyEnumType::NZD:
		 enumName = "NZD";
		break;
	case CurrencyEnumType::OMR:
		 enumName = "OMR";
		break;
	case CurrencyEnumType::PAB:
		 enumName = "PAB";
		break;
	case CurrencyEnumType::PEN:
		 enumName = "PEN";
		break;
	case CurrencyEnumType::PGK:
		 enumName = "PGK";
		break;
	case CurrencyEnumType::PHP:
		 enumName = "PHP";
		break;
	case CurrencyEnumType::PKR:
		 enumName = "PKR";
		break;
	case CurrencyEnumType::PLN:
		 enumName = "PLN";
		break;
	case CurrencyEnumType::PYG:
		 enumName = "PYG";
		break;
	case CurrencyEnumType::QAR:
		 enumName = "QAR";
		break;
	case CurrencyEnumType::RON:
		 enumName = "RON";
		break;
	case CurrencyEnumType::RSD:
		 enumName = "RSD";
		break;
	case CurrencyEnumType::RUB:
		 enumName = "RUB";
		break;
	case CurrencyEnumType::RWF:
		 enumName = "RWF";
		break;
	case CurrencyEnumType::var_SAR:
		 enumName = "SAR";
		break;
	case CurrencyEnumType::SBD:
		 enumName = "SBD";
		break;
	case CurrencyEnumType::SCR:
		 enumName = "SCR";
		break;
	case CurrencyEnumType::SDG:
		 enumName = "SDG";
		break;
	case CurrencyEnumType::SEK:
		 enumName = "SEK";
		break;
	case CurrencyEnumType::SGD:
		 enumName = "SGD";
		break;
	case CurrencyEnumType::SHP:
		 enumName = "SHP";
		break;
	case CurrencyEnumType::SLL:
		 enumName = "SLL";
		break;
	case CurrencyEnumType::SOS:
		 enumName = "SOS";
		break;
	case CurrencyEnumType::SRD:
		 enumName = "SRD";
		break;
	case CurrencyEnumType::SSP:
		 enumName = "SSP";
		break;
	case CurrencyEnumType::STD:
		 enumName = "STD";
		break;
	case CurrencyEnumType::SVC:
		 enumName = "SVC";
		break;
	case CurrencyEnumType::SYP:
		 enumName = "SYP";
		break;
	case CurrencyEnumType::SZL:
		 enumName = "SZL";
		break;
	case CurrencyEnumType::THB:
		 enumName = "THB";
		break;
	case CurrencyEnumType::TJS:
		 enumName = "TJS";
		break;
	case CurrencyEnumType::TMT:
		 enumName = "TMT";
		break;
	case CurrencyEnumType::TND:
		 enumName = "TND";
		break;
	case CurrencyEnumType::TOP:
		 enumName = "TOP";
		break;
	case CurrencyEnumType::TRY:
		 enumName = "TRY";
		break;
	case CurrencyEnumType::TTD:
		 enumName = "TTD";
		break;
	case CurrencyEnumType::TWD:
		 enumName = "TWD";
		break;
	case CurrencyEnumType::TZS:
		 enumName = "TZS";
		break;
	case CurrencyEnumType::UAH:
		 enumName = "UAH";
		break;
	case CurrencyEnumType::UGX:
		 enumName = "UGX";
		break;
	case CurrencyEnumType::USD:
		 enumName = "USD";
		break;
	case CurrencyEnumType::USN:
		 enumName = "USN";
		break;
	case CurrencyEnumType::UYI:
		 enumName = "UYI";
		break;
	case CurrencyEnumType::UYU:
		 enumName = "UYU";
		break;
	case CurrencyEnumType::UZS:
		 enumName = "UZS";
		break;
	case CurrencyEnumType::VEF:
		 enumName = "VEF";
		break;
	case CurrencyEnumType::VND:
		 enumName = "VND";
		break;
	case CurrencyEnumType::VUV:
		 enumName = "VUV";
		break;
	case CurrencyEnumType::WST:
		 enumName = "WST";
		break;
	case CurrencyEnumType::XAF:
		 enumName = "XAF";
		break;
	case CurrencyEnumType::XAG:
		 enumName = "XAG";
		break;
	case CurrencyEnumType::XAU:
		 enumName = "XAU";
		break;
	case CurrencyEnumType::XBA:
		 enumName = "XBA";
		break;
	case CurrencyEnumType::XBB:
		 enumName = "XBB";
		break;
	case CurrencyEnumType::XBC:
		 enumName = "XBC";
		break;
	case CurrencyEnumType::XBD:
		 enumName = "XBD";
		break;
	case CurrencyEnumType::XCD:
		 enumName = "XCD";
		break;
	case CurrencyEnumType::XDR:
		 enumName = "XDR";
		break;
	case CurrencyEnumType::XOF:
		 enumName = "XOF";
		break;
	case CurrencyEnumType::XPD:
		 enumName = "XPD";
		break;
	case CurrencyEnumType::XPF:
		 enumName = "XPF";
		break;
	case CurrencyEnumType::XPT:
		 enumName = "XPT";
		break;
	case CurrencyEnumType::XSU:
		 enumName = "XSU";
		break;
	case CurrencyEnumType::XTS:
		 enumName = "XTS";
		break;
	case CurrencyEnumType::XUA:
		 enumName = "XUA";
		break;
	case CurrencyEnumType::XXX:
		 enumName = "XXX";
		break;
	case CurrencyEnumType::YER:
		 enumName = "YER";
		break;
	case CurrencyEnumType::ZAR:
		 enumName = "ZAR";
		break;
	case CurrencyEnumType::ZMW:
		 enumName = "ZMW";
		break;
	case CurrencyEnumType::ZWL:
		 enumName = "ZWL";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, CurrencyEnumType &dst) {
	if (src == "AED") {
		dst = CurrencyEnumType::AED;
		return;
	}
	if (src == "AFN") {
		dst = CurrencyEnumType::AFN;
		return;
	}
	if (src == "ALL") {
		dst = CurrencyEnumType::ALL;
		return;
	}
	if (src == "AMD") {
		dst = CurrencyEnumType::AMD;
		return;
	}
	if (src == "ANG") {
		dst = CurrencyEnumType::ANG;
		return;
	}
	if (src == "AOA") {
		dst = CurrencyEnumType::AOA;
		return;
	}
	if (src == "ARS") {
		dst = CurrencyEnumType::ARS;
		return;
	}
	if (src == "AUD") {
		dst = CurrencyEnumType::AUD;
		return;
	}
	if (src == "AWG") {
		dst = CurrencyEnumType::AWG;
		return;
	}
	if (src == "AZN") {
		dst = CurrencyEnumType::AZN;
		return;
	}
	if (src == "BAM") {
		dst = CurrencyEnumType::BAM;
		return;
	}
	if (src == "BBD") {
		dst = CurrencyEnumType::BBD;
		return;
	}
	if (src == "BDT") {
		dst = CurrencyEnumType::BDT;
		return;
	}
	if (src == "BGN") {
		dst = CurrencyEnumType::BGN;
		return;
	}
	if (src == "BHD") {
		dst = CurrencyEnumType::BHD;
		return;
	}
	if (src == "BIF") {
		dst = CurrencyEnumType::BIF;
		return;
	}
	if (src == "BMD") {
		dst = CurrencyEnumType::BMD;
		return;
	}
	if (src == "BND") {
		dst = CurrencyEnumType::BND;
		return;
	}
	if (src == "BOB") {
		dst = CurrencyEnumType::BOB;
		return;
	}
	if (src == "BOV") {
		dst = CurrencyEnumType::BOV;
		return;
	}
	if (src == "BRL") {
		dst = CurrencyEnumType::BRL;
		return;
	}
	if (src == "BSD") {
		dst = CurrencyEnumType::BSD;
		return;
	}
	if (src == "BTN") {
		dst = CurrencyEnumType::BTN;
		return;
	}
	if (src == "BWP") {
		dst = CurrencyEnumType::BWP;
		return;
	}
	if (src == "BYR") {
		dst = CurrencyEnumType::BYR;
		return;
	}
	if (src == "BZD") {
		dst = CurrencyEnumType::BZD;
		return;
	}
	if (src == "CAD") {
		dst = CurrencyEnumType::CAD;
		return;
	}
	if (src == "CDF") {
		dst = CurrencyEnumType::CDF;
		return;
	}
	if (src == "CHE") {
		dst = CurrencyEnumType::CHE;
		return;
	}
	if (src == "CHF") {
		dst = CurrencyEnumType::CHF;
		return;
	}
	if (src == "CHW") {
		dst = CurrencyEnumType::CHW;
		return;
	}
	if (src == "CLF") {
		dst = CurrencyEnumType::CLF;
		return;
	}
	if (src == "CLP") {
		dst = CurrencyEnumType::CLP;
		return;
	}
	if (src == "CNY") {
		dst = CurrencyEnumType::CNY;
		return;
	}
	if (src == "COP") {
		dst = CurrencyEnumType::COP;
		return;
	}
	if (src == "COU") {
		dst = CurrencyEnumType::COU;
		return;
	}
	if (src == "CRC") {
		dst = CurrencyEnumType::CRC;
		return;
	}
	if (src == "CUC") {
		dst = CurrencyEnumType::CUC;
		return;
	}
	if (src == "CUP") {
		dst = CurrencyEnumType::CUP;
		return;
	}
	if (src == "CVE") {
		dst = CurrencyEnumType::CVE;
		return;
	}
	if (src == "CZK") {
		dst = CurrencyEnumType::CZK;
		return;
	}
	if (src == "DJF") {
		dst = CurrencyEnumType::DJF;
		return;
	}
	if (src == "DKK") {
		dst = CurrencyEnumType::DKK;
		return;
	}
	if (src == "DOP") {
		dst = CurrencyEnumType::DOP;
		return;
	}
	if (src == "DZD") {
		dst = CurrencyEnumType::DZD;
		return;
	}
	if (src == "EGP") {
		dst = CurrencyEnumType::EGP;
		return;
	}
	if (src == "ERN") {
		dst = CurrencyEnumType::ERN;
		return;
	}
	if (src == "ETB") {
		dst = CurrencyEnumType::ETB;
		return;
	}
	if (src == "EUR") {
		dst = CurrencyEnumType::EUR;
		return;
	}
	if (src == "FJD") {
		dst = CurrencyEnumType::FJD;
		return;
	}
	if (src == "FKP") {
		dst = CurrencyEnumType::FKP;
		return;
	}
	if (src == "GBP") {
		dst = CurrencyEnumType::GBP;
		return;
	}
	if (src == "GEL") {
		dst = CurrencyEnumType::GEL;
		return;
	}
	if (src == "GHS") {
		dst = CurrencyEnumType::GHS;
		return;
	}
	if (src == "GIP") {
		dst = CurrencyEnumType::GIP;
		return;
	}
	if (src == "GMD") {
		dst = CurrencyEnumType::GMD;
		return;
	}
	if (src == "GNF") {
		dst = CurrencyEnumType::GNF;
		return;
	}
	if (src == "GTQ") {
		dst = CurrencyEnumType::GTQ;
		return;
	}
	if (src == "GYD") {
		dst = CurrencyEnumType::GYD;
		return;
	}
	if (src == "HKD") {
		dst = CurrencyEnumType::HKD;
		return;
	}
	if (src == "HNL") {
		dst = CurrencyEnumType::HNL;
		return;
	}
	if (src == "HRK") {
		dst = CurrencyEnumType::HRK;
		return;
	}
	if (src == "HTG") {
		dst = CurrencyEnumType::HTG;
		return;
	}
	if (src == "HUF") {
		dst = CurrencyEnumType::HUF;
		return;
	}
	if (src == "IDR") {
		dst = CurrencyEnumType::IDR;
		return;
	}
	if (src == "ILS") {
		dst = CurrencyEnumType::ILS;
		return;
	}
	if (src == "INR") {
		dst = CurrencyEnumType::INR;
		return;
	}
	if (src == "IQD") {
		dst = CurrencyEnumType::IQD;
		return;
	}
	if (src == "IRR") {
		dst = CurrencyEnumType::IRR;
		return;
	}
	if (src == "ISK") {
		dst = CurrencyEnumType::ISK;
		return;
	}
	if (src == "JMD") {
		dst = CurrencyEnumType::JMD;
		return;
	}
	if (src == "JOD") {
		dst = CurrencyEnumType::JOD;
		return;
	}
	if (src == "JPY") {
		dst = CurrencyEnumType::JPY;
		return;
	}
	if (src == "KES") {
		dst = CurrencyEnumType::KES;
		return;
	}
	if (src == "KGS") {
		dst = CurrencyEnumType::KGS;
		return;
	}
	if (src == "KHR") {
		dst = CurrencyEnumType::KHR;
		return;
	}
	if (src == "KMF") {
		dst = CurrencyEnumType::KMF;
		return;
	}
	if (src == "KPW") {
		dst = CurrencyEnumType::KPW;
		return;
	}
	if (src == "KRW") {
		dst = CurrencyEnumType::KRW;
		return;
	}
	if (src == "KWD") {
		dst = CurrencyEnumType::KWD;
		return;
	}
	if (src == "KYD") {
		dst = CurrencyEnumType::KYD;
		return;
	}
	if (src == "KZT") {
		dst = CurrencyEnumType::KZT;
		return;
	}
	if (src == "LAK") {
		dst = CurrencyEnumType::LAK;
		return;
	}
	if (src == "LBP") {
		dst = CurrencyEnumType::LBP;
		return;
	}
	if (src == "LKR") {
		dst = CurrencyEnumType::LKR;
		return;
	}
	if (src == "LRD") {
		dst = CurrencyEnumType::LRD;
		return;
	}
	if (src == "LSL") {
		dst = CurrencyEnumType::LSL;
		return;
	}
	if (src == "LYD") {
		dst = CurrencyEnumType::LYD;
		return;
	}
	if (src == "MAD") {
		dst = CurrencyEnumType::MAD;
		return;
	}
	if (src == "MDL") {
		dst = CurrencyEnumType::MDL;
		return;
	}
	if (src == "MGA") {
		dst = CurrencyEnumType::MGA;
		return;
	}
	if (src == "MKD") {
		dst = CurrencyEnumType::MKD;
		return;
	}
	if (src == "MMK") {
		dst = CurrencyEnumType::MMK;
		return;
	}
	if (src == "MNT") {
		dst = CurrencyEnumType::MNT;
		return;
	}
	if (src == "MOP") {
		dst = CurrencyEnumType::MOP;
		return;
	}
	if (src == "MRO") {
		dst = CurrencyEnumType::MRO;
		return;
	}
	if (src == "MUR") {
		dst = CurrencyEnumType::MUR;
		return;
	}
	if (src == "MVR") {
		dst = CurrencyEnumType::MVR;
		return;
	}
	if (src == "MWK") {
		dst = CurrencyEnumType::MWK;
		return;
	}
	if (src == "MXN") {
		dst = CurrencyEnumType::MXN;
		return;
	}
	if (src == "MXV") {
		dst = CurrencyEnumType::MXV;
		return;
	}
	if (src == "MYR") {
		dst = CurrencyEnumType::MYR;
		return;
	}
	if (src == "MZN") {
		dst = CurrencyEnumType::MZN;
		return;
	}
	if (src == "NAD") {
		dst = CurrencyEnumType::NAD;
		return;
	}
	if (src == "NGN") {
		dst = CurrencyEnumType::NGN;
		return;
	}
	if (src == "NIO") {
		dst = CurrencyEnumType::NIO;
		return;
	}
	if (src == "NOK") {
		dst = CurrencyEnumType::NOK;
		return;
	}
	if (src == "NPR") {
		dst = CurrencyEnumType::NPR;
		return;
	}
	if (src == "NZD") {
		dst = CurrencyEnumType::NZD;
		return;
	}
	if (src == "OMR") {
		dst = CurrencyEnumType::OMR;
		return;
	}
	if (src == "PAB") {
		dst = CurrencyEnumType::PAB;
		return;
	}
	if (src == "PEN") {
		dst = CurrencyEnumType::PEN;
		return;
	}
	if (src == "PGK") {
		dst = CurrencyEnumType::PGK;
		return;
	}
	if (src == "PHP") {
		dst = CurrencyEnumType::PHP;
		return;
	}
	if (src == "PKR") {
		dst = CurrencyEnumType::PKR;
		return;
	}
	if (src == "PLN") {
		dst = CurrencyEnumType::PLN;
		return;
	}
	if (src == "PYG") {
		dst = CurrencyEnumType::PYG;
		return;
	}
	if (src == "QAR") {
		dst = CurrencyEnumType::QAR;
		return;
	}
	if (src == "RON") {
		dst = CurrencyEnumType::RON;
		return;
	}
	if (src == "RSD") {
		dst = CurrencyEnumType::RSD;
		return;
	}
	if (src == "RUB") {
		dst = CurrencyEnumType::RUB;
		return;
	}
	if (src == "RWF") {
		dst = CurrencyEnumType::RWF;
		return;
	}
	if (src == "SAR") {
		dst = CurrencyEnumType::var_SAR;
		return;
	}
	if (src == "SBD") {
		dst = CurrencyEnumType::SBD;
		return;
	}
	if (src == "SCR") {
		dst = CurrencyEnumType::SCR;
		return;
	}
	if (src == "SDG") {
		dst = CurrencyEnumType::SDG;
		return;
	}
	if (src == "SEK") {
		dst = CurrencyEnumType::SEK;
		return;
	}
	if (src == "SGD") {
		dst = CurrencyEnumType::SGD;
		return;
	}
	if (src == "SHP") {
		dst = CurrencyEnumType::SHP;
		return;
	}
	if (src == "SLL") {
		dst = CurrencyEnumType::SLL;
		return;
	}
	if (src == "SOS") {
		dst = CurrencyEnumType::SOS;
		return;
	}
	if (src == "SRD") {
		dst = CurrencyEnumType::SRD;
		return;
	}
	if (src == "SSP") {
		dst = CurrencyEnumType::SSP;
		return;
	}
	if (src == "STD") {
		dst = CurrencyEnumType::STD;
		return;
	}
	if (src == "SVC") {
		dst = CurrencyEnumType::SVC;
		return;
	}
	if (src == "SYP") {
		dst = CurrencyEnumType::SYP;
		return;
	}
	if (src == "SZL") {
		dst = CurrencyEnumType::SZL;
		return;
	}
	if (src == "THB") {
		dst = CurrencyEnumType::THB;
		return;
	}
	if (src == "TJS") {
		dst = CurrencyEnumType::TJS;
		return;
	}
	if (src == "TMT") {
		dst = CurrencyEnumType::TMT;
		return;
	}
	if (src == "TND") {
		dst = CurrencyEnumType::TND;
		return;
	}
	if (src == "TOP") {
		dst = CurrencyEnumType::TOP;
		return;
	}
	if (src == "TRY") {
		dst = CurrencyEnumType::TRY;
		return;
	}
	if (src == "TTD") {
		dst = CurrencyEnumType::TTD;
		return;
	}
	if (src == "TWD") {
		dst = CurrencyEnumType::TWD;
		return;
	}
	if (src == "TZS") {
		dst = CurrencyEnumType::TZS;
		return;
	}
	if (src == "UAH") {
		dst = CurrencyEnumType::UAH;
		return;
	}
	if (src == "UGX") {
		dst = CurrencyEnumType::UGX;
		return;
	}
	if (src == "USD") {
		dst = CurrencyEnumType::USD;
		return;
	}
	if (src == "USN") {
		dst = CurrencyEnumType::USN;
		return;
	}
	if (src == "UYI") {
		dst = CurrencyEnumType::UYI;
		return;
	}
	if (src == "UYU") {
		dst = CurrencyEnumType::UYU;
		return;
	}
	if (src == "UZS") {
		dst = CurrencyEnumType::UZS;
		return;
	}
	if (src == "VEF") {
		dst = CurrencyEnumType::VEF;
		return;
	}
	if (src == "VND") {
		dst = CurrencyEnumType::VND;
		return;
	}
	if (src == "VUV") {
		dst = CurrencyEnumType::VUV;
		return;
	}
	if (src == "WST") {
		dst = CurrencyEnumType::WST;
		return;
	}
	if (src == "XAF") {
		dst = CurrencyEnumType::XAF;
		return;
	}
	if (src == "XAG") {
		dst = CurrencyEnumType::XAG;
		return;
	}
	if (src == "XAU") {
		dst = CurrencyEnumType::XAU;
		return;
	}
	if (src == "XBA") {
		dst = CurrencyEnumType::XBA;
		return;
	}
	if (src == "XBB") {
		dst = CurrencyEnumType::XBB;
		return;
	}
	if (src == "XBC") {
		dst = CurrencyEnumType::XBC;
		return;
	}
	if (src == "XBD") {
		dst = CurrencyEnumType::XBD;
		return;
	}
	if (src == "XCD") {
		dst = CurrencyEnumType::XCD;
		return;
	}
	if (src == "XDR") {
		dst = CurrencyEnumType::XDR;
		return;
	}
	if (src == "XOF") {
		dst = CurrencyEnumType::XOF;
		return;
	}
	if (src == "XPD") {
		dst = CurrencyEnumType::XPD;
		return;
	}
	if (src == "XPF") {
		dst = CurrencyEnumType::XPF;
		return;
	}
	if (src == "XPT") {
		dst = CurrencyEnumType::XPT;
		return;
	}
	if (src == "XSU") {
		dst = CurrencyEnumType::XSU;
		return;
	}
	if (src == "XTS") {
		dst = CurrencyEnumType::XTS;
		return;
	}
	if (src == "XUA") {
		dst = CurrencyEnumType::XUA;
		return;
	}
	if (src == "XXX") {
		dst = CurrencyEnumType::XXX;
		return;
	}
	if (src == "YER") {
		dst = CurrencyEnumType::YER;
		return;
	}
	if (src == "ZAR") {
		dst = CurrencyEnumType::ZAR;
		return;
	}
	if (src == "ZMW") {
		dst = CurrencyEnumType::ZMW;
		return;
	}
	if (src == "ZWL") {
		dst = CurrencyEnumType::ZWL;
		return;
	}
	 return;
}
bool convertToJson(const ScopeTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ScopeTypeEnumType::ac:
		 enumName = "ac";
		break;
	case ScopeTypeEnumType::acCosPhiGrid:
		 enumName = "acCosPhiGrid";
		break;
	case ScopeTypeEnumType::acCurrentA:
		 enumName = "acCurrentA";
		break;
	case ScopeTypeEnumType::acCurrentB:
		 enumName = "acCurrentB";
		break;
	case ScopeTypeEnumType::acCurrentC:
		 enumName = "acCurrentC";
		break;
	case ScopeTypeEnumType::acFrequencyGrid:
		 enumName = "acFrequencyGrid";
		break;
	case ScopeTypeEnumType::acPowerA:
		 enumName = "acPowerA";
		break;
	case ScopeTypeEnumType::acPowerB:
		 enumName = "acPowerB";
		break;
	case ScopeTypeEnumType::acPowerC:
		 enumName = "acPowerC";
		break;
	case ScopeTypeEnumType::acPowerLimitPct:
		 enumName = "acPowerLimitPct";
		break;
	case ScopeTypeEnumType::acPowerTotal:
		 enumName = "acPowerTotal";
		break;
	case ScopeTypeEnumType::acVoltageA:
		 enumName = "acVoltageA";
		break;
	case ScopeTypeEnumType::acVoltageB:
		 enumName = "acVoltageB";
		break;
	case ScopeTypeEnumType::acVoltageC:
		 enumName = "acVoltageC";
		break;
	case ScopeTypeEnumType::acYieldDay:
		 enumName = "acYieldDay";
		break;
	case ScopeTypeEnumType::acYieldTotal:
		 enumName = "acYieldTotal";
		break;
	case ScopeTypeEnumType::dcCurrent:
		 enumName = "dcCurrent";
		break;
	case ScopeTypeEnumType::dcPower:
		 enumName = "dcPower";
		break;
	case ScopeTypeEnumType::dcString1:
		 enumName = "dcString1";
		break;
	case ScopeTypeEnumType::dcString2:
		 enumName = "dcString2";
		break;
	case ScopeTypeEnumType::dcString3:
		 enumName = "dcString3";
		break;
	case ScopeTypeEnumType::dcString4:
		 enumName = "dcString4";
		break;
	case ScopeTypeEnumType::dcString5:
		 enumName = "dcString5";
		break;
	case ScopeTypeEnumType::dcString6:
		 enumName = "dcString6";
		break;
	case ScopeTypeEnumType::dcTotal:
		 enumName = "dcTotal";
		break;
	case ScopeTypeEnumType::dcVoltage:
		 enumName = "dcVoltage";
		break;
	case ScopeTypeEnumType::dhwTemperature:
		 enumName = "dhwTemperature";
		break;
	case ScopeTypeEnumType::flowTemperature:
		 enumName = "flowTemperature";
		break;
	case ScopeTypeEnumType::outsideAirTemperature:
		 enumName = "outsideAirTemperature";
		break;
	case ScopeTypeEnumType::returnTemperature:
		 enumName = "returnTemperature";
		break;
	case ScopeTypeEnumType::roomAirTemperature:
		 enumName = "roomAirTemperature";
		break;
	case ScopeTypeEnumType::charge:
		 enumName = "charge";
		break;
	case ScopeTypeEnumType::stateOfCharge:
		 enumName = "stateOfCharge";
		break;
	case ScopeTypeEnumType::discharge:
		 enumName = "discharge";
		break;
	case ScopeTypeEnumType::gridConsumption:
		 enumName = "gridConsumption";
		break;
	case ScopeTypeEnumType::gridFeedIn:
		 enumName = "gridFeedIn";
		break;
	case ScopeTypeEnumType::selfConsumption:
		 enumName = "selfConsumption";
		break;
	case ScopeTypeEnumType::overloadProtection:
		 enumName = "overloadProtection";
		break;
	case ScopeTypeEnumType::acPower:
		 enumName = "acPower";
		break;
	case ScopeTypeEnumType::acEnergy:
		 enumName = "acEnergy";
		break;
	case ScopeTypeEnumType::acCurrent:
		 enumName = "acCurrent";
		break;
	case ScopeTypeEnumType::acVoltage:
		 enumName = "acVoltage";
		break;
	case ScopeTypeEnumType::batteryControl:
		 enumName = "batteryControl";
		break;
	case ScopeTypeEnumType::simpleIncentiveTable:
		 enumName = "simpleIncentiveTable";
		break;
	case ScopeTypeEnumType::stateOfHealth:
		 enumName = "stateOfHealth";
		break;
	case ScopeTypeEnumType::travelRange:
		 enumName = "travelRange";
		break;
	case ScopeTypeEnumType::nominalEnergyCapacity:
		 enumName = "nominalEnergyCapacity";
		break;
	case ScopeTypeEnumType::acPowerReal:
		 enumName = "acPowerReal";
		break;
	case ScopeTypeEnumType::acPowerApparent:
		 enumName = "acPowerApparent";
		break;
	case ScopeTypeEnumType::acPowerReactive:
		 enumName = "acPowerReactive";
		break;
	case ScopeTypeEnumType::acYieldMonth:
		 enumName = "acYieldMonth";
		break;
	case ScopeTypeEnumType::acYieldYear:
		 enumName = "acYieldYear";
		break;
	case ScopeTypeEnumType::acFrequency:
		 enumName = "acFrequency";
		break;
	case ScopeTypeEnumType::acCosPhi:
		 enumName = "acCosPhi";
		break;
	case ScopeTypeEnumType::dcEnergy:
		 enumName = "dcEnergy";
		break;
	case ScopeTypeEnumType::insulationResistance:
		 enumName = "insulationResistance";
		break;
	case ScopeTypeEnumType::stateOfEnergy:
		 enumName = "stateOfEnergy";
		break;
	case ScopeTypeEnumType::useableCapacity:
		 enumName = "useableCapacity";
		break;
	case ScopeTypeEnumType::dcChargeEnergy:
		 enumName = "dcChargeEnergy";
		break;
	case ScopeTypeEnumType::dcDischargeEnergy:
		 enumName = "dcDischargeEnergy";
		break;
	case ScopeTypeEnumType::loadCycleCount:
		 enumName = "loadCycleCount";
		break;
	case ScopeTypeEnumType::componentTemperature:
		 enumName = "componentTemperature";
		break;
	case ScopeTypeEnumType::gridLimit:
		 enumName = "gridLimit";
		break;
	case ScopeTypeEnumType::gridLimitFallback:
		 enumName = "gridLimitFallback";
		break;
	case ScopeTypeEnumType::acPowerApparentTotal:
		 enumName = "acPowerApparentTotal";
		break;
	case ScopeTypeEnumType::acPowerReactiveTotal:
		 enumName = "acPowerReactiveTotal";
		break;
	case ScopeTypeEnumType::acCurrentTotal:
		 enumName = "acCurrentTotal";
		break;
	case ScopeTypeEnumType::acEnergyConsumed:
		 enumName = "acEnergyConsumed";
		break;
	case ScopeTypeEnumType::acEnergyProduced:
		 enumName = "acEnergyProduced";
		break;
	case ScopeTypeEnumType::batteryAcPower:
		 enumName = "batteryAcPower";
		break;
	case ScopeTypeEnumType::batteryAcPowerPhaseSpecific:
		 enumName = "batteryAcPowerPhaseSpecific";
		break;
	case ScopeTypeEnumType::batteryDcPower:
		 enumName = "batteryDcPower";
		break;
	case ScopeTypeEnumType::pccPower:
		 enumName = "pccPower";
		break;
	case ScopeTypeEnumType::activePowerLimit:
		 enumName = "activePowerLimit";
		break;
	case ScopeTypeEnumType::activePowerLimitPercentage:
		 enumName = "activePowerLimitPercentage";
		break;
	case ScopeTypeEnumType::simpleCommittedIncentiveTable:
		 enumName = "simpleCommittedIncentiveTable";
		break;
	case ScopeTypeEnumType::simplePreliminaryIncentiveTable:
		 enumName = "simplePreliminaryIncentiveTable";
		break;
	case ScopeTypeEnumType::committedPowerPlan:
		 enumName = "committedPowerPlan";
		break;
	case ScopeTypeEnumType::preliminaryPowerPlan:
		 enumName = "preliminaryPowerPlan";
		break;
	case ScopeTypeEnumType::incentiveTableEnConsWithPoETF:
		 enumName = "incentiveTableEnConsWithPoETF";
		break;
	case ScopeTypeEnumType::incentiveTableEnProdWithPoETF:
		 enumName = "incentiveTableEnProdWithPoETF";
		break;
	case ScopeTypeEnumType::incentiveTableEnConsWithPoE:
		 enumName = "incentiveTableEnConsWithPoE";
		break;
	case ScopeTypeEnumType::incentiveTableEnProdWithPoE:
		 enumName = "incentiveTableEnProdWithPoE";
		break;
	case ScopeTypeEnumType::incentiveTableEnConsWithTF:
		 enumName = "incentiveTableEnConsWithTF";
		break;
	case ScopeTypeEnumType::incentiveTableEnProdWithTF:
		 enumName = "incentiveTableEnProdWithTF";
		break;
	case ScopeTypeEnumType::activePowerForecast:
		 enumName = "activePowerForecast";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ScopeTypeEnumType &dst) {
	if (src == "ac") {
		dst = ScopeTypeEnumType::ac;
		return;
	}
	if (src == "acCosPhiGrid") {
		dst = ScopeTypeEnumType::acCosPhiGrid;
		return;
	}
	if (src == "acCurrentA") {
		dst = ScopeTypeEnumType::acCurrentA;
		return;
	}
	if (src == "acCurrentB") {
		dst = ScopeTypeEnumType::acCurrentB;
		return;
	}
	if (src == "acCurrentC") {
		dst = ScopeTypeEnumType::acCurrentC;
		return;
	}
	if (src == "acFrequencyGrid") {
		dst = ScopeTypeEnumType::acFrequencyGrid;
		return;
	}
	if (src == "acPowerA") {
		dst = ScopeTypeEnumType::acPowerA;
		return;
	}
	if (src == "acPowerB") {
		dst = ScopeTypeEnumType::acPowerB;
		return;
	}
	if (src == "acPowerC") {
		dst = ScopeTypeEnumType::acPowerC;
		return;
	}
	if (src == "acPowerLimitPct") {
		dst = ScopeTypeEnumType::acPowerLimitPct;
		return;
	}
	if (src == "acPowerTotal") {
		dst = ScopeTypeEnumType::acPowerTotal;
		return;
	}
	if (src == "acVoltageA") {
		dst = ScopeTypeEnumType::acVoltageA;
		return;
	}
	if (src == "acVoltageB") {
		dst = ScopeTypeEnumType::acVoltageB;
		return;
	}
	if (src == "acVoltageC") {
		dst = ScopeTypeEnumType::acVoltageC;
		return;
	}
	if (src == "acYieldDay") {
		dst = ScopeTypeEnumType::acYieldDay;
		return;
	}
	if (src == "acYieldTotal") {
		dst = ScopeTypeEnumType::acYieldTotal;
		return;
	}
	if (src == "dcCurrent") {
		dst = ScopeTypeEnumType::dcCurrent;
		return;
	}
	if (src == "dcPower") {
		dst = ScopeTypeEnumType::dcPower;
		return;
	}
	if (src == "dcString1") {
		dst = ScopeTypeEnumType::dcString1;
		return;
	}
	if (src == "dcString2") {
		dst = ScopeTypeEnumType::dcString2;
		return;
	}
	if (src == "dcString3") {
		dst = ScopeTypeEnumType::dcString3;
		return;
	}
	if (src == "dcString4") {
		dst = ScopeTypeEnumType::dcString4;
		return;
	}
	if (src == "dcString5") {
		dst = ScopeTypeEnumType::dcString5;
		return;
	}
	if (src == "dcString6") {
		dst = ScopeTypeEnumType::dcString6;
		return;
	}
	if (src == "dcTotal") {
		dst = ScopeTypeEnumType::dcTotal;
		return;
	}
	if (src == "dcVoltage") {
		dst = ScopeTypeEnumType::dcVoltage;
		return;
	}
	if (src == "dhwTemperature") {
		dst = ScopeTypeEnumType::dhwTemperature;
		return;
	}
	if (src == "flowTemperature") {
		dst = ScopeTypeEnumType::flowTemperature;
		return;
	}
	if (src == "outsideAirTemperature") {
		dst = ScopeTypeEnumType::outsideAirTemperature;
		return;
	}
	if (src == "returnTemperature") {
		dst = ScopeTypeEnumType::returnTemperature;
		return;
	}
	if (src == "roomAirTemperature") {
		dst = ScopeTypeEnumType::roomAirTemperature;
		return;
	}
	if (src == "charge") {
		dst = ScopeTypeEnumType::charge;
		return;
	}
	if (src == "stateOfCharge") {
		dst = ScopeTypeEnumType::stateOfCharge;
		return;
	}
	if (src == "discharge") {
		dst = ScopeTypeEnumType::discharge;
		return;
	}
	if (src == "gridConsumption") {
		dst = ScopeTypeEnumType::gridConsumption;
		return;
	}
	if (src == "gridFeedIn") {
		dst = ScopeTypeEnumType::gridFeedIn;
		return;
	}
	if (src == "selfConsumption") {
		dst = ScopeTypeEnumType::selfConsumption;
		return;
	}
	if (src == "overloadProtection") {
		dst = ScopeTypeEnumType::overloadProtection;
		return;
	}
	if (src == "acPower") {
		dst = ScopeTypeEnumType::acPower;
		return;
	}
	if (src == "acEnergy") {
		dst = ScopeTypeEnumType::acEnergy;
		return;
	}
	if (src == "acCurrent") {
		dst = ScopeTypeEnumType::acCurrent;
		return;
	}
	if (src == "acVoltage") {
		dst = ScopeTypeEnumType::acVoltage;
		return;
	}
	if (src == "batteryControl") {
		dst = ScopeTypeEnumType::batteryControl;
		return;
	}
	if (src == "simpleIncentiveTable") {
		dst = ScopeTypeEnumType::simpleIncentiveTable;
		return;
	}
	if (src == "stateOfHealth") {
		dst = ScopeTypeEnumType::stateOfHealth;
		return;
	}
	if (src == "travelRange") {
		dst = ScopeTypeEnumType::travelRange;
		return;
	}
	if (src == "nominalEnergyCapacity") {
		dst = ScopeTypeEnumType::nominalEnergyCapacity;
		return;
	}
	if (src == "acPowerReal") {
		dst = ScopeTypeEnumType::acPowerReal;
		return;
	}
	if (src == "acPowerApparent") {
		dst = ScopeTypeEnumType::acPowerApparent;
		return;
	}
	if (src == "acPowerReactive") {
		dst = ScopeTypeEnumType::acPowerReactive;
		return;
	}
	if (src == "acYieldMonth") {
		dst = ScopeTypeEnumType::acYieldMonth;
		return;
	}
	if (src == "acYieldYear") {
		dst = ScopeTypeEnumType::acYieldYear;
		return;
	}
	if (src == "acFrequency") {
		dst = ScopeTypeEnumType::acFrequency;
		return;
	}
	if (src == "acCosPhi") {
		dst = ScopeTypeEnumType::acCosPhi;
		return;
	}
	if (src == "dcEnergy") {
		dst = ScopeTypeEnumType::dcEnergy;
		return;
	}
	if (src == "insulationResistance") {
		dst = ScopeTypeEnumType::insulationResistance;
		return;
	}
	if (src == "stateOfEnergy") {
		dst = ScopeTypeEnumType::stateOfEnergy;
		return;
	}
	if (src == "useableCapacity") {
		dst = ScopeTypeEnumType::useableCapacity;
		return;
	}
	if (src == "dcChargeEnergy") {
		dst = ScopeTypeEnumType::dcChargeEnergy;
		return;
	}
	if (src == "dcDischargeEnergy") {
		dst = ScopeTypeEnumType::dcDischargeEnergy;
		return;
	}
	if (src == "loadCycleCount") {
		dst = ScopeTypeEnumType::loadCycleCount;
		return;
	}
	if (src == "componentTemperature") {
		dst = ScopeTypeEnumType::componentTemperature;
		return;
	}
	if (src == "gridLimit") {
		dst = ScopeTypeEnumType::gridLimit;
		return;
	}
	if (src == "gridLimitFallback") {
		dst = ScopeTypeEnumType::gridLimitFallback;
		return;
	}
	if (src == "acPowerApparentTotal") {
		dst = ScopeTypeEnumType::acPowerApparentTotal;
		return;
	}
	if (src == "acPowerReactiveTotal") {
		dst = ScopeTypeEnumType::acPowerReactiveTotal;
		return;
	}
	if (src == "acCurrentTotal") {
		dst = ScopeTypeEnumType::acCurrentTotal;
		return;
	}
	if (src == "acEnergyConsumed") {
		dst = ScopeTypeEnumType::acEnergyConsumed;
		return;
	}
	if (src == "acEnergyProduced") {
		dst = ScopeTypeEnumType::acEnergyProduced;
		return;
	}
	if (src == "batteryAcPower") {
		dst = ScopeTypeEnumType::batteryAcPower;
		return;
	}
	if (src == "batteryAcPowerPhaseSpecific") {
		dst = ScopeTypeEnumType::batteryAcPowerPhaseSpecific;
		return;
	}
	if (src == "batteryDcPower") {
		dst = ScopeTypeEnumType::batteryDcPower;
		return;
	}
	if (src == "pccPower") {
		dst = ScopeTypeEnumType::pccPower;
		return;
	}
	if (src == "activePowerLimit") {
		dst = ScopeTypeEnumType::activePowerLimit;
		return;
	}
	if (src == "activePowerLimitPercentage") {
		dst = ScopeTypeEnumType::activePowerLimitPercentage;
		return;
	}
	if (src == "simpleCommittedIncentiveTable") {
		dst = ScopeTypeEnumType::simpleCommittedIncentiveTable;
		return;
	}
	if (src == "simplePreliminaryIncentiveTable") {
		dst = ScopeTypeEnumType::simplePreliminaryIncentiveTable;
		return;
	}
	if (src == "committedPowerPlan") {
		dst = ScopeTypeEnumType::committedPowerPlan;
		return;
	}
	if (src == "preliminaryPowerPlan") {
		dst = ScopeTypeEnumType::preliminaryPowerPlan;
		return;
	}
	if (src == "incentiveTableEnConsWithPoETF") {
		dst = ScopeTypeEnumType::incentiveTableEnConsWithPoETF;
		return;
	}
	if (src == "incentiveTableEnProdWithPoETF") {
		dst = ScopeTypeEnumType::incentiveTableEnProdWithPoETF;
		return;
	}
	if (src == "incentiveTableEnConsWithPoE") {
		dst = ScopeTypeEnumType::incentiveTableEnConsWithPoE;
		return;
	}
	if (src == "incentiveTableEnProdWithPoE") {
		dst = ScopeTypeEnumType::incentiveTableEnProdWithPoE;
		return;
	}
	if (src == "incentiveTableEnConsWithTF") {
		dst = ScopeTypeEnumType::incentiveTableEnConsWithTF;
		return;
	}
	if (src == "incentiveTableEnProdWithTF") {
		dst = ScopeTypeEnumType::incentiveTableEnProdWithTF;
		return;
	}
	if (src == "activePowerForecast") {
		dst = ScopeTypeEnumType::activePowerForecast;
		return;
	}
	 return;
}
bool convertToJson(const RoleType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case RoleType::client:
		 enumName = "client";
		break;
	case RoleType::server:
		 enumName = "server";
		break;
	case RoleType::special:
		 enumName = "special";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, RoleType &dst) {
	if (src == "client") {
		dst = RoleType::client;
		return;
	}
	if (src == "server") {
		dst = RoleType::server;
		return;
	}
	if (src == "special") {
		dst = RoleType::special;
		return;
	}
	 return;
}
bool convertToJson(const DeviceTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case DeviceTypeEnumType::Dishwasher:
		 enumName = "Dishwasher";
		break;
	case DeviceTypeEnumType::Dryer:
		 enumName = "Dryer";
		break;
	case DeviceTypeEnumType::EnvironmentSensor:
		 enumName = "EnvironmentSensor";
		break;
	case DeviceTypeEnumType::Generic:
		 enumName = "Generic";
		break;
	case DeviceTypeEnumType::HeatGenerationSystem:
		 enumName = "HeatGenerationSystem";
		break;
	case DeviceTypeEnumType::HeatSinkSystem:
		 enumName = "HeatSinkSystem";
		break;
	case DeviceTypeEnumType::HeatStorageSystem:
		 enumName = "HeatStorageSystem";
		break;
	case DeviceTypeEnumType::HVACController:
		 enumName = "HVACController";
		break;
	case DeviceTypeEnumType::SubMeter:
		 enumName = "SubMeter";
		break;
	case DeviceTypeEnumType::Washer:
		 enumName = "Washer";
		break;
	case DeviceTypeEnumType::ElectricitySupplySystem:
		 enumName = "ElectricitySupplySystem";
		break;
	case DeviceTypeEnumType::EnergyManagementSystem:
		 enumName = "EnergyManagementSystem";
		break;
	case DeviceTypeEnumType::Inverter:
		 enumName = "Inverter";
		break;
	case DeviceTypeEnumType::ChargingStation:
		 enumName = "ChargingStation";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceTypeEnumType &dst) {
	if (src == "Dishwasher") {
		dst = DeviceTypeEnumType::Dishwasher;
		return;
	}
	if (src == "Dryer") {
		dst = DeviceTypeEnumType::Dryer;
		return;
	}
	if (src == "EnvironmentSensor") {
		dst = DeviceTypeEnumType::EnvironmentSensor;
		return;
	}
	if (src == "Generic") {
		dst = DeviceTypeEnumType::Generic;
		return;
	}
	if (src == "HeatGenerationSystem") {
		dst = DeviceTypeEnumType::HeatGenerationSystem;
		return;
	}
	if (src == "HeatSinkSystem") {
		dst = DeviceTypeEnumType::HeatSinkSystem;
		return;
	}
	if (src == "HeatStorageSystem") {
		dst = DeviceTypeEnumType::HeatStorageSystem;
		return;
	}
	if (src == "HVACController") {
		dst = DeviceTypeEnumType::HVACController;
		return;
	}
	if (src == "SubMeter") {
		dst = DeviceTypeEnumType::SubMeter;
		return;
	}
	if (src == "Washer") {
		dst = DeviceTypeEnumType::Washer;
		return;
	}
	if (src == "ElectricitySupplySystem") {
		dst = DeviceTypeEnumType::ElectricitySupplySystem;
		return;
	}
	if (src == "EnergyManagementSystem") {
		dst = DeviceTypeEnumType::EnergyManagementSystem;
		return;
	}
	if (src == "Inverter") {
		dst = DeviceTypeEnumType::Inverter;
		return;
	}
	if (src == "ChargingStation") {
		dst = DeviceTypeEnumType::ChargingStation;
		return;
	}
	 return;
}
bool convertToJson(const EntityTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case EntityTypeEnumType::Battery:
		 enumName = "Battery";
		break;
	case EntityTypeEnumType::Compressor:
		 enumName = "Compressor";
		break;
	case EntityTypeEnumType::DeviceInformation:
		 enumName = "DeviceInformation";
		break;
	case EntityTypeEnumType::DHWCircuit:
		 enumName = "DHWCircuit";
		break;
	case EntityTypeEnumType::DHWStorage:
		 enumName = "DHWStorage";
		break;
	case EntityTypeEnumType::Dishwasher:
		 enumName = "Dishwasher";
		break;
	case EntityTypeEnumType::Dryer:
		 enumName = "Dryer";
		break;
	case EntityTypeEnumType::ElectricalImmersionHeater:
		 enumName = "ElectricalImmersionHeater";
		break;
	case EntityTypeEnumType::Fan:
		 enumName = "Fan";
		break;
	case EntityTypeEnumType::GasHeatingAppliance:
		 enumName = "GasHeatingAppliance";
		break;
	case EntityTypeEnumType::Generic:
		 enumName = "Generic";
		break;
	case EntityTypeEnumType::HeatingBufferStorage:
		 enumName = "HeatingBufferStorage";
		break;
	case EntityTypeEnumType::HeatingCircuit:
		 enumName = "HeatingCircuit";
		break;
	case EntityTypeEnumType::HeatingObject:
		 enumName = "HeatingObject";
		break;
	case EntityTypeEnumType::HeatingZone:
		 enumName = "HeatingZone";
		break;
	case EntityTypeEnumType::HeatPumpAppliance:
		 enumName = "HeatPumpAppliance";
		break;
	case EntityTypeEnumType::HeatSinkCircuit:
		 enumName = "HeatSinkCircuit";
		break;
	case EntityTypeEnumType::HeatSourceCircuit:
		 enumName = "HeatSourceCircuit";
		break;
	case EntityTypeEnumType::HeatSourceUnit:
		 enumName = "HeatSourceUnit";
		break;
	case EntityTypeEnumType::HVACController:
		 enumName = "HVACController";
		break;
	case EntityTypeEnumType::HVACRoom:
		 enumName = "HVACRoom";
		break;
	case EntityTypeEnumType::InstantDHWHeater:
		 enumName = "InstantDHWHeater";
		break;
	case EntityTypeEnumType::Inverter:
		 enumName = "Inverter";
		break;
	case EntityTypeEnumType::OilHeatingAppliance:
		 enumName = "OilHeatingAppliance";
		break;
	case EntityTypeEnumType::Pump:
		 enumName = "Pump";
		break;
	case EntityTypeEnumType::RefrigerantCircuit:
		 enumName = "RefrigerantCircuit";
		break;
	case EntityTypeEnumType::SmartEnergyAppliance:
		 enumName = "SmartEnergyAppliance";
		break;
	case EntityTypeEnumType::SolarDHWStorage:
		 enumName = "SolarDHWStorage";
		break;
	case EntityTypeEnumType::SolarThermalCircuit:
		 enumName = "SolarThermalCircuit";
		break;
	case EntityTypeEnumType::SubMeterElectricity:
		 enumName = "SubMeterElectricity";
		break;
	case EntityTypeEnumType::TemperatureSensor:
		 enumName = "TemperatureSensor";
		break;
	case EntityTypeEnumType::Washer:
		 enumName = "Washer";
		break;
	case EntityTypeEnumType::BatterySystem:
		 enumName = "BatterySystem";
		break;
	case EntityTypeEnumType::ElectricityGenerationSystem:
		 enumName = "ElectricityGenerationSystem";
		break;
	case EntityTypeEnumType::ElectricityStorageSystem:
		 enumName = "ElectricityStorageSystem";
		break;
	case EntityTypeEnumType::GridConnectionPointOfPremises:
		 enumName = "GridConnectionPointOfPremises";
		break;
	case EntityTypeEnumType::Household:
		 enumName = "Household";
		break;
	case EntityTypeEnumType::PVSystem:
		 enumName = "PVSystem";
		break;
	case EntityTypeEnumType::EV:
		 enumName = "EV";
		break;
	case EntityTypeEnumType::EVSE:
		 enumName = "EVSE";
		break;
	case EntityTypeEnumType::ChargingOutlet:
		 enumName = "ChargingOutlet";
		break;
	case EntityTypeEnumType::CEM:
		 enumName = "CEM";
		break;
	case EntityTypeEnumType::PV:
		 enumName = "PV";
		break;
	case EntityTypeEnumType::PVESHybrid:
		 enumName = "PVESHybrid";
		break;
	case EntityTypeEnumType::ElectricalStorage:
		 enumName = "ElectricalStorage";
		break;
	case EntityTypeEnumType::PVString:
		 enumName = "PVString";
		break;
	case EntityTypeEnumType::GridGuard:
		 enumName = "GridGuard";
		break;
	case EntityTypeEnumType::ControllableSystem:
		 enumName = "ControllableSystem";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, EntityTypeEnumType &dst) {
	if (src == "Battery") {
		dst = EntityTypeEnumType::Battery;
		return;
	}
	if (src == "Compressor") {
		dst = EntityTypeEnumType::Compressor;
		return;
	}
	if (src == "DeviceInformation") {
		dst = EntityTypeEnumType::DeviceInformation;
		return;
	}
	if (src == "DHWCircuit") {
		dst = EntityTypeEnumType::DHWCircuit;
		return;
	}
	if (src == "DHWStorage") {
		dst = EntityTypeEnumType::DHWStorage;
		return;
	}
	if (src == "Dishwasher") {
		dst = EntityTypeEnumType::Dishwasher;
		return;
	}
	if (src == "Dryer") {
		dst = EntityTypeEnumType::Dryer;
		return;
	}
	if (src == "ElectricalImmersionHeater") {
		dst = EntityTypeEnumType::ElectricalImmersionHeater;
		return;
	}
	if (src == "Fan") {
		dst = EntityTypeEnumType::Fan;
		return;
	}
	if (src == "GasHeatingAppliance") {
		dst = EntityTypeEnumType::GasHeatingAppliance;
		return;
	}
	if (src == "Generic") {
		dst = EntityTypeEnumType::Generic;
		return;
	}
	if (src == "HeatingBufferStorage") {
		dst = EntityTypeEnumType::HeatingBufferStorage;
		return;
	}
	if (src == "HeatingCircuit") {
		dst = EntityTypeEnumType::HeatingCircuit;
		return;
	}
	if (src == "HeatingObject") {
		dst = EntityTypeEnumType::HeatingObject;
		return;
	}
	if (src == "HeatingZone") {
		dst = EntityTypeEnumType::HeatingZone;
		return;
	}
	if (src == "HeatPumpAppliance") {
		dst = EntityTypeEnumType::HeatPumpAppliance;
		return;
	}
	if (src == "HeatSinkCircuit") {
		dst = EntityTypeEnumType::HeatSinkCircuit;
		return;
	}
	if (src == "HeatSourceCircuit") {
		dst = EntityTypeEnumType::HeatSourceCircuit;
		return;
	}
	if (src == "HeatSourceUnit") {
		dst = EntityTypeEnumType::HeatSourceUnit;
		return;
	}
	if (src == "HVACController") {
		dst = EntityTypeEnumType::HVACController;
		return;
	}
	if (src == "HVACRoom") {
		dst = EntityTypeEnumType::HVACRoom;
		return;
	}
	if (src == "InstantDHWHeater") {
		dst = EntityTypeEnumType::InstantDHWHeater;
		return;
	}
	if (src == "Inverter") {
		dst = EntityTypeEnumType::Inverter;
		return;
	}
	if (src == "OilHeatingAppliance") {
		dst = EntityTypeEnumType::OilHeatingAppliance;
		return;
	}
	if (src == "Pump") {
		dst = EntityTypeEnumType::Pump;
		return;
	}
	if (src == "RefrigerantCircuit") {
		dst = EntityTypeEnumType::RefrigerantCircuit;
		return;
	}
	if (src == "SmartEnergyAppliance") {
		dst = EntityTypeEnumType::SmartEnergyAppliance;
		return;
	}
	if (src == "SolarDHWStorage") {
		dst = EntityTypeEnumType::SolarDHWStorage;
		return;
	}
	if (src == "SolarThermalCircuit") {
		dst = EntityTypeEnumType::SolarThermalCircuit;
		return;
	}
	if (src == "SubMeterElectricity") {
		dst = EntityTypeEnumType::SubMeterElectricity;
		return;
	}
	if (src == "TemperatureSensor") {
		dst = EntityTypeEnumType::TemperatureSensor;
		return;
	}
	if (src == "Washer") {
		dst = EntityTypeEnumType::Washer;
		return;
	}
	if (src == "BatterySystem") {
		dst = EntityTypeEnumType::BatterySystem;
		return;
	}
	if (src == "ElectricityGenerationSystem") {
		dst = EntityTypeEnumType::ElectricityGenerationSystem;
		return;
	}
	if (src == "ElectricityStorageSystem") {
		dst = EntityTypeEnumType::ElectricityStorageSystem;
		return;
	}
	if (src == "GridConnectionPointOfPremises") {
		dst = EntityTypeEnumType::GridConnectionPointOfPremises;
		return;
	}
	if (src == "Household") {
		dst = EntityTypeEnumType::Household;
		return;
	}
	if (src == "PVSystem") {
		dst = EntityTypeEnumType::PVSystem;
		return;
	}
	if (src == "EV") {
		dst = EntityTypeEnumType::EV;
		return;
	}
	if (src == "EVSE") {
		dst = EntityTypeEnumType::EVSE;
		return;
	}
	if (src == "ChargingOutlet") {
		dst = EntityTypeEnumType::ChargingOutlet;
		return;
	}
	if (src == "CEM") {
		dst = EntityTypeEnumType::CEM;
		return;
	}
	if (src == "PV") {
		dst = EntityTypeEnumType::PV;
		return;
	}
	if (src == "PVESHybrid") {
		dst = EntityTypeEnumType::PVESHybrid;
		return;
	}
	if (src == "ElectricalStorage") {
		dst = EntityTypeEnumType::ElectricalStorage;
		return;
	}
	if (src == "PVString") {
		dst = EntityTypeEnumType::PVString;
		return;
	}
	if (src == "GridGuard") {
		dst = EntityTypeEnumType::GridGuard;
		return;
	}
	if (src == "ControllableSystem") {
		dst = EntityTypeEnumType::ControllableSystem;
		return;
	}
	 return;
}
bool convertToJson(const FeatureTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case FeatureTypeEnumType::ActuatorLevel:
		 enumName = "ActuatorLevel";
		break;
	case FeatureTypeEnumType::ActuatorSwitch:
		 enumName = "ActuatorSwitch";
		break;
	case FeatureTypeEnumType::Alarm:
		 enumName = "Alarm";
		break;
	case FeatureTypeEnumType::DataTunneling:
		 enumName = "DataTunneling";
		break;
	case FeatureTypeEnumType::DeviceClassification:
		 enumName = "DeviceClassification";
		break;
	case FeatureTypeEnumType::DeviceDiagnosis:
		 enumName = "DeviceDiagnosis";
		break;
	case FeatureTypeEnumType::DirectControl:
		 enumName = "DirectControl";
		break;
	case FeatureTypeEnumType::ElectricalConnection:
		 enumName = "ElectricalConnection";
		break;
	case FeatureTypeEnumType::Generic:
		 enumName = "Generic";
		break;
	case FeatureTypeEnumType::HVAC:
		 enumName = "HVAC";
		break;
	case FeatureTypeEnumType::LoadControl:
		 enumName = "LoadControl";
		break;
	case FeatureTypeEnumType::Measurement:
		 enumName = "Measurement";
		break;
	case FeatureTypeEnumType::Messaging:
		 enumName = "Messaging";
		break;
	case FeatureTypeEnumType::NetworkManagement:
		 enumName = "NetworkManagement";
		break;
	case FeatureTypeEnumType::NodeManagement:
		 enumName = "NodeManagement";
		break;
	case FeatureTypeEnumType::OperatingConstraints:
		 enumName = "OperatingConstraints";
		break;
	case FeatureTypeEnumType::PowerSequences:
		 enumName = "PowerSequences";
		break;
	case FeatureTypeEnumType::Sensing:
		 enumName = "Sensing";
		break;
	case FeatureTypeEnumType::Setpoint:
		 enumName = "Setpoint";
		break;
	case FeatureTypeEnumType::SmartEnergyManagementPs:
		 enumName = "SmartEnergyManagementPs";
		break;
	case FeatureTypeEnumType::TaskManagement:
		 enumName = "TaskManagement";
		break;
	case FeatureTypeEnumType::Threshold:
		 enumName = "Threshold";
		break;
	case FeatureTypeEnumType::TimeInformation:
		 enumName = "TimeInformation";
		break;
	case FeatureTypeEnumType::TimeTable:
		 enumName = "TimeTable";
		break;
	case FeatureTypeEnumType::DeviceConfiguration:
		 enumName = "DeviceConfiguration";
		break;
	case FeatureTypeEnumType::SupplyCondition:
		 enumName = "SupplyCondition";
		break;
	case FeatureTypeEnumType::TimeSeries:
		 enumName = "TimeSeries";
		break;
	case FeatureTypeEnumType::TariffInformation:
		 enumName = "TariffInformation";
		break;
	case FeatureTypeEnumType::IncentiveTable:
		 enumName = "IncentiveTable";
		break;
	case FeatureTypeEnumType::Bill:
		 enumName = "Bill";
		break;
	case FeatureTypeEnumType::Identification:
		 enumName = "Identification";
		break;
	case FeatureTypeEnumType::StateInformation:
		 enumName = "StateInformation";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, FeatureTypeEnumType &dst) {
	if (src == "ActuatorLevel") {
		dst = FeatureTypeEnumType::ActuatorLevel;
		return;
	}
	if (src == "ActuatorSwitch") {
		dst = FeatureTypeEnumType::ActuatorSwitch;
		return;
	}
	if (src == "Alarm") {
		dst = FeatureTypeEnumType::Alarm;
		return;
	}
	if (src == "DataTunneling") {
		dst = FeatureTypeEnumType::DataTunneling;
		return;
	}
	if (src == "DeviceClassification") {
		dst = FeatureTypeEnumType::DeviceClassification;
		return;
	}
	if (src == "DeviceDiagnosis") {
		dst = FeatureTypeEnumType::DeviceDiagnosis;
		return;
	}
	if (src == "DirectControl") {
		dst = FeatureTypeEnumType::DirectControl;
		return;
	}
	if (src == "ElectricalConnection") {
		dst = FeatureTypeEnumType::ElectricalConnection;
		return;
	}
	if (src == "Generic") {
		dst = FeatureTypeEnumType::Generic;
		return;
	}
	if (src == "HVAC") {
		dst = FeatureTypeEnumType::HVAC;
		return;
	}
	if (src == "LoadControl") {
		dst = FeatureTypeEnumType::LoadControl;
		return;
	}
	if (src == "Measurement") {
		dst = FeatureTypeEnumType::Measurement;
		return;
	}
	if (src == "Messaging") {
		dst = FeatureTypeEnumType::Messaging;
		return;
	}
	if (src == "NetworkManagement") {
		dst = FeatureTypeEnumType::NetworkManagement;
		return;
	}
	if (src == "NodeManagement") {
		dst = FeatureTypeEnumType::NodeManagement;
		return;
	}
	if (src == "OperatingConstraints") {
		dst = FeatureTypeEnumType::OperatingConstraints;
		return;
	}
	if (src == "PowerSequences") {
		dst = FeatureTypeEnumType::PowerSequences;
		return;
	}
	if (src == "Sensing") {
		dst = FeatureTypeEnumType::Sensing;
		return;
	}
	if (src == "Setpoint") {
		dst = FeatureTypeEnumType::Setpoint;
		return;
	}
	if (src == "SmartEnergyManagementPs") {
		dst = FeatureTypeEnumType::SmartEnergyManagementPs;
		return;
	}
	if (src == "TaskManagement") {
		dst = FeatureTypeEnumType::TaskManagement;
		return;
	}
	if (src == "Threshold") {
		dst = FeatureTypeEnumType::Threshold;
		return;
	}
	if (src == "TimeInformation") {
		dst = FeatureTypeEnumType::TimeInformation;
		return;
	}
	if (src == "TimeTable") {
		dst = FeatureTypeEnumType::TimeTable;
		return;
	}
	if (src == "DeviceConfiguration") {
		dst = FeatureTypeEnumType::DeviceConfiguration;
		return;
	}
	if (src == "SupplyCondition") {
		dst = FeatureTypeEnumType::SupplyCondition;
		return;
	}
	if (src == "TimeSeries") {
		dst = FeatureTypeEnumType::TimeSeries;
		return;
	}
	if (src == "TariffInformation") {
		dst = FeatureTypeEnumType::TariffInformation;
		return;
	}
	if (src == "IncentiveTable") {
		dst = FeatureTypeEnumType::IncentiveTable;
		return;
	}
	if (src == "Bill") {
		dst = FeatureTypeEnumType::Bill;
		return;
	}
	if (src == "Identification") {
		dst = FeatureTypeEnumType::Identification;
		return;
	}
	if (src == "StateInformation") {
		dst = FeatureTypeEnumType::StateInformation;
		return;
	}
	 return;
}
bool convertToJson(const FeatureDirectControlSpecificUsageEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case FeatureDirectControlSpecificUsageEnumType::History:
		 enumName = "History";
		break;
	case FeatureDirectControlSpecificUsageEnumType::RealTime:
		 enumName = "RealTime";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, FeatureDirectControlSpecificUsageEnumType &dst) {
	if (src == "History") {
		dst = FeatureDirectControlSpecificUsageEnumType::History;
		return;
	}
	if (src == "RealTime") {
		dst = FeatureDirectControlSpecificUsageEnumType::RealTime;
		return;
	}
	 return;
}
bool convertToJson(const FeatureHvacSpecificUsageEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case FeatureHvacSpecificUsageEnumType::OperationMode:
		 enumName = "OperationMode";
		break;
	case FeatureHvacSpecificUsageEnumType::Overrun:
		 enumName = "Overrun";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, FeatureHvacSpecificUsageEnumType &dst) {
	if (src == "OperationMode") {
		dst = FeatureHvacSpecificUsageEnumType::OperationMode;
		return;
	}
	if (src == "Overrun") {
		dst = FeatureHvacSpecificUsageEnumType::Overrun;
		return;
	}
	 return;
}
bool convertToJson(const FeatureMeasurementSpecificUsageEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case FeatureMeasurementSpecificUsageEnumType::Contact:
		 enumName = "Contact";
		break;
	case FeatureMeasurementSpecificUsageEnumType::Electrical:
		 enumName = "Electrical";
		break;
	case FeatureMeasurementSpecificUsageEnumType::Heat:
		 enumName = "Heat";
		break;
	case FeatureMeasurementSpecificUsageEnumType::Level:
		 enumName = "Level";
		break;
	case FeatureMeasurementSpecificUsageEnumType::Pressure:
		 enumName = "Pressure";
		break;
	case FeatureMeasurementSpecificUsageEnumType::Temperature:
		 enumName = "Temperature";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, FeatureMeasurementSpecificUsageEnumType &dst) {
	if (src == "Contact") {
		dst = FeatureMeasurementSpecificUsageEnumType::Contact;
		return;
	}
	if (src == "Electrical") {
		dst = FeatureMeasurementSpecificUsageEnumType::Electrical;
		return;
	}
	if (src == "Heat") {
		dst = FeatureMeasurementSpecificUsageEnumType::Heat;
		return;
	}
	if (src == "Level") {
		dst = FeatureMeasurementSpecificUsageEnumType::Level;
		return;
	}
	if (src == "Pressure") {
		dst = FeatureMeasurementSpecificUsageEnumType::Pressure;
		return;
	}
	if (src == "Temperature") {
		dst = FeatureMeasurementSpecificUsageEnumType::Temperature;
		return;
	}
	 return;
}
bool convertToJson(const FeatureSetpointSpecificUsageEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case FeatureSetpointSpecificUsageEnumType::Contact:
		 enumName = "Contact";
		break;
	case FeatureSetpointSpecificUsageEnumType::Electrical:
		 enumName = "Electrical";
		break;
	case FeatureSetpointSpecificUsageEnumType::Heat:
		 enumName = "Heat";
		break;
	case FeatureSetpointSpecificUsageEnumType::Level:
		 enumName = "Level";
		break;
	case FeatureSetpointSpecificUsageEnumType::Pressure:
		 enumName = "Pressure";
		break;
	case FeatureSetpointSpecificUsageEnumType::Temperature:
		 enumName = "Temperature";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, FeatureSetpointSpecificUsageEnumType &dst) {
	if (src == "Contact") {
		dst = FeatureSetpointSpecificUsageEnumType::Contact;
		return;
	}
	if (src == "Electrical") {
		dst = FeatureSetpointSpecificUsageEnumType::Electrical;
		return;
	}
	if (src == "Heat") {
		dst = FeatureSetpointSpecificUsageEnumType::Heat;
		return;
	}
	if (src == "Level") {
		dst = FeatureSetpointSpecificUsageEnumType::Level;
		return;
	}
	if (src == "Pressure") {
		dst = FeatureSetpointSpecificUsageEnumType::Pressure;
		return;
	}
	if (src == "Temperature") {
		dst = FeatureSetpointSpecificUsageEnumType::Temperature;
		return;
	}
	 return;
}
bool convertToJson(const FeatureSmartEnergyManagementPsSpecificUsageEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case FeatureSmartEnergyManagementPsSpecificUsageEnumType::FixedForecast:
		 enumName = "FixedForecast";
		break;
	case FeatureSmartEnergyManagementPsSpecificUsageEnumType::FlexibleChosenForecast:
		 enumName = "FlexibleChosenForecast";
		break;
	case FeatureSmartEnergyManagementPsSpecificUsageEnumType::FlexibleOptionalForecast:
		 enumName = "FlexibleOptionalForecast";
		break;
	case FeatureSmartEnergyManagementPsSpecificUsageEnumType::OptionalSequenceBasedImmediateControl:
		 enumName = "OptionalSequenceBasedImmediateControl";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, FeatureSmartEnergyManagementPsSpecificUsageEnumType &dst) {
	if (src == "FixedForecast") {
		dst = FeatureSmartEnergyManagementPsSpecificUsageEnumType::FixedForecast;
		return;
	}
	if (src == "FlexibleChosenForecast") {
		dst = FeatureSmartEnergyManagementPsSpecificUsageEnumType::FlexibleChosenForecast;
		return;
	}
	if (src == "FlexibleOptionalForecast") {
		dst = FeatureSmartEnergyManagementPsSpecificUsageEnumType::FlexibleOptionalForecast;
		return;
	}
	if (src == "OptionalSequenceBasedImmediateControl") {
		dst = FeatureSmartEnergyManagementPsSpecificUsageEnumType::OptionalSequenceBasedImmediateControl;
		return;
	}
	 return;
}
bool convertToJson(const FunctionEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case FunctionEnumType::actuatorLevelData:
		 enumName = "actuatorLevelData";
		break;
	case FunctionEnumType::actuatorLevelDescriptionData:
		 enumName = "actuatorLevelDescriptionData";
		break;
	case FunctionEnumType::actuatorSwitchData:
		 enumName = "actuatorSwitchData";
		break;
	case FunctionEnumType::actuatorSwitchDescriptionData:
		 enumName = "actuatorSwitchDescriptionData";
		break;
	case FunctionEnumType::alarmListData:
		 enumName = "alarmListData";
		break;
	case FunctionEnumType::bindingManagementDeleteCall:
		 enumName = "bindingManagementDeleteCall";
		break;
	case FunctionEnumType::bindingManagementEntryListData:
		 enumName = "bindingManagementEntryListData";
		break;
	case FunctionEnumType::bindingManagementRequestCall:
		 enumName = "bindingManagementRequestCall";
		break;
	case FunctionEnumType::dataTunnelingCall:
		 enumName = "dataTunnelingCall";
		break;
	case FunctionEnumType::deviceClassificationManufacturerData:
		 enumName = "deviceClassificationManufacturerData";
		break;
	case FunctionEnumType::deviceClassificationUserData:
		 enumName = "deviceClassificationUserData";
		break;
	case FunctionEnumType::deviceDiagnosisHeartbeatData:
		 enumName = "deviceDiagnosisHeartbeatData";
		break;
	case FunctionEnumType::deviceDiagnosisServiceData:
		 enumName = "deviceDiagnosisServiceData";
		break;
	case FunctionEnumType::deviceDiagnosisStateData:
		 enumName = "deviceDiagnosisStateData";
		break;
	case FunctionEnumType::directControlActivityListData:
		 enumName = "directControlActivityListData";
		break;
	case FunctionEnumType::directControlDescriptionData:
		 enumName = "directControlDescriptionData";
		break;
	case FunctionEnumType::electricalConnectionDescriptionListData:
		 enumName = "electricalConnectionDescriptionListData";
		break;
	case FunctionEnumType::electricalConnectionParameterDescriptionListData:
		 enumName = "electricalConnectionParameterDescriptionListData";
		break;
	case FunctionEnumType::electricalConnectionStateListData:
		 enumName = "electricalConnectionStateListData";
		break;
	case FunctionEnumType::hvacOperationModeDescriptionListData:
		 enumName = "hvacOperationModeDescriptionListData";
		break;
	case FunctionEnumType::hvacOverrunDescriptionListData:
		 enumName = "hvacOverrunDescriptionListData";
		break;
	case FunctionEnumType::hvacOverrunListData:
		 enumName = "hvacOverrunListData";
		break;
	case FunctionEnumType::hvacSystemFunctionDescriptionListData:
		 enumName = "hvacSystemFunctionDescriptionListData";
		break;
	case FunctionEnumType::hvacSystemFunctionListData:
		 enumName = "hvacSystemFunctionListData";
		break;
	case FunctionEnumType::hvacSystemFunctionOperationModeRelationListData:
		 enumName = "hvacSystemFunctionOperationModeRelationListData";
		break;
	case FunctionEnumType::hvacSystemFunctionPowerSequenceRelationListData:
		 enumName = "hvacSystemFunctionPowerSequenceRelationListData";
		break;
	case FunctionEnumType::hvacSystemFunctionSetpointRelationListData:
		 enumName = "hvacSystemFunctionSetpointRelationListData";
		break;
	case FunctionEnumType::loadControlEventListData:
		 enumName = "loadControlEventListData";
		break;
	case FunctionEnumType::loadControlStateListData:
		 enumName = "loadControlStateListData";
		break;
	case FunctionEnumType::measurementConstraintsListData:
		 enumName = "measurementConstraintsListData";
		break;
	case FunctionEnumType::measurementDescriptionListData:
		 enumName = "measurementDescriptionListData";
		break;
	case FunctionEnumType::measurementListData:
		 enumName = "measurementListData";
		break;
	case FunctionEnumType::measurementThresholdRelationListData:
		 enumName = "measurementThresholdRelationListData";
		break;
	case FunctionEnumType::messagingListData:
		 enumName = "messagingListData";
		break;
	case FunctionEnumType::networkManagementAbortCall:
		 enumName = "networkManagementAbortCall";
		break;
	case FunctionEnumType::networkManagementAddNodeCall:
		 enumName = "networkManagementAddNodeCall";
		break;
	case FunctionEnumType::networkManagementDeviceDescriptionListData:
		 enumName = "networkManagementDeviceDescriptionListData";
		break;
	case FunctionEnumType::networkManagementDiscoverCall:
		 enumName = "networkManagementDiscoverCall";
		break;
	case FunctionEnumType::networkManagementEntityDescriptionListData:
		 enumName = "networkManagementEntityDescriptionListData";
		break;
	case FunctionEnumType::networkManagementFeatureDescriptionListData:
		 enumName = "networkManagementFeatureDescriptionListData";
		break;
	case FunctionEnumType::networkManagementJoiningModeData:
		 enumName = "networkManagementJoiningModeData";
		break;
	case FunctionEnumType::networkManagementModifyNodeCall:
		 enumName = "networkManagementModifyNodeCall";
		break;
	case FunctionEnumType::networkManagementProcessStateData:
		 enumName = "networkManagementProcessStateData";
		break;
	case FunctionEnumType::networkManagementRemoveNodeCall:
		 enumName = "networkManagementRemoveNodeCall";
		break;
	case FunctionEnumType::networkManagementReportCandidateData:
		 enumName = "networkManagementReportCandidateData";
		break;
	case FunctionEnumType::networkManagementScanNetworkCall:
		 enumName = "networkManagementScanNetworkCall";
		break;
	case FunctionEnumType::nodeManagementBindingData:
		 enumName = "nodeManagementBindingData";
		break;
	case FunctionEnumType::nodeManagementBindingDeleteCall:
		 enumName = "nodeManagementBindingDeleteCall";
		break;
	case FunctionEnumType::nodeManagementBindingRequestCall:
		 enumName = "nodeManagementBindingRequestCall";
		break;
	case FunctionEnumType::nodeManagementDestinationListData:
		 enumName = "nodeManagementDestinationListData";
		break;
	case FunctionEnumType::nodeManagementDetailedDiscoveryData:
		 enumName = "nodeManagementDetailedDiscoveryData";
		break;
	case FunctionEnumType::nodeManagementSubscriptionData:
		 enumName = "nodeManagementSubscriptionData";
		break;
	case FunctionEnumType::nodeManagementSubscriptionDeleteCall:
		 enumName = "nodeManagementSubscriptionDeleteCall";
		break;
	case FunctionEnumType::nodeManagementSubscriptionRequestCall:
		 enumName = "nodeManagementSubscriptionRequestCall";
		break;
	case FunctionEnumType::operatingConstraintsDurationListData:
		 enumName = "operatingConstraintsDurationListData";
		break;
	case FunctionEnumType::operatingConstraintsInterruptListData:
		 enumName = "operatingConstraintsInterruptListData";
		break;
	case FunctionEnumType::operatingConstraintsPowerDescriptionListData:
		 enumName = "operatingConstraintsPowerDescriptionListData";
		break;
	case FunctionEnumType::operatingConstraintsPowerLevelListData:
		 enumName = "operatingConstraintsPowerLevelListData";
		break;
	case FunctionEnumType::operatingConstraintsPowerRangeListData:
		 enumName = "operatingConstraintsPowerRangeListData";
		break;
	case FunctionEnumType::operatingConstraintsResumeImplicationListData:
		 enumName = "operatingConstraintsResumeImplicationListData";
		break;
	case FunctionEnumType::powerSequenceAlternativesRelationListData:
		 enumName = "powerSequenceAlternativesRelationListData";
		break;
	case FunctionEnumType::powerSequenceDescriptionListData:
		 enumName = "powerSequenceDescriptionListData";
		break;
	case FunctionEnumType::powerSequenceNodeScheduleInformationData:
		 enumName = "powerSequenceNodeScheduleInformationData";
		break;
	case FunctionEnumType::powerSequencePriceCalculationRequestCall:
		 enumName = "powerSequencePriceCalculationRequestCall";
		break;
	case FunctionEnumType::powerSequencePriceListData:
		 enumName = "powerSequencePriceListData";
		break;
	case FunctionEnumType::powerSequenceScheduleConfigurationRequestCall:
		 enumName = "powerSequenceScheduleConfigurationRequestCall";
		break;
	case FunctionEnumType::powerSequenceScheduleConstraintsListData:
		 enumName = "powerSequenceScheduleConstraintsListData";
		break;
	case FunctionEnumType::powerSequenceScheduleListData:
		 enumName = "powerSequenceScheduleListData";
		break;
	case FunctionEnumType::powerSequenceSchedulePreferenceListData:
		 enumName = "powerSequenceSchedulePreferenceListData";
		break;
	case FunctionEnumType::powerSequenceStateListData:
		 enumName = "powerSequenceStateListData";
		break;
	case FunctionEnumType::powerTimeSlotScheduleConstraintsListData:
		 enumName = "powerTimeSlotScheduleConstraintsListData";
		break;
	case FunctionEnumType::powerTimeSlotScheduleListData:
		 enumName = "powerTimeSlotScheduleListData";
		break;
	case FunctionEnumType::powerTimeSlotValueListData:
		 enumName = "powerTimeSlotValueListData";
		break;
	case FunctionEnumType::resultData:
		 enumName = "resultData";
		break;
	case FunctionEnumType::sensingDescriptionData:
		 enumName = "sensingDescriptionData";
		break;
	case FunctionEnumType::sensingListData:
		 enumName = "sensingListData";
		break;
	case FunctionEnumType::sessionIdentificationListData:
		 enumName = "sessionIdentificationListData";
		break;
	case FunctionEnumType::sessionMeasurementRelationListData:
		 enumName = "sessionMeasurementRelationListData";
		break;
	case FunctionEnumType::setpointConstraintsListData:
		 enumName = "setpointConstraintsListData";
		break;
	case FunctionEnumType::setpointDescriptionListData:
		 enumName = "setpointDescriptionListData";
		break;
	case FunctionEnumType::setpointListData:
		 enumName = "setpointListData";
		break;
	case FunctionEnumType::smartEnergyManagementPsConfigurationRequestCall:
		 enumName = "smartEnergyManagementPsConfigurationRequestCall";
		break;
	case FunctionEnumType::smartEnergyManagementPsData:
		 enumName = "smartEnergyManagementPsData";
		break;
	case FunctionEnumType::smartEnergyManagementPsPriceCalculationRequestCall:
		 enumName = "smartEnergyManagementPsPriceCalculationRequestCall";
		break;
	case FunctionEnumType::smartEnergyManagementPsPriceData:
		 enumName = "smartEnergyManagementPsPriceData";
		break;
	case FunctionEnumType::specificationVersionListData:
		 enumName = "specificationVersionListData";
		break;
	case FunctionEnumType::subscriptionManagementDeleteCall:
		 enumName = "subscriptionManagementDeleteCall";
		break;
	case FunctionEnumType::subscriptionManagementEntryListData:
		 enumName = "subscriptionManagementEntryListData";
		break;
	case FunctionEnumType::subscriptionManagementRequestCall:
		 enumName = "subscriptionManagementRequestCall";
		break;
	case FunctionEnumType::supplyConditionDescriptionListData:
		 enumName = "supplyConditionDescriptionListData";
		break;
	case FunctionEnumType::supplyConditionListData:
		 enumName = "supplyConditionListData";
		break;
	case FunctionEnumType::supplyConditionThresholdRelationListData:
		 enumName = "supplyConditionThresholdRelationListData";
		break;
	case FunctionEnumType::taskManagementJobDescriptionListData:
		 enumName = "taskManagementJobDescriptionListData";
		break;
	case FunctionEnumType::taskManagementJobListData:
		 enumName = "taskManagementJobListData";
		break;
	case FunctionEnumType::taskManagementJobRelationListData:
		 enumName = "taskManagementJobRelationListData";
		break;
	case FunctionEnumType::taskManagementOverviewData:
		 enumName = "taskManagementOverviewData";
		break;
	case FunctionEnumType::thresholdConstraintsListData:
		 enumName = "thresholdConstraintsListData";
		break;
	case FunctionEnumType::thresholdDescriptionListData:
		 enumName = "thresholdDescriptionListData";
		break;
	case FunctionEnumType::thresholdListData:
		 enumName = "thresholdListData";
		break;
	case FunctionEnumType::timeDistributorData:
		 enumName = "timeDistributorData";
		break;
	case FunctionEnumType::timeDistributorEnquiryCall:
		 enumName = "timeDistributorEnquiryCall";
		break;
	case FunctionEnumType::timeInformationData:
		 enumName = "timeInformationData";
		break;
	case FunctionEnumType::timePrecisionData:
		 enumName = "timePrecisionData";
		break;
	case FunctionEnumType::timeTableConstraintsListData:
		 enumName = "timeTableConstraintsListData";
		break;
	case FunctionEnumType::timeTableDescriptionListData:
		 enumName = "timeTableDescriptionListData";
		break;
	case FunctionEnumType::timeTableListData:
		 enumName = "timeTableListData";
		break;
	case FunctionEnumType::deviceConfigurationKeyValueConstraintsListData:
		 enumName = "deviceConfigurationKeyValueConstraintsListData";
		break;
	case FunctionEnumType::deviceConfigurationKeyValueListData:
		 enumName = "deviceConfigurationKeyValueListData";
		break;
	case FunctionEnumType::deviceConfigurationKeyValueDescriptionListData:
		 enumName = "deviceConfigurationKeyValueDescriptionListData";
		break;
	case FunctionEnumType::loadControlLimitConstraintsListData:
		 enumName = "loadControlLimitConstraintsListData";
		break;
	case FunctionEnumType::loadControlLimitDescriptionListData:
		 enumName = "loadControlLimitDescriptionListData";
		break;
	case FunctionEnumType::loadControlLimitListData:
		 enumName = "loadControlLimitListData";
		break;
	case FunctionEnumType::loadControlNodeData:
		 enumName = "loadControlNodeData";
		break;
	case FunctionEnumType::timeSeriesConstraintsListData:
		 enumName = "timeSeriesConstraintsListData";
		break;
	case FunctionEnumType::timeSeriesDescriptionListData:
		 enumName = "timeSeriesDescriptionListData";
		break;
	case FunctionEnumType::timeSeriesListData:
		 enumName = "timeSeriesListData";
		break;
	case FunctionEnumType::tariffOverallConstraintsData:
		 enumName = "tariffOverallConstraintsData";
		break;
	case FunctionEnumType::tariffListData:
		 enumName = "tariffListData";
		break;
	case FunctionEnumType::tariffBoundaryRelationListData:
		 enumName = "tariffBoundaryRelationListData";
		break;
	case FunctionEnumType::tariffTierRelationListData:
		 enumName = "tariffTierRelationListData";
		break;
	case FunctionEnumType::tariffDescriptionListData:
		 enumName = "tariffDescriptionListData";
		break;
	case FunctionEnumType::tierBoundaryListData:
		 enumName = "tierBoundaryListData";
		break;
	case FunctionEnumType::tierBoundaryDescriptionListData:
		 enumName = "tierBoundaryDescriptionListData";
		break;
	case FunctionEnumType::commodityListData:
		 enumName = "commodityListData";
		break;
	case FunctionEnumType::tierListData:
		 enumName = "tierListData";
		break;
	case FunctionEnumType::tierIncentiveRelationListData:
		 enumName = "tierIncentiveRelationListData";
		break;
	case FunctionEnumType::tierDescriptionListData:
		 enumName = "tierDescriptionListData";
		break;
	case FunctionEnumType::incentiveListData:
		 enumName = "incentiveListData";
		break;
	case FunctionEnumType::incentiveDescriptionListData:
		 enumName = "incentiveDescriptionListData";
		break;
	case FunctionEnumType::incentiveTableData:
		 enumName = "incentiveTableData";
		break;
	case FunctionEnumType::incentiveTableDescriptionData:
		 enumName = "incentiveTableDescriptionData";
		break;
	case FunctionEnumType::incentiveTableConstraintsData:
		 enumName = "incentiveTableConstraintsData";
		break;
	case FunctionEnumType::electricalConnectionPermittedValueSetListData:
		 enumName = "electricalConnectionPermittedValueSetListData";
		break;
	case FunctionEnumType::useCaseInformationListData:
		 enumName = "useCaseInformationListData";
		break;
	case FunctionEnumType::nodeManagementUseCaseData:
		 enumName = "nodeManagementUseCaseData";
		break;
	case FunctionEnumType::billConstraintsListData:
		 enumName = "billConstraintsListData";
		break;
	case FunctionEnumType::billDescriptionListData:
		 enumName = "billDescriptionListData";
		break;
	case FunctionEnumType::billListData:
		 enumName = "billListData";
		break;
	case FunctionEnumType::identificationListData:
		 enumName = "identificationListData";
		break;
	case FunctionEnumType::measurementSeriesListData:
		 enumName = "measurementSeriesListData";
		break;
	case FunctionEnumType::electricalConnectionCharacteristicListData:
		 enumName = "electricalConnectionCharacteristicListData";
		break;
	case FunctionEnumType::stateInformationListData:
		 enumName = "stateInformationListData";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, FunctionEnumType &dst) {
	if (src == "actuatorLevelData") {
		dst = FunctionEnumType::actuatorLevelData;
		return;
	}
	if (src == "actuatorLevelDescriptionData") {
		dst = FunctionEnumType::actuatorLevelDescriptionData;
		return;
	}
	if (src == "actuatorSwitchData") {
		dst = FunctionEnumType::actuatorSwitchData;
		return;
	}
	if (src == "actuatorSwitchDescriptionData") {
		dst = FunctionEnumType::actuatorSwitchDescriptionData;
		return;
	}
	if (src == "alarmListData") {
		dst = FunctionEnumType::alarmListData;
		return;
	}
	if (src == "bindingManagementDeleteCall") {
		dst = FunctionEnumType::bindingManagementDeleteCall;
		return;
	}
	if (src == "bindingManagementEntryListData") {
		dst = FunctionEnumType::bindingManagementEntryListData;
		return;
	}
	if (src == "bindingManagementRequestCall") {
		dst = FunctionEnumType::bindingManagementRequestCall;
		return;
	}
	if (src == "dataTunnelingCall") {
		dst = FunctionEnumType::dataTunnelingCall;
		return;
	}
	if (src == "deviceClassificationManufacturerData") {
		dst = FunctionEnumType::deviceClassificationManufacturerData;
		return;
	}
	if (src == "deviceClassificationUserData") {
		dst = FunctionEnumType::deviceClassificationUserData;
		return;
	}
	if (src == "deviceDiagnosisHeartbeatData") {
		dst = FunctionEnumType::deviceDiagnosisHeartbeatData;
		return;
	}
	if (src == "deviceDiagnosisServiceData") {
		dst = FunctionEnumType::deviceDiagnosisServiceData;
		return;
	}
	if (src == "deviceDiagnosisStateData") {
		dst = FunctionEnumType::deviceDiagnosisStateData;
		return;
	}
	if (src == "directControlActivityListData") {
		dst = FunctionEnumType::directControlActivityListData;
		return;
	}
	if (src == "directControlDescriptionData") {
		dst = FunctionEnumType::directControlDescriptionData;
		return;
	}
	if (src == "electricalConnectionDescriptionListData") {
		dst = FunctionEnumType::electricalConnectionDescriptionListData;
		return;
	}
	if (src == "electricalConnectionParameterDescriptionListData") {
		dst = FunctionEnumType::electricalConnectionParameterDescriptionListData;
		return;
	}
	if (src == "electricalConnectionStateListData") {
		dst = FunctionEnumType::electricalConnectionStateListData;
		return;
	}
	if (src == "hvacOperationModeDescriptionListData") {
		dst = FunctionEnumType::hvacOperationModeDescriptionListData;
		return;
	}
	if (src == "hvacOverrunDescriptionListData") {
		dst = FunctionEnumType::hvacOverrunDescriptionListData;
		return;
	}
	if (src == "hvacOverrunListData") {
		dst = FunctionEnumType::hvacOverrunListData;
		return;
	}
	if (src == "hvacSystemFunctionDescriptionListData") {
		dst = FunctionEnumType::hvacSystemFunctionDescriptionListData;
		return;
	}
	if (src == "hvacSystemFunctionListData") {
		dst = FunctionEnumType::hvacSystemFunctionListData;
		return;
	}
	if (src == "hvacSystemFunctionOperationModeRelationListData") {
		dst = FunctionEnumType::hvacSystemFunctionOperationModeRelationListData;
		return;
	}
	if (src == "hvacSystemFunctionPowerSequenceRelationListData") {
		dst = FunctionEnumType::hvacSystemFunctionPowerSequenceRelationListData;
		return;
	}
	if (src == "hvacSystemFunctionSetpointRelationListData") {
		dst = FunctionEnumType::hvacSystemFunctionSetpointRelationListData;
		return;
	}
	if (src == "loadControlEventListData") {
		dst = FunctionEnumType::loadControlEventListData;
		return;
	}
	if (src == "loadControlStateListData") {
		dst = FunctionEnumType::loadControlStateListData;
		return;
	}
	if (src == "measurementConstraintsListData") {
		dst = FunctionEnumType::measurementConstraintsListData;
		return;
	}
	if (src == "measurementDescriptionListData") {
		dst = FunctionEnumType::measurementDescriptionListData;
		return;
	}
	if (src == "measurementListData") {
		dst = FunctionEnumType::measurementListData;
		return;
	}
	if (src == "measurementThresholdRelationListData") {
		dst = FunctionEnumType::measurementThresholdRelationListData;
		return;
	}
	if (src == "messagingListData") {
		dst = FunctionEnumType::messagingListData;
		return;
	}
	if (src == "networkManagementAbortCall") {
		dst = FunctionEnumType::networkManagementAbortCall;
		return;
	}
	if (src == "networkManagementAddNodeCall") {
		dst = FunctionEnumType::networkManagementAddNodeCall;
		return;
	}
	if (src == "networkManagementDeviceDescriptionListData") {
		dst = FunctionEnumType::networkManagementDeviceDescriptionListData;
		return;
	}
	if (src == "networkManagementDiscoverCall") {
		dst = FunctionEnumType::networkManagementDiscoverCall;
		return;
	}
	if (src == "networkManagementEntityDescriptionListData") {
		dst = FunctionEnumType::networkManagementEntityDescriptionListData;
		return;
	}
	if (src == "networkManagementFeatureDescriptionListData") {
		dst = FunctionEnumType::networkManagementFeatureDescriptionListData;
		return;
	}
	if (src == "networkManagementJoiningModeData") {
		dst = FunctionEnumType::networkManagementJoiningModeData;
		return;
	}
	if (src == "networkManagementModifyNodeCall") {
		dst = FunctionEnumType::networkManagementModifyNodeCall;
		return;
	}
	if (src == "networkManagementProcessStateData") {
		dst = FunctionEnumType::networkManagementProcessStateData;
		return;
	}
	if (src == "networkManagementRemoveNodeCall") {
		dst = FunctionEnumType::networkManagementRemoveNodeCall;
		return;
	}
	if (src == "networkManagementReportCandidateData") {
		dst = FunctionEnumType::networkManagementReportCandidateData;
		return;
	}
	if (src == "networkManagementScanNetworkCall") {
		dst = FunctionEnumType::networkManagementScanNetworkCall;
		return;
	}
	if (src == "nodeManagementBindingData") {
		dst = FunctionEnumType::nodeManagementBindingData;
		return;
	}
	if (src == "nodeManagementBindingDeleteCall") {
		dst = FunctionEnumType::nodeManagementBindingDeleteCall;
		return;
	}
	if (src == "nodeManagementBindingRequestCall") {
		dst = FunctionEnumType::nodeManagementBindingRequestCall;
		return;
	}
	if (src == "nodeManagementDestinationListData") {
		dst = FunctionEnumType::nodeManagementDestinationListData;
		return;
	}
	if (src == "nodeManagementDetailedDiscoveryData") {
		dst = FunctionEnumType::nodeManagementDetailedDiscoveryData;
		return;
	}
	if (src == "nodeManagementSubscriptionData") {
		dst = FunctionEnumType::nodeManagementSubscriptionData;
		return;
	}
	if (src == "nodeManagementSubscriptionDeleteCall") {
		dst = FunctionEnumType::nodeManagementSubscriptionDeleteCall;
		return;
	}
	if (src == "nodeManagementSubscriptionRequestCall") {
		dst = FunctionEnumType::nodeManagementSubscriptionRequestCall;
		return;
	}
	if (src == "operatingConstraintsDurationListData") {
		dst = FunctionEnumType::operatingConstraintsDurationListData;
		return;
	}
	if (src == "operatingConstraintsInterruptListData") {
		dst = FunctionEnumType::operatingConstraintsInterruptListData;
		return;
	}
	if (src == "operatingConstraintsPowerDescriptionListData") {
		dst = FunctionEnumType::operatingConstraintsPowerDescriptionListData;
		return;
	}
	if (src == "operatingConstraintsPowerLevelListData") {
		dst = FunctionEnumType::operatingConstraintsPowerLevelListData;
		return;
	}
	if (src == "operatingConstraintsPowerRangeListData") {
		dst = FunctionEnumType::operatingConstraintsPowerRangeListData;
		return;
	}
	if (src == "operatingConstraintsResumeImplicationListData") {
		dst = FunctionEnumType::operatingConstraintsResumeImplicationListData;
		return;
	}
	if (src == "powerSequenceAlternativesRelationListData") {
		dst = FunctionEnumType::powerSequenceAlternativesRelationListData;
		return;
	}
	if (src == "powerSequenceDescriptionListData") {
		dst = FunctionEnumType::powerSequenceDescriptionListData;
		return;
	}
	if (src == "powerSequenceNodeScheduleInformationData") {
		dst = FunctionEnumType::powerSequenceNodeScheduleInformationData;
		return;
	}
	if (src == "powerSequencePriceCalculationRequestCall") {
		dst = FunctionEnumType::powerSequencePriceCalculationRequestCall;
		return;
	}
	if (src == "powerSequencePriceListData") {
		dst = FunctionEnumType::powerSequencePriceListData;
		return;
	}
	if (src == "powerSequenceScheduleConfigurationRequestCall") {
		dst = FunctionEnumType::powerSequenceScheduleConfigurationRequestCall;
		return;
	}
	if (src == "powerSequenceScheduleConstraintsListData") {
		dst = FunctionEnumType::powerSequenceScheduleConstraintsListData;
		return;
	}
	if (src == "powerSequenceScheduleListData") {
		dst = FunctionEnumType::powerSequenceScheduleListData;
		return;
	}
	if (src == "powerSequenceSchedulePreferenceListData") {
		dst = FunctionEnumType::powerSequenceSchedulePreferenceListData;
		return;
	}
	if (src == "powerSequenceStateListData") {
		dst = FunctionEnumType::powerSequenceStateListData;
		return;
	}
	if (src == "powerTimeSlotScheduleConstraintsListData") {
		dst = FunctionEnumType::powerTimeSlotScheduleConstraintsListData;
		return;
	}
	if (src == "powerTimeSlotScheduleListData") {
		dst = FunctionEnumType::powerTimeSlotScheduleListData;
		return;
	}
	if (src == "powerTimeSlotValueListData") {
		dst = FunctionEnumType::powerTimeSlotValueListData;
		return;
	}
	if (src == "resultData") {
		dst = FunctionEnumType::resultData;
		return;
	}
	if (src == "sensingDescriptionData") {
		dst = FunctionEnumType::sensingDescriptionData;
		return;
	}
	if (src == "sensingListData") {
		dst = FunctionEnumType::sensingListData;
		return;
	}
	if (src == "sessionIdentificationListData") {
		dst = FunctionEnumType::sessionIdentificationListData;
		return;
	}
	if (src == "sessionMeasurementRelationListData") {
		dst = FunctionEnumType::sessionMeasurementRelationListData;
		return;
	}
	if (src == "setpointConstraintsListData") {
		dst = FunctionEnumType::setpointConstraintsListData;
		return;
	}
	if (src == "setpointDescriptionListData") {
		dst = FunctionEnumType::setpointDescriptionListData;
		return;
	}
	if (src == "setpointListData") {
		dst = FunctionEnumType::setpointListData;
		return;
	}
	if (src == "smartEnergyManagementPsConfigurationRequestCall") {
		dst = FunctionEnumType::smartEnergyManagementPsConfigurationRequestCall;
		return;
	}
	if (src == "smartEnergyManagementPsData") {
		dst = FunctionEnumType::smartEnergyManagementPsData;
		return;
	}
	if (src == "smartEnergyManagementPsPriceCalculationRequestCall") {
		dst = FunctionEnumType::smartEnergyManagementPsPriceCalculationRequestCall;
		return;
	}
	if (src == "smartEnergyManagementPsPriceData") {
		dst = FunctionEnumType::smartEnergyManagementPsPriceData;
		return;
	}
	if (src == "specificationVersionListData") {
		dst = FunctionEnumType::specificationVersionListData;
		return;
	}
	if (src == "subscriptionManagementDeleteCall") {
		dst = FunctionEnumType::subscriptionManagementDeleteCall;
		return;
	}
	if (src == "subscriptionManagementEntryListData") {
		dst = FunctionEnumType::subscriptionManagementEntryListData;
		return;
	}
	if (src == "subscriptionManagementRequestCall") {
		dst = FunctionEnumType::subscriptionManagementRequestCall;
		return;
	}
	if (src == "supplyConditionDescriptionListData") {
		dst = FunctionEnumType::supplyConditionDescriptionListData;
		return;
	}
	if (src == "supplyConditionListData") {
		dst = FunctionEnumType::supplyConditionListData;
		return;
	}
	if (src == "supplyConditionThresholdRelationListData") {
		dst = FunctionEnumType::supplyConditionThresholdRelationListData;
		return;
	}
	if (src == "taskManagementJobDescriptionListData") {
		dst = FunctionEnumType::taskManagementJobDescriptionListData;
		return;
	}
	if (src == "taskManagementJobListData") {
		dst = FunctionEnumType::taskManagementJobListData;
		return;
	}
	if (src == "taskManagementJobRelationListData") {
		dst = FunctionEnumType::taskManagementJobRelationListData;
		return;
	}
	if (src == "taskManagementOverviewData") {
		dst = FunctionEnumType::taskManagementOverviewData;
		return;
	}
	if (src == "thresholdConstraintsListData") {
		dst = FunctionEnumType::thresholdConstraintsListData;
		return;
	}
	if (src == "thresholdDescriptionListData") {
		dst = FunctionEnumType::thresholdDescriptionListData;
		return;
	}
	if (src == "thresholdListData") {
		dst = FunctionEnumType::thresholdListData;
		return;
	}
	if (src == "timeDistributorData") {
		dst = FunctionEnumType::timeDistributorData;
		return;
	}
	if (src == "timeDistributorEnquiryCall") {
		dst = FunctionEnumType::timeDistributorEnquiryCall;
		return;
	}
	if (src == "timeInformationData") {
		dst = FunctionEnumType::timeInformationData;
		return;
	}
	if (src == "timePrecisionData") {
		dst = FunctionEnumType::timePrecisionData;
		return;
	}
	if (src == "timeTableConstraintsListData") {
		dst = FunctionEnumType::timeTableConstraintsListData;
		return;
	}
	if (src == "timeTableDescriptionListData") {
		dst = FunctionEnumType::timeTableDescriptionListData;
		return;
	}
	if (src == "timeTableListData") {
		dst = FunctionEnumType::timeTableListData;
		return;
	}
	if (src == "deviceConfigurationKeyValueConstraintsListData") {
		dst = FunctionEnumType::deviceConfigurationKeyValueConstraintsListData;
		return;
	}
	if (src == "deviceConfigurationKeyValueListData") {
		dst = FunctionEnumType::deviceConfigurationKeyValueListData;
		return;
	}
	if (src == "deviceConfigurationKeyValueDescriptionListData") {
		dst = FunctionEnumType::deviceConfigurationKeyValueDescriptionListData;
		return;
	}
	if (src == "loadControlLimitConstraintsListData") {
		dst = FunctionEnumType::loadControlLimitConstraintsListData;
		return;
	}
	if (src == "loadControlLimitDescriptionListData") {
		dst = FunctionEnumType::loadControlLimitDescriptionListData;
		return;
	}
	if (src == "loadControlLimitListData") {
		dst = FunctionEnumType::loadControlLimitListData;
		return;
	}
	if (src == "loadControlNodeData") {
		dst = FunctionEnumType::loadControlNodeData;
		return;
	}
	if (src == "timeSeriesConstraintsListData") {
		dst = FunctionEnumType::timeSeriesConstraintsListData;
		return;
	}
	if (src == "timeSeriesDescriptionListData") {
		dst = FunctionEnumType::timeSeriesDescriptionListData;
		return;
	}
	if (src == "timeSeriesListData") {
		dst = FunctionEnumType::timeSeriesListData;
		return;
	}
	if (src == "tariffOverallConstraintsData") {
		dst = FunctionEnumType::tariffOverallConstraintsData;
		return;
	}
	if (src == "tariffListData") {
		dst = FunctionEnumType::tariffListData;
		return;
	}
	if (src == "tariffBoundaryRelationListData") {
		dst = FunctionEnumType::tariffBoundaryRelationListData;
		return;
	}
	if (src == "tariffTierRelationListData") {
		dst = FunctionEnumType::tariffTierRelationListData;
		return;
	}
	if (src == "tariffDescriptionListData") {
		dst = FunctionEnumType::tariffDescriptionListData;
		return;
	}
	if (src == "tierBoundaryListData") {
		dst = FunctionEnumType::tierBoundaryListData;
		return;
	}
	if (src == "tierBoundaryDescriptionListData") {
		dst = FunctionEnumType::tierBoundaryDescriptionListData;
		return;
	}
	if (src == "commodityListData") {
		dst = FunctionEnumType::commodityListData;
		return;
	}
	if (src == "tierListData") {
		dst = FunctionEnumType::tierListData;
		return;
	}
	if (src == "tierIncentiveRelationListData") {
		dst = FunctionEnumType::tierIncentiveRelationListData;
		return;
	}
	if (src == "tierDescriptionListData") {
		dst = FunctionEnumType::tierDescriptionListData;
		return;
	}
	if (src == "incentiveListData") {
		dst = FunctionEnumType::incentiveListData;
		return;
	}
	if (src == "incentiveDescriptionListData") {
		dst = FunctionEnumType::incentiveDescriptionListData;
		return;
	}
	if (src == "incentiveTableData") {
		dst = FunctionEnumType::incentiveTableData;
		return;
	}
	if (src == "incentiveTableDescriptionData") {
		dst = FunctionEnumType::incentiveTableDescriptionData;
		return;
	}
	if (src == "incentiveTableConstraintsData") {
		dst = FunctionEnumType::incentiveTableConstraintsData;
		return;
	}
	if (src == "electricalConnectionPermittedValueSetListData") {
		dst = FunctionEnumType::electricalConnectionPermittedValueSetListData;
		return;
	}
	if (src == "useCaseInformationListData") {
		dst = FunctionEnumType::useCaseInformationListData;
		return;
	}
	if (src == "nodeManagementUseCaseData") {
		dst = FunctionEnumType::nodeManagementUseCaseData;
		return;
	}
	if (src == "billConstraintsListData") {
		dst = FunctionEnumType::billConstraintsListData;
		return;
	}
	if (src == "billDescriptionListData") {
		dst = FunctionEnumType::billDescriptionListData;
		return;
	}
	if (src == "billListData") {
		dst = FunctionEnumType::billListData;
		return;
	}
	if (src == "identificationListData") {
		dst = FunctionEnumType::identificationListData;
		return;
	}
	if (src == "measurementSeriesListData") {
		dst = FunctionEnumType::measurementSeriesListData;
		return;
	}
	if (src == "electricalConnectionCharacteristicListData") {
		dst = FunctionEnumType::electricalConnectionCharacteristicListData;
		return;
	}
	if (src == "stateInformationListData") {
		dst = FunctionEnumType::stateInformationListData;
		return;
	}
	 return;
}
bool convertToJson(const TimeSeriesTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case TimeSeriesTypeEnumType::plan:
		 enumName = "plan";
		break;
	case TimeSeriesTypeEnumType::singleDemand:
		 enumName = "singleDemand";
		break;
	case TimeSeriesTypeEnumType::constraints:
		 enumName = "constraints";
		break;
	case TimeSeriesTypeEnumType::energyRequest:
		 enumName = "energyRequest";
		break;
	case TimeSeriesTypeEnumType::dischargingEnergyRequest:
		 enumName = "dischargingEnergyRequest";
		break;
	case TimeSeriesTypeEnumType::consumptionLimitCurve:
		 enumName = "consumptionLimitCurve";
		break;
	case TimeSeriesTypeEnumType::productionLimitCurve:
		 enumName = "productionLimitCurve";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesTypeEnumType &dst) {
	if (src == "plan") {
		dst = TimeSeriesTypeEnumType::plan;
		return;
	}
	if (src == "singleDemand") {
		dst = TimeSeriesTypeEnumType::singleDemand;
		return;
	}
	if (src == "constraints") {
		dst = TimeSeriesTypeEnumType::constraints;
		return;
	}
	if (src == "energyRequest") {
		dst = TimeSeriesTypeEnumType::energyRequest;
		return;
	}
	if (src == "dischargingEnergyRequest") {
		dst = TimeSeriesTypeEnumType::dischargingEnergyRequest;
		return;
	}
	if (src == "consumptionLimitCurve") {
		dst = TimeSeriesTypeEnumType::consumptionLimitCurve;
		return;
	}
	if (src == "productionLimitCurve") {
		dst = TimeSeriesTypeEnumType::productionLimitCurve;
		return;
	}
	 return;
}
bool convertToJson(const MeasurementTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case MeasurementTypeEnumType::acceleration:
		 enumName = "acceleration";
		break;
	case MeasurementTypeEnumType::angle:
		 enumName = "angle";
		break;
	case MeasurementTypeEnumType::angularVelocity:
		 enumName = "angularVelocity";
		break;
	case MeasurementTypeEnumType::area:
		 enumName = "area";
		break;
	case MeasurementTypeEnumType::atmosphericPressure:
		 enumName = "atmosphericPressure";
		break;
	case MeasurementTypeEnumType::capacity:
		 enumName = "capacity";
		break;
	case MeasurementTypeEnumType::concentration:
		 enumName = "concentration";
		break;
	case MeasurementTypeEnumType::count:
		 enumName = "count";
		break;
	case MeasurementTypeEnumType::current:
		 enumName = "current";
		break;
	case MeasurementTypeEnumType::density:
		 enumName = "density";
		break;
	case MeasurementTypeEnumType::distance:
		 enumName = "distance";
		break;
	case MeasurementTypeEnumType::electricField:
		 enumName = "electricField";
		break;
	case MeasurementTypeEnumType::energy:
		 enumName = "energy";
		break;
	case MeasurementTypeEnumType::force:
		 enumName = "force";
		break;
	case MeasurementTypeEnumType::frequency:
		 enumName = "frequency";
		break;
	case MeasurementTypeEnumType::harmonicDistortion:
		 enumName = "harmonicDistortion";
		break;
	case MeasurementTypeEnumType::heat:
		 enumName = "heat";
		break;
	case MeasurementTypeEnumType::heatFlux:
		 enumName = "heatFlux";
		break;
	case MeasurementTypeEnumType::illuminance:
		 enumName = "illuminance";
		break;
	case MeasurementTypeEnumType::impulse:
		 enumName = "impulse";
		break;
	case MeasurementTypeEnumType::level:
		 enumName = "level";
		break;
	case MeasurementTypeEnumType::magneticField:
		 enumName = "magneticField";
		break;
	case MeasurementTypeEnumType::mass:
		 enumName = "mass";
		break;
	case MeasurementTypeEnumType::massFlow:
		 enumName = "massFlow";
		break;
	case MeasurementTypeEnumType::particles:
		 enumName = "particles";
		break;
	case MeasurementTypeEnumType::percentage:
		 enumName = "percentage";
		break;
	case MeasurementTypeEnumType::power:
		 enumName = "power";
		break;
	case MeasurementTypeEnumType::powerFactor:
		 enumName = "powerFactor";
		break;
	case MeasurementTypeEnumType::pressure:
		 enumName = "pressure";
		break;
	case MeasurementTypeEnumType::radonActivity:
		 enumName = "radonActivity";
		break;
	case MeasurementTypeEnumType::relativeHumidity:
		 enumName = "relativeHumidity";
		break;
	case MeasurementTypeEnumType::resistance:
		 enumName = "resistance";
		break;
	case MeasurementTypeEnumType::solarRadiation:
		 enumName = "solarRadiation";
		break;
	case MeasurementTypeEnumType::speed:
		 enumName = "speed";
		break;
	case MeasurementTypeEnumType::temperature:
		 enumName = "temperature";
		break;
	case MeasurementTypeEnumType::time:
		 enumName = "time";
		break;
	case MeasurementTypeEnumType::torque:
		 enumName = "torque";
		break;
	case MeasurementTypeEnumType::unknown:
		 enumName = "unknown";
		break;
	case MeasurementTypeEnumType::velocity:
		 enumName = "velocity";
		break;
	case MeasurementTypeEnumType::voltage:
		 enumName = "voltage";
		break;
	case MeasurementTypeEnumType::volume:
		 enumName = "volume";
		break;
	case MeasurementTypeEnumType::volumetricFlow:
		 enumName = "volumetricFlow";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementTypeEnumType &dst) {
	if (src == "acceleration") {
		dst = MeasurementTypeEnumType::acceleration;
		return;
	}
	if (src == "angle") {
		dst = MeasurementTypeEnumType::angle;
		return;
	}
	if (src == "angularVelocity") {
		dst = MeasurementTypeEnumType::angularVelocity;
		return;
	}
	if (src == "area") {
		dst = MeasurementTypeEnumType::area;
		return;
	}
	if (src == "atmosphericPressure") {
		dst = MeasurementTypeEnumType::atmosphericPressure;
		return;
	}
	if (src == "capacity") {
		dst = MeasurementTypeEnumType::capacity;
		return;
	}
	if (src == "concentration") {
		dst = MeasurementTypeEnumType::concentration;
		return;
	}
	if (src == "count") {
		dst = MeasurementTypeEnumType::count;
		return;
	}
	if (src == "current") {
		dst = MeasurementTypeEnumType::current;
		return;
	}
	if (src == "density") {
		dst = MeasurementTypeEnumType::density;
		return;
	}
	if (src == "distance") {
		dst = MeasurementTypeEnumType::distance;
		return;
	}
	if (src == "electricField") {
		dst = MeasurementTypeEnumType::electricField;
		return;
	}
	if (src == "energy") {
		dst = MeasurementTypeEnumType::energy;
		return;
	}
	if (src == "force") {
		dst = MeasurementTypeEnumType::force;
		return;
	}
	if (src == "frequency") {
		dst = MeasurementTypeEnumType::frequency;
		return;
	}
	if (src == "harmonicDistortion") {
		dst = MeasurementTypeEnumType::harmonicDistortion;
		return;
	}
	if (src == "heat") {
		dst = MeasurementTypeEnumType::heat;
		return;
	}
	if (src == "heatFlux") {
		dst = MeasurementTypeEnumType::heatFlux;
		return;
	}
	if (src == "illuminance") {
		dst = MeasurementTypeEnumType::illuminance;
		return;
	}
	if (src == "impulse") {
		dst = MeasurementTypeEnumType::impulse;
		return;
	}
	if (src == "level") {
		dst = MeasurementTypeEnumType::level;
		return;
	}
	if (src == "magneticField") {
		dst = MeasurementTypeEnumType::magneticField;
		return;
	}
	if (src == "mass") {
		dst = MeasurementTypeEnumType::mass;
		return;
	}
	if (src == "massFlow") {
		dst = MeasurementTypeEnumType::massFlow;
		return;
	}
	if (src == "particles") {
		dst = MeasurementTypeEnumType::particles;
		return;
	}
	if (src == "percentage") {
		dst = MeasurementTypeEnumType::percentage;
		return;
	}
	if (src == "power") {
		dst = MeasurementTypeEnumType::power;
		return;
	}
	if (src == "powerFactor") {
		dst = MeasurementTypeEnumType::powerFactor;
		return;
	}
	if (src == "pressure") {
		dst = MeasurementTypeEnumType::pressure;
		return;
	}
	if (src == "radonActivity") {
		dst = MeasurementTypeEnumType::radonActivity;
		return;
	}
	if (src == "relativeHumidity") {
		dst = MeasurementTypeEnumType::relativeHumidity;
		return;
	}
	if (src == "resistance") {
		dst = MeasurementTypeEnumType::resistance;
		return;
	}
	if (src == "solarRadiation") {
		dst = MeasurementTypeEnumType::solarRadiation;
		return;
	}
	if (src == "speed") {
		dst = MeasurementTypeEnumType::speed;
		return;
	}
	if (src == "temperature") {
		dst = MeasurementTypeEnumType::temperature;
		return;
	}
	if (src == "time") {
		dst = MeasurementTypeEnumType::time;
		return;
	}
	if (src == "torque") {
		dst = MeasurementTypeEnumType::torque;
		return;
	}
	if (src == "unknown") {
		dst = MeasurementTypeEnumType::unknown;
		return;
	}
	if (src == "velocity") {
		dst = MeasurementTypeEnumType::velocity;
		return;
	}
	if (src == "voltage") {
		dst = MeasurementTypeEnumType::voltage;
		return;
	}
	if (src == "volume") {
		dst = MeasurementTypeEnumType::volume;
		return;
	}
	if (src == "volumetricFlow") {
		dst = MeasurementTypeEnumType::volumetricFlow;
		return;
	}
	 return;
}
bool convertToJson(const MeasurementValueTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case MeasurementValueTypeEnumType::value:
		 enumName = "value";
		break;
	case MeasurementValueTypeEnumType::averageValue:
		 enumName = "averageValue";
		break;
	case MeasurementValueTypeEnumType::minValue:
		 enumName = "minValue";
		break;
	case MeasurementValueTypeEnumType::maxValue:
		 enumName = "maxValue";
		break;
	case MeasurementValueTypeEnumType::standardDeviation:
		 enumName = "standardDeviation";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementValueTypeEnumType &dst) {
	if (src == "value") {
		dst = MeasurementValueTypeEnumType::value;
		return;
	}
	if (src == "averageValue") {
		dst = MeasurementValueTypeEnumType::averageValue;
		return;
	}
	if (src == "minValue") {
		dst = MeasurementValueTypeEnumType::minValue;
		return;
	}
	if (src == "maxValue") {
		dst = MeasurementValueTypeEnumType::maxValue;
		return;
	}
	if (src == "standardDeviation") {
		dst = MeasurementValueTypeEnumType::standardDeviation;
		return;
	}
	 return;
}
bool convertToJson(const MeasurementValueSourceEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case MeasurementValueSourceEnumType::measuredValue:
		 enumName = "measuredValue";
		break;
	case MeasurementValueSourceEnumType::calculatedValue:
		 enumName = "calculatedValue";
		break;
	case MeasurementValueSourceEnumType::empiricalValue:
		 enumName = "empiricalValue";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementValueSourceEnumType &dst) {
	if (src == "measuredValue") {
		dst = MeasurementValueSourceEnumType::measuredValue;
		return;
	}
	if (src == "calculatedValue") {
		dst = MeasurementValueSourceEnumType::calculatedValue;
		return;
	}
	if (src == "empiricalValue") {
		dst = MeasurementValueSourceEnumType::empiricalValue;
		return;
	}
	 return;
}
bool convertToJson(const MeasurementValueTendencyEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case MeasurementValueTendencyEnumType::rising:
		 enumName = "rising";
		break;
	case MeasurementValueTendencyEnumType::stable:
		 enumName = "stable";
		break;
	case MeasurementValueTendencyEnumType::falling:
		 enumName = "falling";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementValueTendencyEnumType &dst) {
	if (src == "rising") {
		dst = MeasurementValueTendencyEnumType::rising;
		return;
	}
	if (src == "stable") {
		dst = MeasurementValueTendencyEnumType::stable;
		return;
	}
	if (src == "falling") {
		dst = MeasurementValueTendencyEnumType::falling;
		return;
	}
	 return;
}
bool convertToJson(const MeasurementValueStateEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case MeasurementValueStateEnumType::normal:
		 enumName = "normal";
		break;
	case MeasurementValueStateEnumType::outOfRange:
		 enumName = "outOfRange";
		break;
	case MeasurementValueStateEnumType::error:
		 enumName = "error";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementValueStateEnumType &dst) {
	if (src == "normal") {
		dst = MeasurementValueStateEnumType::normal;
		return;
	}
	if (src == "outOfRange") {
		dst = MeasurementValueStateEnumType::outOfRange;
		return;
	}
	if (src == "error") {
		dst = MeasurementValueStateEnumType::error;
		return;
	}
	 return;
}
bool convertToJson(const ThresholdTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ThresholdTypeEnumType::goodAbove:
		 enumName = "goodAbove";
		break;
	case ThresholdTypeEnumType::badAbove:
		 enumName = "badAbove";
		break;
	case ThresholdTypeEnumType::goodBelow:
		 enumName = "goodBelow";
		break;
	case ThresholdTypeEnumType::badBelow:
		 enumName = "badBelow";
		break;
	case ThresholdTypeEnumType::minValueThreshold:
		 enumName = "minValueThreshold";
		break;
	case ThresholdTypeEnumType::maxValueThreshold:
		 enumName = "maxValueThreshold";
		break;
	case ThresholdTypeEnumType::minValueThresholdExtreme:
		 enumName = "minValueThresholdExtreme";
		break;
	case ThresholdTypeEnumType::maxValueThresholdExtreme:
		 enumName = "maxValueThresholdExtreme";
		break;
	case ThresholdTypeEnumType::sagThreshold:
		 enumName = "sagThreshold";
		break;
	case ThresholdTypeEnumType::swellThreshold:
		 enumName = "swellThreshold";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdTypeEnumType &dst) {
	if (src == "goodAbove") {
		dst = ThresholdTypeEnumType::goodAbove;
		return;
	}
	if (src == "badAbove") {
		dst = ThresholdTypeEnumType::badAbove;
		return;
	}
	if (src == "goodBelow") {
		dst = ThresholdTypeEnumType::goodBelow;
		return;
	}
	if (src == "badBelow") {
		dst = ThresholdTypeEnumType::badBelow;
		return;
	}
	if (src == "minValueThreshold") {
		dst = ThresholdTypeEnumType::minValueThreshold;
		return;
	}
	if (src == "maxValueThreshold") {
		dst = ThresholdTypeEnumType::maxValueThreshold;
		return;
	}
	if (src == "minValueThresholdExtreme") {
		dst = ThresholdTypeEnumType::minValueThresholdExtreme;
		return;
	}
	if (src == "maxValueThresholdExtreme") {
		dst = ThresholdTypeEnumType::maxValueThresholdExtreme;
		return;
	}
	if (src == "sagThreshold") {
		dst = ThresholdTypeEnumType::sagThreshold;
		return;
	}
	if (src == "swellThreshold") {
		dst = ThresholdTypeEnumType::swellThreshold;
		return;
	}
	 return;
}
bool convertToJson(const DirectControlActivityStateEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case DirectControlActivityStateEnumType::running:
		 enumName = "running";
		break;
	case DirectControlActivityStateEnumType::paused:
		 enumName = "paused";
		break;
	case DirectControlActivityStateEnumType::inactive:
		 enumName = "inactive";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, DirectControlActivityStateEnumType &dst) {
	if (src == "running") {
		dst = DirectControlActivityStateEnumType::running;
		return;
	}
	if (src == "paused") {
		dst = DirectControlActivityStateEnumType::paused;
		return;
	}
	if (src == "inactive") {
		dst = DirectControlActivityStateEnumType::inactive;
		return;
	}
	 return;
}
bool convertToJson(const PowerTimeSlotValueTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case PowerTimeSlotValueTypeEnumType::power:
		 enumName = "power";
		break;
	case PowerTimeSlotValueTypeEnumType::powerMin:
		 enumName = "powerMin";
		break;
	case PowerTimeSlotValueTypeEnumType::powerMax:
		 enumName = "powerMax";
		break;
	case PowerTimeSlotValueTypeEnumType::powerExpectedValue:
		 enumName = "powerExpectedValue";
		break;
	case PowerTimeSlotValueTypeEnumType::powerStandardDeviation:
		 enumName = "powerStandardDeviation";
		break;
	case PowerTimeSlotValueTypeEnumType::powerSkewness:
		 enumName = "powerSkewness";
		break;
	case PowerTimeSlotValueTypeEnumType::energy:
		 enumName = "energy";
		break;
	case PowerTimeSlotValueTypeEnumType::energyMin:
		 enumName = "energyMin";
		break;
	case PowerTimeSlotValueTypeEnumType::energyMax:
		 enumName = "energyMax";
		break;
	case PowerTimeSlotValueTypeEnumType::energyExpectedValue:
		 enumName = "energyExpectedValue";
		break;
	case PowerTimeSlotValueTypeEnumType::energyStandardDeviation:
		 enumName = "energyStandardDeviation";
		break;
	case PowerTimeSlotValueTypeEnumType::energySkewness:
		 enumName = "energySkewness";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotValueTypeEnumType &dst) {
	if (src == "power") {
		dst = PowerTimeSlotValueTypeEnumType::power;
		return;
	}
	if (src == "powerMin") {
		dst = PowerTimeSlotValueTypeEnumType::powerMin;
		return;
	}
	if (src == "powerMax") {
		dst = PowerTimeSlotValueTypeEnumType::powerMax;
		return;
	}
	if (src == "powerExpectedValue") {
		dst = PowerTimeSlotValueTypeEnumType::powerExpectedValue;
		return;
	}
	if (src == "powerStandardDeviation") {
		dst = PowerTimeSlotValueTypeEnumType::powerStandardDeviation;
		return;
	}
	if (src == "powerSkewness") {
		dst = PowerTimeSlotValueTypeEnumType::powerSkewness;
		return;
	}
	if (src == "energy") {
		dst = PowerTimeSlotValueTypeEnumType::energy;
		return;
	}
	if (src == "energyMin") {
		dst = PowerTimeSlotValueTypeEnumType::energyMin;
		return;
	}
	if (src == "energyMax") {
		dst = PowerTimeSlotValueTypeEnumType::energyMax;
		return;
	}
	if (src == "energyExpectedValue") {
		dst = PowerTimeSlotValueTypeEnumType::energyExpectedValue;
		return;
	}
	if (src == "energyStandardDeviation") {
		dst = PowerTimeSlotValueTypeEnumType::energyStandardDeviation;
		return;
	}
	if (src == "energySkewness") {
		dst = PowerTimeSlotValueTypeEnumType::energySkewness;
		return;
	}
	 return;
}
bool convertToJson(const PowerSequenceScopeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case PowerSequenceScopeEnumType::forecast:
		 enumName = "forecast";
		break;
	case PowerSequenceScopeEnumType::measurement:
		 enumName = "measurement";
		break;
	case PowerSequenceScopeEnumType::recommendation:
		 enumName = "recommendation";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScopeEnumType &dst) {
	if (src == "forecast") {
		dst = PowerSequenceScopeEnumType::forecast;
		return;
	}
	if (src == "measurement") {
		dst = PowerSequenceScopeEnumType::measurement;
		return;
	}
	if (src == "recommendation") {
		dst = PowerSequenceScopeEnumType::recommendation;
		return;
	}
	 return;
}
bool convertToJson(const PowerSequenceStateEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case PowerSequenceStateEnumType::running:
		 enumName = "running";
		break;
	case PowerSequenceStateEnumType::paused:
		 enumName = "paused";
		break;
	case PowerSequenceStateEnumType::scheduled:
		 enumName = "scheduled";
		break;
	case PowerSequenceStateEnumType::scheduledPaused:
		 enumName = "scheduledPaused";
		break;
	case PowerSequenceStateEnumType::pending:
		 enumName = "pending";
		break;
	case PowerSequenceStateEnumType::inactive:
		 enumName = "inactive";
		break;
	case PowerSequenceStateEnumType::completed:
		 enumName = "completed";
		break;
	case PowerSequenceStateEnumType::invalid:
		 enumName = "invalid";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceStateEnumType &dst) {
	if (src == "running") {
		dst = PowerSequenceStateEnumType::running;
		return;
	}
	if (src == "paused") {
		dst = PowerSequenceStateEnumType::paused;
		return;
	}
	if (src == "scheduled") {
		dst = PowerSequenceStateEnumType::scheduled;
		return;
	}
	if (src == "scheduledPaused") {
		dst = PowerSequenceStateEnumType::scheduledPaused;
		return;
	}
	if (src == "pending") {
		dst = PowerSequenceStateEnumType::pending;
		return;
	}
	if (src == "inactive") {
		dst = PowerSequenceStateEnumType::inactive;
		return;
	}
	if (src == "completed") {
		dst = PowerSequenceStateEnumType::completed;
		return;
	}
	if (src == "invalid") {
		dst = PowerSequenceStateEnumType::invalid;
		return;
	}
	 return;
}
bool convertToJson(const ActuatorLevelFctEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ActuatorLevelFctEnumType::start:
		 enumName = "start";
		break;
	case ActuatorLevelFctEnumType::up:
		 enumName = "up";
		break;
	case ActuatorLevelFctEnumType::down:
		 enumName = "down";
		break;
	case ActuatorLevelFctEnumType::stop:
		 enumName = "stop";
		break;
	case ActuatorLevelFctEnumType::percentageAbsolute:
		 enumName = "percentageAbsolute";
		break;
	case ActuatorLevelFctEnumType::percentageRelative:
		 enumName = "percentageRelative";
		break;
	case ActuatorLevelFctEnumType::absolute:
		 enumName = "absolute";
		break;
	case ActuatorLevelFctEnumType::relative:
		 enumName = "relative";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorLevelFctEnumType &dst) {
	if (src == "start") {
		dst = ActuatorLevelFctEnumType::start;
		return;
	}
	if (src == "up") {
		dst = ActuatorLevelFctEnumType::up;
		return;
	}
	if (src == "down") {
		dst = ActuatorLevelFctEnumType::down;
		return;
	}
	if (src == "stop") {
		dst = ActuatorLevelFctEnumType::stop;
		return;
	}
	if (src == "percentageAbsolute") {
		dst = ActuatorLevelFctEnumType::percentageAbsolute;
		return;
	}
	if (src == "percentageRelative") {
		dst = ActuatorLevelFctEnumType::percentageRelative;
		return;
	}
	if (src == "absolute") {
		dst = ActuatorLevelFctEnumType::absolute;
		return;
	}
	if (src == "relative") {
		dst = ActuatorLevelFctEnumType::relative;
		return;
	}
	 return;
}
bool convertToJson(const CmdClassifierType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case CmdClassifierType::read:
		 enumName = "read";
		break;
	case CmdClassifierType::reply:
		 enumName = "reply";
		break;
	case CmdClassifierType::notify:
		 enumName = "notify";
		break;
	case CmdClassifierType::write:
		 enumName = "write";
		break;
	case CmdClassifierType::call:
		 enumName = "call";
		break;
	case CmdClassifierType::result:
		 enumName = "result";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, CmdClassifierType &dst) {
	if (src == "read") {
		dst = CmdClassifierType::read;
		return;
	}
	if (src == "reply") {
		dst = CmdClassifierType::reply;
		return;
	}
	if (src == "notify") {
		dst = CmdClassifierType::notify;
		return;
	}
	if (src == "write") {
		dst = CmdClassifierType::write;
		return;
	}
	if (src == "call") {
		dst = CmdClassifierType::call;
		return;
	}
	if (src == "result") {
		dst = CmdClassifierType::result;
		return;
	}
	 return;
}
bool convertToJson(const ActuatorSwitchFctEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ActuatorSwitchFctEnumType::on:
		 enumName = "on";
		break;
	case ActuatorSwitchFctEnumType::off:
		 enumName = "off";
		break;
	case ActuatorSwitchFctEnumType::toggle:
		 enumName = "toggle";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorSwitchFctEnumType &dst) {
	if (src == "on") {
		dst = ActuatorSwitchFctEnumType::on;
		return;
	}
	if (src == "off") {
		dst = ActuatorSwitchFctEnumType::off;
		return;
	}
	if (src == "toggle") {
		dst = ActuatorSwitchFctEnumType::toggle;
		return;
	}
	 return;
}
bool convertToJson(const AlarmTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case AlarmTypeEnumType::alarmCancelled:
		 enumName = "alarmCancelled";
		break;
	case AlarmTypeEnumType::underThreshold:
		 enumName = "underThreshold";
		break;
	case AlarmTypeEnumType::overThreshold:
		 enumName = "overThreshold";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, AlarmTypeEnumType &dst) {
	if (src == "alarmCancelled") {
		dst = AlarmTypeEnumType::alarmCancelled;
		return;
	}
	if (src == "underThreshold") {
		dst = AlarmTypeEnumType::underThreshold;
		return;
	}
	if (src == "overThreshold") {
		dst = AlarmTypeEnumType::overThreshold;
		return;
	}
	 return;
}
bool convertToJson(const BillTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case BillTypeEnumType::chargingSummary:
		 enumName = "chargingSummary";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, BillTypeEnumType &dst) {
	if (src == "chargingSummary") {
		dst = BillTypeEnumType::chargingSummary;
		return;
	}
	 return;
}
bool convertToJson(const BillPositionTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case BillPositionTypeEnumType::gridElectricEnergy:
		 enumName = "gridElectricEnergy";
		break;
	case BillPositionTypeEnumType::selfProducedElectricEnergy:
		 enumName = "selfProducedElectricEnergy";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, BillPositionTypeEnumType &dst) {
	if (src == "gridElectricEnergy") {
		dst = BillPositionTypeEnumType::gridElectricEnergy;
		return;
	}
	if (src == "selfProducedElectricEnergy") {
		dst = BillPositionTypeEnumType::selfProducedElectricEnergy;
		return;
	}
	 return;
}
bool convertToJson(const BillCostTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case BillCostTypeEnumType::absolutePrice:
		 enumName = "absolutePrice";
		break;
	case BillCostTypeEnumType::relativePrice:
		 enumName = "relativePrice";
		break;
	case BillCostTypeEnumType::co2Emission:
		 enumName = "co2Emission";
		break;
	case BillCostTypeEnumType::renewableEnergy:
		 enumName = "renewableEnergy";
		break;
	case BillCostTypeEnumType::radioactiveWaste:
		 enumName = "radioactiveWaste";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, BillCostTypeEnumType &dst) {
	if (src == "absolutePrice") {
		dst = BillCostTypeEnumType::absolutePrice;
		return;
	}
	if (src == "relativePrice") {
		dst = BillCostTypeEnumType::relativePrice;
		return;
	}
	if (src == "co2Emission") {
		dst = BillCostTypeEnumType::co2Emission;
		return;
	}
	if (src == "renewableEnergy") {
		dst = BillCostTypeEnumType::renewableEnergy;
		return;
	}
	if (src == "radioactiveWaste") {
		dst = BillCostTypeEnumType::radioactiveWaste;
		return;
	}
	 return;
}
bool convertToJson(const IdentificationTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case IdentificationTypeEnumType::eui48:
		 enumName = "eui48";
		break;
	case IdentificationTypeEnumType::eui64:
		 enumName = "eui64";
		break;
	case IdentificationTypeEnumType::userRfidTag:
		 enumName = "userRfidTag";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, IdentificationTypeEnumType &dst) {
	if (src == "eui48") {
		dst = IdentificationTypeEnumType::eui48;
		return;
	}
	if (src == "eui64") {
		dst = IdentificationTypeEnumType::eui64;
		return;
	}
	if (src == "userRfidTag") {
		dst = IdentificationTypeEnumType::userRfidTag;
		return;
	}
	 return;
}
bool convertToJson(const PowerSourceEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case PowerSourceEnumType::unknown:
		 enumName = "unknown";
		break;
	case PowerSourceEnumType::mainsSinglePhase:
		 enumName = "mainsSinglePhase";
		break;
	case PowerSourceEnumType::mains3Phase:
		 enumName = "mains3Phase";
		break;
	case PowerSourceEnumType::battery:
		 enumName = "battery";
		break;
	case PowerSourceEnumType::dc:
		 enumName = "dc";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSourceEnumType &dst) {
	if (src == "unknown") {
		dst = PowerSourceEnumType::unknown;
		return;
	}
	if (src == "mainsSinglePhase") {
		dst = PowerSourceEnumType::mainsSinglePhase;
		return;
	}
	if (src == "mains3Phase") {
		dst = PowerSourceEnumType::mains3Phase;
		return;
	}
	if (src == "battery") {
		dst = PowerSourceEnumType::battery;
		return;
	}
	if (src == "dc") {
		dst = PowerSourceEnumType::dc;
		return;
	}
	 return;
}
bool convertToJson(const DeviceConfigurationKeyNameEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case DeviceConfigurationKeyNameEnumType::peakPowerOfPvSystem:
		 enumName = "peakPowerOfPvSystem";
		break;
	case DeviceConfigurationKeyNameEnumType::pvCurtailmentLimitFactor:
		 enumName = "pvCurtailmentLimitFactor";
		break;
	case DeviceConfigurationKeyNameEnumType::asymmetricChargingSupported:
		 enumName = "asymmetricChargingSupported";
		break;
	case DeviceConfigurationKeyNameEnumType::communicationsStandard:
		 enumName = "communicationsStandard";
		break;
	case DeviceConfigurationKeyNameEnumType::inverterGridCode:
		 enumName = "inverterGridCode";
		break;
	case DeviceConfigurationKeyNameEnumType::pvStringAvailabilityStatus:
		 enumName = "pvStringAvailabilityStatus";
		break;
	case DeviceConfigurationKeyNameEnumType::batteryAvailabilityStatus:
		 enumName = "batteryAvailabilityStatus";
		break;
	case DeviceConfigurationKeyNameEnumType::gridConnectionStatus:
		 enumName = "gridConnectionStatus";
		break;
	case DeviceConfigurationKeyNameEnumType::timeToAcChargePowerMax:
		 enumName = "timeToAcChargePowerMax";
		break;
	case DeviceConfigurationKeyNameEnumType::timeToAcDischargePowerMax:
		 enumName = "timeToAcDischargePowerMax";
		break;
	case DeviceConfigurationKeyNameEnumType::tilt:
		 enumName = "tilt";
		break;
	case DeviceConfigurationKeyNameEnumType::azimuth:
		 enumName = "azimuth";
		break;
	case DeviceConfigurationKeyNameEnumType::batteryType:
		 enumName = "batteryType";
		break;
	case DeviceConfigurationKeyNameEnumType::maxCycleCountPerDay:
		 enumName = "maxCycleCountPerDay";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafeConsumptionActivePowerLimit:
		 enumName = "failsafeConsumptionActivePowerLimit";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafeProductionActivePowerLimit:
		 enumName = "failsafeProductionActivePowerLimit";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafePositiveReactivePowerLimit:
		 enumName = "failsafePositiveReactivePowerLimit";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafeNegativeReactivePowerLimit:
		 enumName = "failsafeNegativeReactivePowerLimit";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafePositiveCosPhiLimit:
		 enumName = "failsafePositiveCosPhiLimit";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafeNegativeCosPhiLimit:
		 enumName = "failsafeNegativeCosPhiLimit";
		break;
	case DeviceConfigurationKeyNameEnumType::maxAcChargePower:
		 enumName = "maxAcChargePower";
		break;
	case DeviceConfigurationKeyNameEnumType::maxAcDischargePower:
		 enumName = "maxAcDischargePower";
		break;
	case DeviceConfigurationKeyNameEnumType::maxDcChargePower:
		 enumName = "maxDcChargePower";
		break;
	case DeviceConfigurationKeyNameEnumType::maxDcDischargePower:
		 enumName = "maxDcDischargePower";
		break;
	case DeviceConfigurationKeyNameEnumType::batteryActiveControlMode:
		 enumName = "batteryActiveControlMode";
		break;
	case DeviceConfigurationKeyNameEnumType::defaultAcPower:
		 enumName = "defaultAcPower";
		break;
	case DeviceConfigurationKeyNameEnumType::defaultDcPower:
		 enumName = "defaultDcPower";
		break;
	case DeviceConfigurationKeyNameEnumType::defaultPccPower:
		 enumName = "defaultPccPower";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafeAcPowerSetpoint:
		 enumName = "failsafeAcPowerSetpoint";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafeDcPowerSetpoint:
		 enumName = "failsafeDcPowerSetpoint";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafePccPowerSetpoint:
		 enumName = "failsafePccPowerSetpoint";
		break;
	case DeviceConfigurationKeyNameEnumType::failsafeDurationMinimum:
		 enumName = "failsafeDurationMinimum";
		break;
	case DeviceConfigurationKeyNameEnumType::dischargingBelowTargetEnergyRequestPermitted:
		 enumName = "dischargingBelowTargetEnergyRequestPermitted";
		break;
	case DeviceConfigurationKeyNameEnumType::incentivesSimulationCyclesMax:
		 enumName = "incentivesSimulationCyclesMax";
		break;
	case DeviceConfigurationKeyNameEnumType::incentivesSimulationConcurrent:
		 enumName = "incentivesSimulationConcurrent";
		break;
	case DeviceConfigurationKeyNameEnumType::incentivesTimeoutIncentiveRequest:
		 enumName = "incentivesTimeoutIncentiveRequest";
		break;
	case DeviceConfigurationKeyNameEnumType::incentivesWaitIncentiveWriteable:
		 enumName = "incentivesWaitIncentiveWriteable";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyNameEnumType &dst) {
	if (src == "peakPowerOfPvSystem") {
		dst = DeviceConfigurationKeyNameEnumType::peakPowerOfPvSystem;
		return;
	}
	if (src == "pvCurtailmentLimitFactor") {
		dst = DeviceConfigurationKeyNameEnumType::pvCurtailmentLimitFactor;
		return;
	}
	if (src == "asymmetricChargingSupported") {
		dst = DeviceConfigurationKeyNameEnumType::asymmetricChargingSupported;
		return;
	}
	if (src == "communicationsStandard") {
		dst = DeviceConfigurationKeyNameEnumType::communicationsStandard;
		return;
	}
	if (src == "inverterGridCode") {
		dst = DeviceConfigurationKeyNameEnumType::inverterGridCode;
		return;
	}
	if (src == "pvStringAvailabilityStatus") {
		dst = DeviceConfigurationKeyNameEnumType::pvStringAvailabilityStatus;
		return;
	}
	if (src == "batteryAvailabilityStatus") {
		dst = DeviceConfigurationKeyNameEnumType::batteryAvailabilityStatus;
		return;
	}
	if (src == "gridConnectionStatus") {
		dst = DeviceConfigurationKeyNameEnumType::gridConnectionStatus;
		return;
	}
	if (src == "timeToAcChargePowerMax") {
		dst = DeviceConfigurationKeyNameEnumType::timeToAcChargePowerMax;
		return;
	}
	if (src == "timeToAcDischargePowerMax") {
		dst = DeviceConfigurationKeyNameEnumType::timeToAcDischargePowerMax;
		return;
	}
	if (src == "tilt") {
		dst = DeviceConfigurationKeyNameEnumType::tilt;
		return;
	}
	if (src == "azimuth") {
		dst = DeviceConfigurationKeyNameEnumType::azimuth;
		return;
	}
	if (src == "batteryType") {
		dst = DeviceConfigurationKeyNameEnumType::batteryType;
		return;
	}
	if (src == "maxCycleCountPerDay") {
		dst = DeviceConfigurationKeyNameEnumType::maxCycleCountPerDay;
		return;
	}
	if (src == "failsafeConsumptionActivePowerLimit") {
		dst = DeviceConfigurationKeyNameEnumType::failsafeConsumptionActivePowerLimit;
		return;
	}
	if (src == "failsafeProductionActivePowerLimit") {
		dst = DeviceConfigurationKeyNameEnumType::failsafeProductionActivePowerLimit;
		return;
	}
	if (src == "failsafePositiveReactivePowerLimit") {
		dst = DeviceConfigurationKeyNameEnumType::failsafePositiveReactivePowerLimit;
		return;
	}
	if (src == "failsafeNegativeReactivePowerLimit") {
		dst = DeviceConfigurationKeyNameEnumType::failsafeNegativeReactivePowerLimit;
		return;
	}
	if (src == "failsafePositiveCosPhiLimit") {
		dst = DeviceConfigurationKeyNameEnumType::failsafePositiveCosPhiLimit;
		return;
	}
	if (src == "failsafeNegativeCosPhiLimit") {
		dst = DeviceConfigurationKeyNameEnumType::failsafeNegativeCosPhiLimit;
		return;
	}
	if (src == "maxAcChargePower") {
		dst = DeviceConfigurationKeyNameEnumType::maxAcChargePower;
		return;
	}
	if (src == "maxAcDischargePower") {
		dst = DeviceConfigurationKeyNameEnumType::maxAcDischargePower;
		return;
	}
	if (src == "maxDcChargePower") {
		dst = DeviceConfigurationKeyNameEnumType::maxDcChargePower;
		return;
	}
	if (src == "maxDcDischargePower") {
		dst = DeviceConfigurationKeyNameEnumType::maxDcDischargePower;
		return;
	}
	if (src == "batteryActiveControlMode") {
		dst = DeviceConfigurationKeyNameEnumType::batteryActiveControlMode;
		return;
	}
	if (src == "defaultAcPower") {
		dst = DeviceConfigurationKeyNameEnumType::defaultAcPower;
		return;
	}
	if (src == "defaultDcPower") {
		dst = DeviceConfigurationKeyNameEnumType::defaultDcPower;
		return;
	}
	if (src == "defaultPccPower") {
		dst = DeviceConfigurationKeyNameEnumType::defaultPccPower;
		return;
	}
	if (src == "failsafeAcPowerSetpoint") {
		dst = DeviceConfigurationKeyNameEnumType::failsafeAcPowerSetpoint;
		return;
	}
	if (src == "failsafeDcPowerSetpoint") {
		dst = DeviceConfigurationKeyNameEnumType::failsafeDcPowerSetpoint;
		return;
	}
	if (src == "failsafePccPowerSetpoint") {
		dst = DeviceConfigurationKeyNameEnumType::failsafePccPowerSetpoint;
		return;
	}
	if (src == "failsafeDurationMinimum") {
		dst = DeviceConfigurationKeyNameEnumType::failsafeDurationMinimum;
		return;
	}
	if (src == "dischargingBelowTargetEnergyRequestPermitted") {
		dst = DeviceConfigurationKeyNameEnumType::dischargingBelowTargetEnergyRequestPermitted;
		return;
	}
	if (src == "incentivesSimulationCyclesMax") {
		dst = DeviceConfigurationKeyNameEnumType::incentivesSimulationCyclesMax;
		return;
	}
	if (src == "incentivesSimulationConcurrent") {
		dst = DeviceConfigurationKeyNameEnumType::incentivesSimulationConcurrent;
		return;
	}
	if (src == "incentivesTimeoutIncentiveRequest") {
		dst = DeviceConfigurationKeyNameEnumType::incentivesTimeoutIncentiveRequest;
		return;
	}
	if (src == "incentivesWaitIncentiveWriteable") {
		dst = DeviceConfigurationKeyNameEnumType::incentivesWaitIncentiveWriteable;
		return;
	}
	 return;
}
bool convertToJson(const DeviceConfigurationKeyValueTypeType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case DeviceConfigurationKeyValueTypeType::boolean:
		 enumName = "boolean";
		break;
	case DeviceConfigurationKeyValueTypeType::date:
		 enumName = "date";
		break;
	case DeviceConfigurationKeyValueTypeType::dateTime:
		 enumName = "dateTime";
		break;
	case DeviceConfigurationKeyValueTypeType::duration:
		 enumName = "duration";
		break;
	case DeviceConfigurationKeyValueTypeType::string:
		 enumName = "string";
		break;
	case DeviceConfigurationKeyValueTypeType::time:
		 enumName = "time";
		break;
	case DeviceConfigurationKeyValueTypeType::scaledNumber:
		 enumName = "scaledNumber";
		break;
	case DeviceConfigurationKeyValueTypeType::integer:
		 enumName = "integer";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueTypeType &dst) {
	if (src == "boolean") {
		dst = DeviceConfigurationKeyValueTypeType::boolean;
		return;
	}
	if (src == "date") {
		dst = DeviceConfigurationKeyValueTypeType::date;
		return;
	}
	if (src == "dateTime") {
		dst = DeviceConfigurationKeyValueTypeType::dateTime;
		return;
	}
	if (src == "duration") {
		dst = DeviceConfigurationKeyValueTypeType::duration;
		return;
	}
	if (src == "string") {
		dst = DeviceConfigurationKeyValueTypeType::string;
		return;
	}
	if (src == "time") {
		dst = DeviceConfigurationKeyValueTypeType::time;
		return;
	}
	if (src == "scaledNumber") {
		dst = DeviceConfigurationKeyValueTypeType::scaledNumber;
		return;
	}
	if (src == "integer") {
		dst = DeviceConfigurationKeyValueTypeType::integer;
		return;
	}
	 return;
}
bool convertToJson(const DeviceDiagnosisOperatingStateEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case DeviceDiagnosisOperatingStateEnumType::normalOperation:
		 enumName = "normalOperation";
		break;
	case DeviceDiagnosisOperatingStateEnumType::standby:
		 enumName = "standby";
		break;
	case DeviceDiagnosisOperatingStateEnumType::failure:
		 enumName = "failure";
		break;
	case DeviceDiagnosisOperatingStateEnumType::serviceNeeded:
		 enumName = "serviceNeeded";
		break;
	case DeviceDiagnosisOperatingStateEnumType::overrideDetected:
		 enumName = "overrideDetected";
		break;
	case DeviceDiagnosisOperatingStateEnumType::inAlarm:
		 enumName = "inAlarm";
		break;
	case DeviceDiagnosisOperatingStateEnumType::notReachable:
		 enumName = "notReachable";
		break;
	case DeviceDiagnosisOperatingStateEnumType::finished:
		 enumName = "finished";
		break;
	case DeviceDiagnosisOperatingStateEnumType::temporarilyNotReady:
		 enumName = "temporarilyNotReady";
		break;
	case DeviceDiagnosisOperatingStateEnumType::off:
		 enumName = "off";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisOperatingStateEnumType &dst) {
	if (src == "normalOperation") {
		dst = DeviceDiagnosisOperatingStateEnumType::normalOperation;
		return;
	}
	if (src == "standby") {
		dst = DeviceDiagnosisOperatingStateEnumType::standby;
		return;
	}
	if (src == "failure") {
		dst = DeviceDiagnosisOperatingStateEnumType::failure;
		return;
	}
	if (src == "serviceNeeded") {
		dst = DeviceDiagnosisOperatingStateEnumType::serviceNeeded;
		return;
	}
	if (src == "overrideDetected") {
		dst = DeviceDiagnosisOperatingStateEnumType::overrideDetected;
		return;
	}
	if (src == "inAlarm") {
		dst = DeviceDiagnosisOperatingStateEnumType::inAlarm;
		return;
	}
	if (src == "notReachable") {
		dst = DeviceDiagnosisOperatingStateEnumType::notReachable;
		return;
	}
	if (src == "finished") {
		dst = DeviceDiagnosisOperatingStateEnumType::finished;
		return;
	}
	if (src == "temporarilyNotReady") {
		dst = DeviceDiagnosisOperatingStateEnumType::temporarilyNotReady;
		return;
	}
	if (src == "off") {
		dst = DeviceDiagnosisOperatingStateEnumType::off;
		return;
	}
	 return;
}
bool convertToJson(const PowerSupplyConditionEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case PowerSupplyConditionEnumType::good:
		 enumName = "good";
		break;
	case PowerSupplyConditionEnumType::low:
		 enumName = "low";
		break;
	case PowerSupplyConditionEnumType::critical:
		 enumName = "critical";
		break;
	case PowerSupplyConditionEnumType::unknown:
		 enumName = "unknown";
		break;
	case PowerSupplyConditionEnumType::error:
		 enumName = "error";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSupplyConditionEnumType &dst) {
	if (src == "good") {
		dst = PowerSupplyConditionEnumType::good;
		return;
	}
	if (src == "low") {
		dst = PowerSupplyConditionEnumType::low;
		return;
	}
	if (src == "critical") {
		dst = PowerSupplyConditionEnumType::critical;
		return;
	}
	if (src == "unknown") {
		dst = PowerSupplyConditionEnumType::unknown;
		return;
	}
	if (src == "error") {
		dst = PowerSupplyConditionEnumType::error;
		return;
	}
	 return;
}
bool convertToJson(const ElectricalConnectionMeasurandVariantEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ElectricalConnectionMeasurandVariantEnumType::amplitude:
		 enumName = "amplitude";
		break;
	case ElectricalConnectionMeasurandVariantEnumType::rms:
		 enumName = "rms";
		break;
	case ElectricalConnectionMeasurandVariantEnumType::instantaneous:
		 enumName = "instantaneous";
		break;
	case ElectricalConnectionMeasurandVariantEnumType::angle:
		 enumName = "angle";
		break;
	case ElectricalConnectionMeasurandVariantEnumType::cosPhi:
		 enumName = "cosPhi";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionMeasurandVariantEnumType &dst) {
	if (src == "amplitude") {
		dst = ElectricalConnectionMeasurandVariantEnumType::amplitude;
		return;
	}
	if (src == "rms") {
		dst = ElectricalConnectionMeasurandVariantEnumType::rms;
		return;
	}
	if (src == "instantaneous") {
		dst = ElectricalConnectionMeasurandVariantEnumType::instantaneous;
		return;
	}
	if (src == "angle") {
		dst = ElectricalConnectionMeasurandVariantEnumType::angle;
		return;
	}
	if (src == "cosPhi") {
		dst = ElectricalConnectionMeasurandVariantEnumType::cosPhi;
		return;
	}
	 return;
}
bool convertToJson(const ElectricalConnectionVoltageTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ElectricalConnectionVoltageTypeEnumType::ac:
		 enumName = "ac";
		break;
	case ElectricalConnectionVoltageTypeEnumType::dc:
		 enumName = "dc";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionVoltageTypeEnumType &dst) {
	if (src == "ac") {
		dst = ElectricalConnectionVoltageTypeEnumType::ac;
		return;
	}
	if (src == "dc") {
		dst = ElectricalConnectionVoltageTypeEnumType::dc;
		return;
	}
	 return;
}
bool convertToJson(const ElectricalConnectionAcMeasurementTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ElectricalConnectionAcMeasurementTypeEnumType::real:
		 enumName = "real";
		break;
	case ElectricalConnectionAcMeasurementTypeEnumType::reactive:
		 enumName = "reactive";
		break;
	case ElectricalConnectionAcMeasurementTypeEnumType::apparent:
		 enumName = "apparent";
		break;
	case ElectricalConnectionAcMeasurementTypeEnumType::phase:
		 enumName = "phase";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionAcMeasurementTypeEnumType &dst) {
	if (src == "real") {
		dst = ElectricalConnectionAcMeasurementTypeEnumType::real;
		return;
	}
	if (src == "reactive") {
		dst = ElectricalConnectionAcMeasurementTypeEnumType::reactive;
		return;
	}
	if (src == "apparent") {
		dst = ElectricalConnectionAcMeasurementTypeEnumType::apparent;
		return;
	}
	if (src == "phase") {
		dst = ElectricalConnectionAcMeasurementTypeEnumType::phase;
		return;
	}
	 return;
}
bool convertToJson(const ElectricalConnectionPhaseNameEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ElectricalConnectionPhaseNameEnumType::a:
		 enumName = "a";
		break;
	case ElectricalConnectionPhaseNameEnumType::b:
		 enumName = "b";
		break;
	case ElectricalConnectionPhaseNameEnumType::c:
		 enumName = "c";
		break;
	case ElectricalConnectionPhaseNameEnumType::ab:
		 enumName = "ab";
		break;
	case ElectricalConnectionPhaseNameEnumType::bc:
		 enumName = "bc";
		break;
	case ElectricalConnectionPhaseNameEnumType::ac:
		 enumName = "ac";
		break;
	case ElectricalConnectionPhaseNameEnumType::abc:
		 enumName = "abc";
		break;
	case ElectricalConnectionPhaseNameEnumType::neutral:
		 enumName = "neutral";
		break;
	case ElectricalConnectionPhaseNameEnumType::ground:
		 enumName = "ground";
		break;
	case ElectricalConnectionPhaseNameEnumType::none:
		 enumName = "none";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionPhaseNameEnumType &dst) {
	if (src == "a") {
		dst = ElectricalConnectionPhaseNameEnumType::a;
		return;
	}
	if (src == "b") {
		dst = ElectricalConnectionPhaseNameEnumType::b;
		return;
	}
	if (src == "c") {
		dst = ElectricalConnectionPhaseNameEnumType::c;
		return;
	}
	if (src == "ab") {
		dst = ElectricalConnectionPhaseNameEnumType::ab;
		return;
	}
	if (src == "bc") {
		dst = ElectricalConnectionPhaseNameEnumType::bc;
		return;
	}
	if (src == "ac") {
		dst = ElectricalConnectionPhaseNameEnumType::ac;
		return;
	}
	if (src == "abc") {
		dst = ElectricalConnectionPhaseNameEnumType::abc;
		return;
	}
	if (src == "neutral") {
		dst = ElectricalConnectionPhaseNameEnumType::neutral;
		return;
	}
	if (src == "ground") {
		dst = ElectricalConnectionPhaseNameEnumType::ground;
		return;
	}
	if (src == "none") {
		dst = ElectricalConnectionPhaseNameEnumType::none;
		return;
	}
	 return;
}
bool convertToJson(const ElectricalConnectionConnectionPointType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ElectricalConnectionConnectionPointType::grid:
		 enumName = "grid";
		break;
	case ElectricalConnectionConnectionPointType::home:
		 enumName = "home";
		break;
	case ElectricalConnectionConnectionPointType::pv:
		 enumName = "pv";
		break;
	case ElectricalConnectionConnectionPointType::sd:
		 enumName = "sd";
		break;
	case ElectricalConnectionConnectionPointType::other:
		 enumName = "other";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionConnectionPointType &dst) {
	if (src == "grid") {
		dst = ElectricalConnectionConnectionPointType::grid;
		return;
	}
	if (src == "home") {
		dst = ElectricalConnectionConnectionPointType::home;
		return;
	}
	if (src == "pv") {
		dst = ElectricalConnectionConnectionPointType::pv;
		return;
	}
	if (src == "sd") {
		dst = ElectricalConnectionConnectionPointType::sd;
		return;
	}
	if (src == "other") {
		dst = ElectricalConnectionConnectionPointType::other;
		return;
	}
	 return;
}
bool convertToJson(const ElectricalConnectionCharacteristicContextEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ElectricalConnectionCharacteristicContextEnumType::device:
		 enumName = "device";
		break;
	case ElectricalConnectionCharacteristicContextEnumType::entity:
		 enumName = "entity";
		break;
	case ElectricalConnectionCharacteristicContextEnumType::inverter:
		 enumName = "inverter";
		break;
	case ElectricalConnectionCharacteristicContextEnumType::pvString:
		 enumName = "pvString";
		break;
	case ElectricalConnectionCharacteristicContextEnumType::battery:
		 enumName = "battery";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicContextEnumType &dst) {
	if (src == "device") {
		dst = ElectricalConnectionCharacteristicContextEnumType::device;
		return;
	}
	if (src == "entity") {
		dst = ElectricalConnectionCharacteristicContextEnumType::entity;
		return;
	}
	if (src == "inverter") {
		dst = ElectricalConnectionCharacteristicContextEnumType::inverter;
		return;
	}
	if (src == "pvString") {
		dst = ElectricalConnectionCharacteristicContextEnumType::pvString;
		return;
	}
	if (src == "battery") {
		dst = ElectricalConnectionCharacteristicContextEnumType::battery;
		return;
	}
	 return;
}
bool convertToJson(const ElectricalConnectionCharacteristicTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ElectricalConnectionCharacteristicTypeEnumType::powerConsumptionMin:
		 enumName = "powerConsumptionMin";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::powerConsumptionMax:
		 enumName = "powerConsumptionMax";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::powerConsumptionNominalMin:
		 enumName = "powerConsumptionNominalMin";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::powerConsumptionNominalMax:
		 enumName = "powerConsumptionNominalMax";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::powerProductionMin:
		 enumName = "powerProductionMin";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::powerProductionMax:
		 enumName = "powerProductionMax";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::powerProductionNominalMin:
		 enumName = "powerProductionNominalMin";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::powerProductionNominalMax:
		 enumName = "powerProductionNominalMax";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::energyCapacityNominalMax:
		 enumName = "energyCapacityNominalMax";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::contractualConsumptionNominalMax:
		 enumName = "contractualConsumptionNominalMax";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::contractualProductionNominalMax:
		 enumName = "contractualProductionNominalMax";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::apparentPowerProductionNominalMax:
		 enumName = "apparentPowerProductionNominalMax";
		break;
	case ElectricalConnectionCharacteristicTypeEnumType::apparentPowerConsumptionNominalMax:
		 enumName = "apparentPowerConsumptionNominalMax";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicTypeEnumType &dst) {
	if (src == "powerConsumptionMin") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::powerConsumptionMin;
		return;
	}
	if (src == "powerConsumptionMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::powerConsumptionMax;
		return;
	}
	if (src == "powerConsumptionNominalMin") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::powerConsumptionNominalMin;
		return;
	}
	if (src == "powerConsumptionNominalMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::powerConsumptionNominalMax;
		return;
	}
	if (src == "powerProductionMin") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::powerProductionMin;
		return;
	}
	if (src == "powerProductionMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::powerProductionMax;
		return;
	}
	if (src == "powerProductionNominalMin") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::powerProductionNominalMin;
		return;
	}
	if (src == "powerProductionNominalMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::powerProductionNominalMax;
		return;
	}
	if (src == "energyCapacityNominalMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::energyCapacityNominalMax;
		return;
	}
	if (src == "contractualConsumptionNominalMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::contractualConsumptionNominalMax;
		return;
	}
	if (src == "contractualProductionNominalMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::contractualProductionNominalMax;
		return;
	}
	if (src == "apparentPowerProductionNominalMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::apparentPowerProductionNominalMax;
		return;
	}
	if (src == "apparentPowerConsumptionNominalMax") {
		dst = ElectricalConnectionCharacteristicTypeEnumType::apparentPowerConsumptionNominalMax;
		return;
	}
	 return;
}
bool convertToJson(const HvacSystemFunctionTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case HvacSystemFunctionTypeEnumType::heating:
		 enumName = "heating";
		break;
	case HvacSystemFunctionTypeEnumType::cooling:
		 enumName = "cooling";
		break;
	case HvacSystemFunctionTypeEnumType::ventilation:
		 enumName = "ventilation";
		break;
	case HvacSystemFunctionTypeEnumType::dhw:
		 enumName = "dhw";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionTypeEnumType &dst) {
	if (src == "heating") {
		dst = HvacSystemFunctionTypeEnumType::heating;
		return;
	}
	if (src == "cooling") {
		dst = HvacSystemFunctionTypeEnumType::cooling;
		return;
	}
	if (src == "ventilation") {
		dst = HvacSystemFunctionTypeEnumType::ventilation;
		return;
	}
	if (src == "dhw") {
		dst = HvacSystemFunctionTypeEnumType::dhw;
		return;
	}
	 return;
}
bool convertToJson(const HvacOperationModeTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case HvacOperationModeTypeEnumType::var_auto:
		 enumName = "auto";
		break;
	case HvacOperationModeTypeEnumType::on:
		 enumName = "on";
		break;
	case HvacOperationModeTypeEnumType::off:
		 enumName = "off";
		break;
	case HvacOperationModeTypeEnumType::eco:
		 enumName = "eco";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOperationModeTypeEnumType &dst) {
	if (src == "auto") {
		dst = HvacOperationModeTypeEnumType::var_auto;
		return;
	}
	if (src == "on") {
		dst = HvacOperationModeTypeEnumType::on;
		return;
	}
	if (src == "off") {
		dst = HvacOperationModeTypeEnumType::off;
		return;
	}
	if (src == "eco") {
		dst = HvacOperationModeTypeEnumType::eco;
		return;
	}
	 return;
}
bool convertToJson(const HvacOverrunTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case HvacOverrunTypeEnumType::oneTimeDhw:
		 enumName = "oneTimeDhw";
		break;
	case HvacOverrunTypeEnumType::party:
		 enumName = "party";
		break;
	case HvacOverrunTypeEnumType::sgReadyCondition1:
		 enumName = "sgReadyCondition1";
		break;
	case HvacOverrunTypeEnumType::sgReadyCondition3:
		 enumName = "sgReadyCondition3";
		break;
	case HvacOverrunTypeEnumType::sgReadyCondition4:
		 enumName = "sgReadyCondition4";
		break;
	case HvacOverrunTypeEnumType::oneDayAway:
		 enumName = "oneDayAway";
		break;
	case HvacOverrunTypeEnumType::oneDayAtHome:
		 enumName = "oneDayAtHome";
		break;
	case HvacOverrunTypeEnumType::oneTimeVentilation:
		 enumName = "oneTimeVentilation";
		break;
	case HvacOverrunTypeEnumType::hvacSystemOff:
		 enumName = "hvacSystemOff";
		break;
	case HvacOverrunTypeEnumType::valveKick:
		 enumName = "valveKick";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunTypeEnumType &dst) {
	if (src == "oneTimeDhw") {
		dst = HvacOverrunTypeEnumType::oneTimeDhw;
		return;
	}
	if (src == "party") {
		dst = HvacOverrunTypeEnumType::party;
		return;
	}
	if (src == "sgReadyCondition1") {
		dst = HvacOverrunTypeEnumType::sgReadyCondition1;
		return;
	}
	if (src == "sgReadyCondition3") {
		dst = HvacOverrunTypeEnumType::sgReadyCondition3;
		return;
	}
	if (src == "sgReadyCondition4") {
		dst = HvacOverrunTypeEnumType::sgReadyCondition4;
		return;
	}
	if (src == "oneDayAway") {
		dst = HvacOverrunTypeEnumType::oneDayAway;
		return;
	}
	if (src == "oneDayAtHome") {
		dst = HvacOverrunTypeEnumType::oneDayAtHome;
		return;
	}
	if (src == "oneTimeVentilation") {
		dst = HvacOverrunTypeEnumType::oneTimeVentilation;
		return;
	}
	if (src == "hvacSystemOff") {
		dst = HvacOverrunTypeEnumType::hvacSystemOff;
		return;
	}
	if (src == "valveKick") {
		dst = HvacOverrunTypeEnumType::valveKick;
		return;
	}
	 return;
}
bool convertToJson(const HvacOverrunStatusEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case HvacOverrunStatusEnumType::active:
		 enumName = "active";
		break;
	case HvacOverrunStatusEnumType::running:
		 enumName = "running";
		break;
	case HvacOverrunStatusEnumType::finished:
		 enumName = "finished";
		break;
	case HvacOverrunStatusEnumType::inactive:
		 enumName = "inactive";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunStatusEnumType &dst) {
	if (src == "active") {
		dst = HvacOverrunStatusEnumType::active;
		return;
	}
	if (src == "running") {
		dst = HvacOverrunStatusEnumType::running;
		return;
	}
	if (src == "finished") {
		dst = HvacOverrunStatusEnumType::finished;
		return;
	}
	if (src == "inactive") {
		dst = HvacOverrunStatusEnumType::inactive;
		return;
	}
	 return;
}
bool convertToJson(const SetpointTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case SetpointTypeEnumType::valueAbsolute:
		 enumName = "valueAbsolute";
		break;
	case SetpointTypeEnumType::valueRelative:
		 enumName = "valueRelative";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointTypeEnumType &dst) {
	if (src == "valueAbsolute") {
		dst = SetpointTypeEnumType::valueAbsolute;
		return;
	}
	if (src == "valueRelative") {
		dst = SetpointTypeEnumType::valueRelative;
		return;
	}
	 return;
}
bool convertToJson(const TimeSlotTimeModeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case TimeSlotTimeModeEnumType::absolute:
		 enumName = "absolute";
		break;
	case TimeSlotTimeModeEnumType::recurring:
		 enumName = "recurring";
		break;
	case TimeSlotTimeModeEnumType::both:
		 enumName = "both";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSlotTimeModeEnumType &dst) {
	if (src == "absolute") {
		dst = TimeSlotTimeModeEnumType::absolute;
		return;
	}
	if (src == "recurring") {
		dst = TimeSlotTimeModeEnumType::recurring;
		return;
	}
	if (src == "both") {
		dst = TimeSlotTimeModeEnumType::both;
		return;
	}
	 return;
}
bool convertToJson(const TierBoundaryTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case TierBoundaryTypeEnumType::powerBoundary:
		 enumName = "powerBoundary";
		break;
	case TierBoundaryTypeEnumType::energyBoundary:
		 enumName = "energyBoundary";
		break;
	case TierBoundaryTypeEnumType::countBoundary:
		 enumName = "countBoundary";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryTypeEnumType &dst) {
	if (src == "powerBoundary") {
		dst = TierBoundaryTypeEnumType::powerBoundary;
		return;
	}
	if (src == "energyBoundary") {
		dst = TierBoundaryTypeEnumType::energyBoundary;
		return;
	}
	if (src == "countBoundary") {
		dst = TierBoundaryTypeEnumType::countBoundary;
		return;
	}
	 return;
}
bool convertToJson(const TierTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case TierTypeEnumType::fixedCost:
		 enumName = "fixedCost";
		break;
	case TierTypeEnumType::dynamicCost:
		 enumName = "dynamicCost";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, TierTypeEnumType &dst) {
	if (src == "fixedCost") {
		dst = TierTypeEnumType::fixedCost;
		return;
	}
	if (src == "dynamicCost") {
		dst = TierTypeEnumType::dynamicCost;
		return;
	}
	 return;
}
bool convertToJson(const IncentiveTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case IncentiveTypeEnumType::absoluteCost:
		 enumName = "absoluteCost";
		break;
	case IncentiveTypeEnumType::relativeCost:
		 enumName = "relativeCost";
		break;
	case IncentiveTypeEnumType::renewableEnergyPercentage:
		 enumName = "renewableEnergyPercentage";
		break;
	case IncentiveTypeEnumType::co2Emission:
		 enumName = "co2Emission";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTypeEnumType &dst) {
	if (src == "absoluteCost") {
		dst = IncentiveTypeEnumType::absoluteCost;
		return;
	}
	if (src == "relativeCost") {
		dst = IncentiveTypeEnumType::relativeCost;
		return;
	}
	if (src == "renewableEnergyPercentage") {
		dst = IncentiveTypeEnumType::renewableEnergyPercentage;
		return;
	}
	if (src == "co2Emission") {
		dst = IncentiveTypeEnumType::co2Emission;
		return;
	}
	 return;
}
bool convertToJson(const IncentiveValueTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case IncentiveValueTypeEnumType::value:
		 enumName = "value";
		break;
	case IncentiveValueTypeEnumType::averageValue:
		 enumName = "averageValue";
		break;
	case IncentiveValueTypeEnumType::minValue:
		 enumName = "minValue";
		break;
	case IncentiveValueTypeEnumType::maxValue:
		 enumName = "maxValue";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveValueTypeEnumType &dst) {
	if (src == "value") {
		dst = IncentiveValueTypeEnumType::value;
		return;
	}
	if (src == "averageValue") {
		dst = IncentiveValueTypeEnumType::averageValue;
		return;
	}
	if (src == "minValue") {
		dst = IncentiveValueTypeEnumType::minValue;
		return;
	}
	if (src == "maxValue") {
		dst = IncentiveValueTypeEnumType::maxValue;
		return;
	}
	 return;
}
bool convertToJson(const LoadControlEventActionEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case LoadControlEventActionEnumType::pause:
		 enumName = "pause";
		break;
	case LoadControlEventActionEnumType::resume:
		 enumName = "resume";
		break;
	case LoadControlEventActionEnumType::reduce:
		 enumName = "reduce";
		break;
	case LoadControlEventActionEnumType::increase:
		 enumName = "increase";
		break;
	case LoadControlEventActionEnumType::emergency:
		 enumName = "emergency";
		break;
	case LoadControlEventActionEnumType::normal:
		 enumName = "normal";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlEventActionEnumType &dst) {
	if (src == "pause") {
		dst = LoadControlEventActionEnumType::pause;
		return;
	}
	if (src == "resume") {
		dst = LoadControlEventActionEnumType::resume;
		return;
	}
	if (src == "reduce") {
		dst = LoadControlEventActionEnumType::reduce;
		return;
	}
	if (src == "increase") {
		dst = LoadControlEventActionEnumType::increase;
		return;
	}
	if (src == "emergency") {
		dst = LoadControlEventActionEnumType::emergency;
		return;
	}
	if (src == "normal") {
		dst = LoadControlEventActionEnumType::normal;
		return;
	}
	 return;
}
bool convertToJson(const LoadControlEventStateEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case LoadControlEventStateEnumType::eventAccepted:
		 enumName = "eventAccepted";
		break;
	case LoadControlEventStateEnumType::eventStarted:
		 enumName = "eventStarted";
		break;
	case LoadControlEventStateEnumType::eventStopped:
		 enumName = "eventStopped";
		break;
	case LoadControlEventStateEnumType::eventRejected:
		 enumName = "eventRejected";
		break;
	case LoadControlEventStateEnumType::eventCancelled:
		 enumName = "eventCancelled";
		break;
	case LoadControlEventStateEnumType::eventError:
		 enumName = "eventError";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlEventStateEnumType &dst) {
	if (src == "eventAccepted") {
		dst = LoadControlEventStateEnumType::eventAccepted;
		return;
	}
	if (src == "eventStarted") {
		dst = LoadControlEventStateEnumType::eventStarted;
		return;
	}
	if (src == "eventStopped") {
		dst = LoadControlEventStateEnumType::eventStopped;
		return;
	}
	if (src == "eventRejected") {
		dst = LoadControlEventStateEnumType::eventRejected;
		return;
	}
	if (src == "eventCancelled") {
		dst = LoadControlEventStateEnumType::eventCancelled;
		return;
	}
	if (src == "eventError") {
		dst = LoadControlEventStateEnumType::eventError;
		return;
	}
	 return;
}
bool convertToJson(const LoadControlLimitTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case LoadControlLimitTypeEnumType::minValueLimit:
		 enumName = "minValueLimit";
		break;
	case LoadControlLimitTypeEnumType::maxValueLimit:
		 enumName = "maxValueLimit";
		break;
	case LoadControlLimitTypeEnumType::signDependentAbsValueLimit:
		 enumName = "signDependentAbsValueLimit";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitTypeEnumType &dst) {
	if (src == "minValueLimit") {
		dst = LoadControlLimitTypeEnumType::minValueLimit;
		return;
	}
	if (src == "maxValueLimit") {
		dst = LoadControlLimitTypeEnumType::maxValueLimit;
		return;
	}
	if (src == "signDependentAbsValueLimit") {
		dst = LoadControlLimitTypeEnumType::signDependentAbsValueLimit;
		return;
	}
	 return;
}
bool convertToJson(const LoadControlCategoryEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case LoadControlCategoryEnumType::obligation:
		 enumName = "obligation";
		break;
	case LoadControlCategoryEnumType::recommendation:
		 enumName = "recommendation";
		break;
	case LoadControlCategoryEnumType::optimization:
		 enumName = "optimization";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlCategoryEnumType &dst) {
	if (src == "obligation") {
		dst = LoadControlCategoryEnumType::obligation;
		return;
	}
	if (src == "recommendation") {
		dst = LoadControlCategoryEnumType::recommendation;
		return;
	}
	if (src == "optimization") {
		dst = LoadControlCategoryEnumType::optimization;
		return;
	}
	 return;
}
bool convertToJson(const NetworkManagementFeatureSetType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case NetworkManagementFeatureSetType::gateway:
		 enumName = "gateway";
		break;
	case NetworkManagementFeatureSetType::router:
		 enumName = "router";
		break;
	case NetworkManagementFeatureSetType::smart:
		 enumName = "smart";
		break;
	case NetworkManagementFeatureSetType::simple:
		 enumName = "simple";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementFeatureSetType &dst) {
	if (src == "gateway") {
		dst = NetworkManagementFeatureSetType::gateway;
		return;
	}
	if (src == "router") {
		dst = NetworkManagementFeatureSetType::router;
		return;
	}
	if (src == "smart") {
		dst = NetworkManagementFeatureSetType::smart;
		return;
	}
	if (src == "simple") {
		dst = NetworkManagementFeatureSetType::simple;
		return;
	}
	 return;
}
bool convertToJson(const NetworkManagementProcessStateStateType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case NetworkManagementProcessStateStateType::succeeded:
		 enumName = "succeeded";
		break;
	case NetworkManagementProcessStateStateType::failed:
		 enumName = "failed";
		break;
	case NetworkManagementProcessStateStateType::aborted:
		 enumName = "aborted";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementProcessStateStateType &dst) {
	if (src == "succeeded") {
		dst = NetworkManagementProcessStateStateType::succeeded;
		return;
	}
	if (src == "failed") {
		dst = NetworkManagementProcessStateStateType::failed;
		return;
	}
	if (src == "aborted") {
		dst = NetworkManagementProcessStateStateType::aborted;
		return;
	}
	 return;
}
bool convertToJson(const NetworkManagementStateChangeType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case NetworkManagementStateChangeType::added:
		 enumName = "added";
		break;
	case NetworkManagementStateChangeType::removed:
		 enumName = "removed";
		break;
	case NetworkManagementStateChangeType::modified:
		 enumName = "modified";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementStateChangeType &dst) {
	if (src == "added") {
		dst = NetworkManagementStateChangeType::added;
		return;
	}
	if (src == "removed") {
		dst = NetworkManagementStateChangeType::removed;
		return;
	}
	if (src == "modified") {
		dst = NetworkManagementStateChangeType::modified;
		return;
	}
	 return;
}
bool convertToJson(const SensingStateEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case SensingStateEnumType::on:
		 enumName = "on";
		break;
	case SensingStateEnumType::off:
		 enumName = "off";
		break;
	case SensingStateEnumType::toggle:
		 enumName = "toggle";
		break;
	case SensingStateEnumType::level:
		 enumName = "level";
		break;
	case SensingStateEnumType::levelUp:
		 enumName = "levelUp";
		break;
	case SensingStateEnumType::levelDown:
		 enumName = "levelDown";
		break;
	case SensingStateEnumType::levelStart:
		 enumName = "levelStart";
		break;
	case SensingStateEnumType::levelStop:
		 enumName = "levelStop";
		break;
	case SensingStateEnumType::levelAbsolute:
		 enumName = "levelAbsolute";
		break;
	case SensingStateEnumType::levelRelative:
		 enumName = "levelRelative";
		break;
	case SensingStateEnumType::levelPercentageAbsolute:
		 enumName = "levelPercentageAbsolute";
		break;
	case SensingStateEnumType::levelPercentageRelative:
		 enumName = "levelPercentageRelative";
		break;
	case SensingStateEnumType::pressed:
		 enumName = "pressed";
		break;
	case SensingStateEnumType::longPressed:
		 enumName = "longPressed";
		break;
	case SensingStateEnumType::released:
		 enumName = "released";
		break;
	case SensingStateEnumType::changed:
		 enumName = "changed";
		break;
	case SensingStateEnumType::started:
		 enumName = "started";
		break;
	case SensingStateEnumType::stopped:
		 enumName = "stopped";
		break;
	case SensingStateEnumType::paused:
		 enumName = "paused";
		break;
	case SensingStateEnumType::middle:
		 enumName = "middle";
		break;
	case SensingStateEnumType::up:
		 enumName = "up";
		break;
	case SensingStateEnumType::down:
		 enumName = "down";
		break;
	case SensingStateEnumType::forward:
		 enumName = "forward";
		break;
	case SensingStateEnumType::backwards:
		 enumName = "backwards";
		break;
	case SensingStateEnumType::open:
		 enumName = "open";
		break;
	case SensingStateEnumType::closed:
		 enumName = "closed";
		break;
	case SensingStateEnumType::opening:
		 enumName = "opening";
		break;
	case SensingStateEnumType::closing:
		 enumName = "closing";
		break;
	case SensingStateEnumType::high:
		 enumName = "high";
		break;
	case SensingStateEnumType::low:
		 enumName = "low";
		break;
	case SensingStateEnumType::day:
		 enumName = "day";
		break;
	case SensingStateEnumType::night:
		 enumName = "night";
		break;
	case SensingStateEnumType::detected:
		 enumName = "detected";
		break;
	case SensingStateEnumType::notDetected:
		 enumName = "notDetected";
		break;
	case SensingStateEnumType::alarmed:
		 enumName = "alarmed";
		break;
	case SensingStateEnumType::notAlarmed:
		 enumName = "notAlarmed";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, SensingStateEnumType &dst) {
	if (src == "on") {
		dst = SensingStateEnumType::on;
		return;
	}
	if (src == "off") {
		dst = SensingStateEnumType::off;
		return;
	}
	if (src == "toggle") {
		dst = SensingStateEnumType::toggle;
		return;
	}
	if (src == "level") {
		dst = SensingStateEnumType::level;
		return;
	}
	if (src == "levelUp") {
		dst = SensingStateEnumType::levelUp;
		return;
	}
	if (src == "levelDown") {
		dst = SensingStateEnumType::levelDown;
		return;
	}
	if (src == "levelStart") {
		dst = SensingStateEnumType::levelStart;
		return;
	}
	if (src == "levelStop") {
		dst = SensingStateEnumType::levelStop;
		return;
	}
	if (src == "levelAbsolute") {
		dst = SensingStateEnumType::levelAbsolute;
		return;
	}
	if (src == "levelRelative") {
		dst = SensingStateEnumType::levelRelative;
		return;
	}
	if (src == "levelPercentageAbsolute") {
		dst = SensingStateEnumType::levelPercentageAbsolute;
		return;
	}
	if (src == "levelPercentageRelative") {
		dst = SensingStateEnumType::levelPercentageRelative;
		return;
	}
	if (src == "pressed") {
		dst = SensingStateEnumType::pressed;
		return;
	}
	if (src == "longPressed") {
		dst = SensingStateEnumType::longPressed;
		return;
	}
	if (src == "released") {
		dst = SensingStateEnumType::released;
		return;
	}
	if (src == "changed") {
		dst = SensingStateEnumType::changed;
		return;
	}
	if (src == "started") {
		dst = SensingStateEnumType::started;
		return;
	}
	if (src == "stopped") {
		dst = SensingStateEnumType::stopped;
		return;
	}
	if (src == "paused") {
		dst = SensingStateEnumType::paused;
		return;
	}
	if (src == "middle") {
		dst = SensingStateEnumType::middle;
		return;
	}
	if (src == "up") {
		dst = SensingStateEnumType::up;
		return;
	}
	if (src == "down") {
		dst = SensingStateEnumType::down;
		return;
	}
	if (src == "forward") {
		dst = SensingStateEnumType::forward;
		return;
	}
	if (src == "backwards") {
		dst = SensingStateEnumType::backwards;
		return;
	}
	if (src == "open") {
		dst = SensingStateEnumType::open;
		return;
	}
	if (src == "closed") {
		dst = SensingStateEnumType::closed;
		return;
	}
	if (src == "opening") {
		dst = SensingStateEnumType::opening;
		return;
	}
	if (src == "closing") {
		dst = SensingStateEnumType::closing;
		return;
	}
	if (src == "high") {
		dst = SensingStateEnumType::high;
		return;
	}
	if (src == "low") {
		dst = SensingStateEnumType::low;
		return;
	}
	if (src == "day") {
		dst = SensingStateEnumType::day;
		return;
	}
	if (src == "night") {
		dst = SensingStateEnumType::night;
		return;
	}
	if (src == "detected") {
		dst = SensingStateEnumType::detected;
		return;
	}
	if (src == "notDetected") {
		dst = SensingStateEnumType::notDetected;
		return;
	}
	if (src == "alarmed") {
		dst = SensingStateEnumType::alarmed;
		return;
	}
	if (src == "notAlarmed") {
		dst = SensingStateEnumType::notAlarmed;
		return;
	}
	 return;
}
bool convertToJson(const SensingTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case SensingTypeEnumType::var_switch:
		 enumName = "switch";
		break;
	case SensingTypeEnumType::button:
		 enumName = "button";
		break;
	case SensingTypeEnumType::level:
		 enumName = "level";
		break;
	case SensingTypeEnumType::levelSwitch:
		 enumName = "levelSwitch";
		break;
	case SensingTypeEnumType::windowHandle:
		 enumName = "windowHandle";
		break;
	case SensingTypeEnumType::contactSensor:
		 enumName = "contactSensor";
		break;
	case SensingTypeEnumType::occupancySensor:
		 enumName = "occupancySensor";
		break;
	case SensingTypeEnumType::motionDetector:
		 enumName = "motionDetector";
		break;
	case SensingTypeEnumType::fireDetector:
		 enumName = "fireDetector";
		break;
	case SensingTypeEnumType::smokeDetector:
		 enumName = "smokeDetector";
		break;
	case SensingTypeEnumType::heatDetector:
		 enumName = "heatDetector";
		break;
	case SensingTypeEnumType::waterDetector:
		 enumName = "waterDetector";
		break;
	case SensingTypeEnumType::gasDetector:
		 enumName = "gasDetector";
		break;
	case SensingTypeEnumType::alarmSensor:
		 enumName = "alarmSensor";
		break;
	case SensingTypeEnumType::powerAlarmSensor:
		 enumName = "powerAlarmSensor";
		break;
	case SensingTypeEnumType::dayNightIndicator:
		 enumName = "dayNightIndicator";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, SensingTypeEnumType &dst) {
	if (src == "switch") {
		dst = SensingTypeEnumType::var_switch;
		return;
	}
	if (src == "button") {
		dst = SensingTypeEnumType::button;
		return;
	}
	if (src == "level") {
		dst = SensingTypeEnumType::level;
		return;
	}
	if (src == "levelSwitch") {
		dst = SensingTypeEnumType::levelSwitch;
		return;
	}
	if (src == "windowHandle") {
		dst = SensingTypeEnumType::windowHandle;
		return;
	}
	if (src == "contactSensor") {
		dst = SensingTypeEnumType::contactSensor;
		return;
	}
	if (src == "occupancySensor") {
		dst = SensingTypeEnumType::occupancySensor;
		return;
	}
	if (src == "motionDetector") {
		dst = SensingTypeEnumType::motionDetector;
		return;
	}
	if (src == "fireDetector") {
		dst = SensingTypeEnumType::fireDetector;
		return;
	}
	if (src == "smokeDetector") {
		dst = SensingTypeEnumType::smokeDetector;
		return;
	}
	if (src == "heatDetector") {
		dst = SensingTypeEnumType::heatDetector;
		return;
	}
	if (src == "waterDetector") {
		dst = SensingTypeEnumType::waterDetector;
		return;
	}
	if (src == "gasDetector") {
		dst = SensingTypeEnumType::gasDetector;
		return;
	}
	if (src == "alarmSensor") {
		dst = SensingTypeEnumType::alarmSensor;
		return;
	}
	if (src == "powerAlarmSensor") {
		dst = SensingTypeEnumType::powerAlarmSensor;
		return;
	}
	if (src == "dayNightIndicator") {
		dst = SensingTypeEnumType::dayNightIndicator;
		return;
	}
	 return;
}
bool convertToJson(const StateInformationFunctionalityEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case StateInformationFunctionalityEnumType::externalOverrideFromGrid:
		 enumName = "externalOverrideFromGrid";
		break;
	case StateInformationFunctionalityEnumType::autonomousGridSupport:
		 enumName = "autonomousGridSupport";
		break;
	case StateInformationFunctionalityEnumType::islandingMode:
		 enumName = "islandingMode";
		break;
	case StateInformationFunctionalityEnumType::balancing:
		 enumName = "balancing";
		break;
	case StateInformationFunctionalityEnumType::trickleCharging:
		 enumName = "trickleCharging";
		break;
	case StateInformationFunctionalityEnumType::calibration:
		 enumName = "calibration";
		break;
	case StateInformationFunctionalityEnumType::commissioningMissing:
		 enumName = "commissioningMissing";
		break;
	case StateInformationFunctionalityEnumType::sleeping:
		 enumName = "sleeping";
		break;
	case StateInformationFunctionalityEnumType::starting:
		 enumName = "starting";
		break;
	case StateInformationFunctionalityEnumType::mppt:
		 enumName = "mppt";
		break;
	case StateInformationFunctionalityEnumType::throttled:
		 enumName = "throttled";
		break;
	case StateInformationFunctionalityEnumType::shuttingDown:
		 enumName = "shuttingDown";
		break;
	case StateInformationFunctionalityEnumType::manualShutdown:
		 enumName = "manualShutdown";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, StateInformationFunctionalityEnumType &dst) {
	if (src == "externalOverrideFromGrid") {
		dst = StateInformationFunctionalityEnumType::externalOverrideFromGrid;
		return;
	}
	if (src == "autonomousGridSupport") {
		dst = StateInformationFunctionalityEnumType::autonomousGridSupport;
		return;
	}
	if (src == "islandingMode") {
		dst = StateInformationFunctionalityEnumType::islandingMode;
		return;
	}
	if (src == "balancing") {
		dst = StateInformationFunctionalityEnumType::balancing;
		return;
	}
	if (src == "trickleCharging") {
		dst = StateInformationFunctionalityEnumType::trickleCharging;
		return;
	}
	if (src == "calibration") {
		dst = StateInformationFunctionalityEnumType::calibration;
		return;
	}
	if (src == "commissioningMissing") {
		dst = StateInformationFunctionalityEnumType::commissioningMissing;
		return;
	}
	if (src == "sleeping") {
		dst = StateInformationFunctionalityEnumType::sleeping;
		return;
	}
	if (src == "starting") {
		dst = StateInformationFunctionalityEnumType::starting;
		return;
	}
	if (src == "mppt") {
		dst = StateInformationFunctionalityEnumType::mppt;
		return;
	}
	if (src == "throttled") {
		dst = StateInformationFunctionalityEnumType::throttled;
		return;
	}
	if (src == "shuttingDown") {
		dst = StateInformationFunctionalityEnumType::shuttingDown;
		return;
	}
	if (src == "manualShutdown") {
		dst = StateInformationFunctionalityEnumType::manualShutdown;
		return;
	}
	 return;
}
bool convertToJson(const StateInformationFailureEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case StateInformationFailureEnumType::inverterDefective:
		 enumName = "inverterDefective";
		break;
	case StateInformationFailureEnumType::batteryOvercurrentProtection:
		 enumName = "batteryOvercurrentProtection";
		break;
	case StateInformationFailureEnumType::pvStringOvercurrentProtection:
		 enumName = "pvStringOvercurrentProtection";
		break;
	case StateInformationFailureEnumType::gridFault:
		 enumName = "gridFault";
		break;
	case StateInformationFailureEnumType::groundFault:
		 enumName = "groundFault";
		break;
	case StateInformationFailureEnumType::acDisconnected:
		 enumName = "acDisconnected";
		break;
	case StateInformationFailureEnumType::dcDisconnected:
		 enumName = "dcDisconnected";
		break;
	case StateInformationFailureEnumType::cabinetOpen:
		 enumName = "cabinetOpen";
		break;
	case StateInformationFailureEnumType::overTemperature:
		 enumName = "overTemperature";
		break;
	case StateInformationFailureEnumType::underTemperature:
		 enumName = "underTemperature";
		break;
	case StateInformationFailureEnumType::frequencyAboveLimit:
		 enumName = "frequencyAboveLimit";
		break;
	case StateInformationFailureEnumType::frequencyBelowLimit:
		 enumName = "frequencyBelowLimit";
		break;
	case StateInformationFailureEnumType::acVoltageAboveLimit:
		 enumName = "acVoltageAboveLimit";
		break;
	case StateInformationFailureEnumType::acVoltageBelowLimit:
		 enumName = "acVoltageBelowLimit";
		break;
	case StateInformationFailureEnumType::dcVoltageAboveLimit:
		 enumName = "dcVoltageAboveLimit";
		break;
	case StateInformationFailureEnumType::dcVoltageBelowLimit:
		 enumName = "dcVoltageBelowLimit";
		break;
	case StateInformationFailureEnumType::hardwareTestFailure:
		 enumName = "hardwareTestFailure";
		break;
	case StateInformationFailureEnumType::genericInternalError:
		 enumName = "genericInternalError";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, StateInformationFailureEnumType &dst) {
	if (src == "inverterDefective") {
		dst = StateInformationFailureEnumType::inverterDefective;
		return;
	}
	if (src == "batteryOvercurrentProtection") {
		dst = StateInformationFailureEnumType::batteryOvercurrentProtection;
		return;
	}
	if (src == "pvStringOvercurrentProtection") {
		dst = StateInformationFailureEnumType::pvStringOvercurrentProtection;
		return;
	}
	if (src == "gridFault") {
		dst = StateInformationFailureEnumType::gridFault;
		return;
	}
	if (src == "groundFault") {
		dst = StateInformationFailureEnumType::groundFault;
		return;
	}
	if (src == "acDisconnected") {
		dst = StateInformationFailureEnumType::acDisconnected;
		return;
	}
	if (src == "dcDisconnected") {
		dst = StateInformationFailureEnumType::dcDisconnected;
		return;
	}
	if (src == "cabinetOpen") {
		dst = StateInformationFailureEnumType::cabinetOpen;
		return;
	}
	if (src == "overTemperature") {
		dst = StateInformationFailureEnumType::overTemperature;
		return;
	}
	if (src == "underTemperature") {
		dst = StateInformationFailureEnumType::underTemperature;
		return;
	}
	if (src == "frequencyAboveLimit") {
		dst = StateInformationFailureEnumType::frequencyAboveLimit;
		return;
	}
	if (src == "frequencyBelowLimit") {
		dst = StateInformationFailureEnumType::frequencyBelowLimit;
		return;
	}
	if (src == "acVoltageAboveLimit") {
		dst = StateInformationFailureEnumType::acVoltageAboveLimit;
		return;
	}
	if (src == "acVoltageBelowLimit") {
		dst = StateInformationFailureEnumType::acVoltageBelowLimit;
		return;
	}
	if (src == "dcVoltageAboveLimit") {
		dst = StateInformationFailureEnumType::dcVoltageAboveLimit;
		return;
	}
	if (src == "dcVoltageBelowLimit") {
		dst = StateInformationFailureEnumType::dcVoltageBelowLimit;
		return;
	}
	if (src == "hardwareTestFailure") {
		dst = StateInformationFailureEnumType::hardwareTestFailure;
		return;
	}
	if (src == "genericInternalError") {
		dst = StateInformationFailureEnumType::genericInternalError;
		return;
	}
	 return;
}
bool convertToJson(const StateInformationCategoryEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case StateInformationCategoryEnumType::functionality:
		 enumName = "functionality";
		break;
	case StateInformationCategoryEnumType::failure:
		 enumName = "failure";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, StateInformationCategoryEnumType &dst) {
	if (src == "functionality") {
		dst = StateInformationCategoryEnumType::functionality;
		return;
	}
	if (src == "failure") {
		dst = StateInformationCategoryEnumType::failure;
		return;
	}
	 return;
}
bool convertToJson(const SupplyConditionEventTypeEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case SupplyConditionEventTypeEnumType::thesholdExceeded:
		 enumName = "thesholdExceeded";
		break;
	case SupplyConditionEventTypeEnumType::fallenBelowThreshold:
		 enumName = "fallenBelowThreshold";
		break;
	case SupplyConditionEventTypeEnumType::supplyInterrupt:
		 enumName = "supplyInterrupt";
		break;
	case SupplyConditionEventTypeEnumType::releaseOfLimitations:
		 enumName = "releaseOfLimitations";
		break;
	case SupplyConditionEventTypeEnumType::otherProblem:
		 enumName = "otherProblem";
		break;
	case SupplyConditionEventTypeEnumType::gridConditionUpdate:
		 enumName = "gridConditionUpdate";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionEventTypeEnumType &dst) {
	if (src == "thesholdExceeded") {
		dst = SupplyConditionEventTypeEnumType::thesholdExceeded;
		return;
	}
	if (src == "fallenBelowThreshold") {
		dst = SupplyConditionEventTypeEnumType::fallenBelowThreshold;
		return;
	}
	if (src == "supplyInterrupt") {
		dst = SupplyConditionEventTypeEnumType::supplyInterrupt;
		return;
	}
	if (src == "releaseOfLimitations") {
		dst = SupplyConditionEventTypeEnumType::releaseOfLimitations;
		return;
	}
	if (src == "otherProblem") {
		dst = SupplyConditionEventTypeEnumType::otherProblem;
		return;
	}
	if (src == "gridConditionUpdate") {
		dst = SupplyConditionEventTypeEnumType::gridConditionUpdate;
		return;
	}
	 return;
}
bool convertToJson(const SupplyConditionOriginatorEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case SupplyConditionOriginatorEnumType::externDSO:
		 enumName = "externDSO";
		break;
	case SupplyConditionOriginatorEnumType::externSupplier:
		 enumName = "externSupplier";
		break;
	case SupplyConditionOriginatorEnumType::internalLimit:
		 enumName = "internalLimit";
		break;
	case SupplyConditionOriginatorEnumType::internalService:
		 enumName = "internalService";
		break;
	case SupplyConditionOriginatorEnumType::internalUser:
		 enumName = "internalUser";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionOriginatorEnumType &dst) {
	if (src == "externDSO") {
		dst = SupplyConditionOriginatorEnumType::externDSO;
		return;
	}
	if (src == "externSupplier") {
		dst = SupplyConditionOriginatorEnumType::externSupplier;
		return;
	}
	if (src == "internalLimit") {
		dst = SupplyConditionOriginatorEnumType::internalLimit;
		return;
	}
	if (src == "internalService") {
		dst = SupplyConditionOriginatorEnumType::internalService;
		return;
	}
	if (src == "internalUser") {
		dst = SupplyConditionOriginatorEnumType::internalUser;
		return;
	}
	 return;
}
bool convertToJson(const GridConditionEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case GridConditionEnumType::consumptionRed:
		 enumName = "consumptionRed";
		break;
	case GridConditionEnumType::consumptionYellow:
		 enumName = "consumptionYellow";
		break;
	case GridConditionEnumType::good:
		 enumName = "good";
		break;
	case GridConditionEnumType::productionYellow:
		 enumName = "productionYellow";
		break;
	case GridConditionEnumType::productionRed:
		 enumName = "productionRed";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, GridConditionEnumType &dst) {
	if (src == "consumptionRed") {
		dst = GridConditionEnumType::consumptionRed;
		return;
	}
	if (src == "consumptionYellow") {
		dst = GridConditionEnumType::consumptionYellow;
		return;
	}
	if (src == "good") {
		dst = GridConditionEnumType::good;
		return;
	}
	if (src == "productionYellow") {
		dst = GridConditionEnumType::productionYellow;
		return;
	}
	if (src == "productionRed") {
		dst = GridConditionEnumType::productionRed;
		return;
	}
	 return;
}
bool convertToJson(const TaskManagementJobSourceEnumType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case TaskManagementJobSourceEnumType::internalMechanism:
		 enumName = "internalMechanism";
		break;
	case TaskManagementJobSourceEnumType::userInteraction:
		 enumName = "userInteraction";
		break;
	case TaskManagementJobSourceEnumType::externalConfiguration:
		 enumName = "externalConfiguration";
		break;
	} 
	dst.set(enumName);
	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobSourceEnumType &dst) {
	if (src == "internalMechanism") {
		dst = TaskManagementJobSourceEnumType::internalMechanism;
		return;
	}
	if (src == "userInteraction") {
		dst = TaskManagementJobSourceEnumType::userInteraction;
		return;
	}
	if (src == "externalConfiguration") {
		dst = TaskManagementJobSourceEnumType::externalConfiguration;
		return;
	}
	 return;
}
bool convertToJson(const MessagingTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.messagingtypeenumtype) {
		obj["MessagingTypeEnumType"] = *src.messagingtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, MessagingTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("MessagingTypeEnumType")) {
		dst.messagingtypeenumtype = obj["MessagingTypeEnumType"].as<decltype(dst.messagingtypeenumtype)::value_type>();
	} else {
		dst.messagingtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const AbsoluteOrRelativeTimeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.duration) {
		obj["duration"] = *src.duration;
	}
	if (src.datetime) {
		obj["dateTime"] = *src.datetime;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, AbsoluteOrRelativeTimeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("duration")) {
		dst.duration = obj["duration"].as<decltype(dst.duration)::value_type>();
	} else {
		dst.duration = std::nullopt;
	}
	if (obj.containsKey("dateTime")) {
		dst.datetime = obj["dateTime"].as<decltype(dst.datetime)::value_type>();
	} else {
		dst.datetime = std::nullopt;
	}
};
bool convertToJson(const RecurringIntervalType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.recurringintervalenumtype) {
		obj["RecurringIntervalEnumType"] = *src.recurringintervalenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, RecurringIntervalType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("RecurringIntervalEnumType")) {
		dst.recurringintervalenumtype = obj["RecurringIntervalEnumType"].as<decltype(dst.recurringintervalenumtype)::value_type>();
	} else {
		dst.recurringintervalenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const OccurrenceType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.occurrenceenumtype) {
		obj["OccurrenceEnumType"] = *src.occurrenceenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, OccurrenceType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("OccurrenceEnumType")) {
		dst.occurrenceenumtype = obj["OccurrenceEnumType"].as<decltype(dst.occurrenceenumtype)::value_type>();
	} else {
		dst.occurrenceenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const CommodityTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.commoditytypeenumtype) {
		obj["CommodityTypeEnumType"] = *src.commoditytypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, CommodityTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("CommodityTypeEnumType")) {
		dst.commoditytypeenumtype = obj["CommodityTypeEnumType"].as<decltype(dst.commoditytypeenumtype)::value_type>();
	} else {
		dst.commoditytypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const EnergyDirectionType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.energydirectionenumtype) {
		obj["EnergyDirectionEnumType"] = *src.energydirectionenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, EnergyDirectionType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("EnergyDirectionEnumType")) {
		dst.energydirectionenumtype = obj["EnergyDirectionEnumType"].as<decltype(dst.energydirectionenumtype)::value_type>();
	} else {
		dst.energydirectionenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const EnergyModeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.energymodeenumtype) {
		obj["EnergyModeEnumType"] = *src.energymodeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, EnergyModeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("EnergyModeEnumType")) {
		dst.energymodeenumtype = obj["EnergyModeEnumType"].as<decltype(dst.energymodeenumtype)::value_type>();
	} else {
		dst.energymodeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const UnitOfMeasurementType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.unitofmeasurementenumtype) {
		obj["UnitOfMeasurementEnumType"] = *src.unitofmeasurementenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, UnitOfMeasurementType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("UnitOfMeasurementEnumType")) {
		dst.unitofmeasurementenumtype = obj["UnitOfMeasurementEnumType"].as<decltype(dst.unitofmeasurementenumtype)::value_type>();
	} else {
		dst.unitofmeasurementenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const CurrencyType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.currencyenumtype) {
		obj["CurrencyEnumType"] = *src.currencyenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, CurrencyType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("CurrencyEnumType")) {
		dst.currencyenumtype = obj["CurrencyEnumType"].as<decltype(dst.currencyenumtype)::value_type>();
	} else {
		dst.currencyenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ScopeTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.scopetypeenumtype) {
		obj["ScopeTypeEnumType"] = *src.scopetypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ScopeTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ScopeTypeEnumType")) {
		dst.scopetypeenumtype = obj["ScopeTypeEnumType"].as<decltype(dst.scopetypeenumtype)::value_type>();
	} else {
		dst.scopetypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const DeviceTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.devicetypeenumtype) {
		obj["DeviceTypeEnumType"] = *src.devicetypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, DeviceTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("DeviceTypeEnumType")) {
		dst.devicetypeenumtype = obj["DeviceTypeEnumType"].as<decltype(dst.devicetypeenumtype)::value_type>();
	} else {
		dst.devicetypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const EntityTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.entitytypeenumtype) {
		obj["EntityTypeEnumType"] = *src.entitytypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, EntityTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("EntityTypeEnumType")) {
		dst.entitytypeenumtype = obj["EntityTypeEnumType"].as<decltype(dst.entitytypeenumtype)::value_type>();
	} else {
		dst.entitytypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const FeatureTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.featuretypeenumtype) {
		obj["FeatureTypeEnumType"] = *src.featuretypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, FeatureTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("FeatureTypeEnumType")) {
		dst.featuretypeenumtype = obj["FeatureTypeEnumType"].as<decltype(dst.featuretypeenumtype)::value_type>();
	} else {
		dst.featuretypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const FeatureSpecificUsageType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.featurespecificusageenumtype) {
		obj["FeatureSpecificUsageEnumType"] = *src.featurespecificusageenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, FeatureSpecificUsageType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("FeatureSpecificUsageEnumType")) {
		dst.featurespecificusageenumtype = obj["FeatureSpecificUsageEnumType"].as<decltype(dst.featurespecificusageenumtype)::value_type>();
	} else {
		dst.featurespecificusageenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const FeatureSpecificUsageEnumType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.featuredirectcontrolspecificusageenumtype) {
		obj["FeatureDirectControlSpecificUsageEnumType"] = *src.featuredirectcontrolspecificusageenumtype;
	}
	if (src.featurehvacspecificusageenumtype) {
		obj["FeatureHvacSpecificUsageEnumType"] = *src.featurehvacspecificusageenumtype;
	}
	if (src.featuremeasurementspecificusageenumtype) {
		obj["FeatureMeasurementSpecificUsageEnumType"] = *src.featuremeasurementspecificusageenumtype;
	}
	if (src.featuresetpointspecificusageenumtype) {
		obj["FeatureSetpointSpecificUsageEnumType"] = *src.featuresetpointspecificusageenumtype;
	}
	if (src.featuresmartenergymanagementpsspecificusageenumtype) {
		obj["FeatureSmartEnergyManagementPsSpecificUsageEnumType"] = *src.featuresmartenergymanagementpsspecificusageenumtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, FeatureSpecificUsageEnumType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("FeatureDirectControlSpecificUsageEnumType")) {
		dst.featuredirectcontrolspecificusageenumtype = obj["FeatureDirectControlSpecificUsageEnumType"].as<decltype(dst.featuredirectcontrolspecificusageenumtype)::value_type>();
	} else {
		dst.featuredirectcontrolspecificusageenumtype = std::nullopt;
	}
	if (obj.containsKey("FeatureHvacSpecificUsageEnumType")) {
		dst.featurehvacspecificusageenumtype = obj["FeatureHvacSpecificUsageEnumType"].as<decltype(dst.featurehvacspecificusageenumtype)::value_type>();
	} else {
		dst.featurehvacspecificusageenumtype = std::nullopt;
	}
	if (obj.containsKey("FeatureMeasurementSpecificUsageEnumType")) {
		dst.featuremeasurementspecificusageenumtype = obj["FeatureMeasurementSpecificUsageEnumType"].as<decltype(dst.featuremeasurementspecificusageenumtype)::value_type>();
	} else {
		dst.featuremeasurementspecificusageenumtype = std::nullopt;
	}
	if (obj.containsKey("FeatureSetpointSpecificUsageEnumType")) {
		dst.featuresetpointspecificusageenumtype = obj["FeatureSetpointSpecificUsageEnumType"].as<decltype(dst.featuresetpointspecificusageenumtype)::value_type>();
	} else {
		dst.featuresetpointspecificusageenumtype = std::nullopt;
	}
	if (obj.containsKey("FeatureSmartEnergyManagementPsSpecificUsageEnumType")) {
		dst.featuresmartenergymanagementpsspecificusageenumtype = obj["FeatureSmartEnergyManagementPsSpecificUsageEnumType"].as<decltype(dst.featuresmartenergymanagementpsspecificusageenumtype)::value_type>();
	} else {
		dst.featuresmartenergymanagementpsspecificusageenumtype = std::nullopt;
	}
};
bool convertToJson(const FunctionType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.functionenumtype) {
		obj["FunctionEnumType"] = *src.functionenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, FunctionType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("FunctionEnumType")) {
		dst.functionenumtype = obj["FunctionEnumType"].as<decltype(dst.functionenumtype)::value_type>();
	} else {
		dst.functionenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const MessagingDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.messagingNumber) {
		obj["messagingNumber"] = *src.messagingNumber;
	}
	if (src.type) {
		obj["type"] = *src.type;
	}
	if (src.text) {
		obj["text"] = *src.text;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MessagingDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("messagingNumber")) {
		dst.messagingNumber = obj["messagingNumber"].as<decltype(dst.messagingNumber)::value_type>();
	} else {
		dst.messagingNumber = std::nullopt;
	}
	if (obj.containsKey("type")) {
		dst.type = obj["type"].as<decltype(dst.type)::value_type>();
	} else {
		dst.type = std::nullopt;
	}
	if (obj.containsKey("text")) {
		dst.text = obj["text"].as<decltype(dst.text)::value_type>();
	} else {
		dst.text = std::nullopt;
	}

}
bool convertToJson(const MessagingDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.messagingNumber) {
		obj["messagingNumber"] = *src.messagingNumber;
	}
	if (src.type) {
		obj["type"] = *src.type;
	}
	if (src.text) {
		obj["text"] = *src.text;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MessagingDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("messagingNumber")) {
		dst.messagingNumber = obj["messagingNumber"].as<decltype(dst.messagingNumber)::value_type>();
	} else {
		dst.messagingNumber = std::nullopt;
	}
	if (obj.containsKey("type")) {
		dst.type = obj["type"].as<decltype(dst.type)::value_type>();
	} else {
		dst.type = std::nullopt;
	}
	if (obj.containsKey("text")) {
		dst.text = obj["text"].as<decltype(dst.text)::value_type>();
	} else {
		dst.text = std::nullopt;
	}

}
bool convertToJson(const MessagingListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.messagingData) {
		obj["messagingData"] = *src.messagingData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MessagingListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("messagingData")) {
		dst.messagingData = obj["messagingData"].as<decltype(dst.messagingData)::value_type>();
	} else {
		dst.messagingData = std::nullopt;
	}

}
bool convertToJson(const MessagingListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}
	if (src.messagingNumber) {
		obj["messagingNumber"] = *src.messagingNumber;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MessagingListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}
	if (obj.containsKey("messagingNumber")) {
		dst.messagingNumber = obj["messagingNumber"].as<decltype(dst.messagingNumber)::value_type>();
	} else {
		dst.messagingNumber = std::nullopt;
	}

}
bool convertToJson(const ElementTagType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElementTagType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const TimePeriodType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.startTime) {
		obj["startTime"] = *src.startTime;
	}
	if (src.endTime) {
		obj["endTime"] = *src.endTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimePeriodType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("startTime")) {
		dst.startTime = obj["startTime"].as<decltype(dst.startTime)::value_type>();
	} else {
		dst.startTime = std::nullopt;
	}
	if (obj.containsKey("endTime")) {
		dst.endTime = obj["endTime"].as<decltype(dst.endTime)::value_type>();
	} else {
		dst.endTime = std::nullopt;
	}

}
bool convertToJson(const TimePeriodElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.startTime) {
		obj["startTime"] = *src.startTime;
	}
	if (src.endTime) {
		obj["endTime"] = *src.endTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimePeriodElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("startTime")) {
		dst.startTime = obj["startTime"].as<decltype(dst.startTime)::value_type>();
	} else {
		dst.startTime = std::nullopt;
	}
	if (obj.containsKey("endTime")) {
		dst.endTime = obj["endTime"].as<decltype(dst.endTime)::value_type>();
	} else {
		dst.endTime = std::nullopt;
	}

}
bool convertToJson(const TimestampIntervalType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.startTime) {
		obj["startTime"] = *src.startTime;
	}
	if (src.endTime) {
		obj["endTime"] = *src.endTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimestampIntervalType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("startTime")) {
		dst.startTime = obj["startTime"].as<decltype(dst.startTime)::value_type>();
	} else {
		dst.startTime = std::nullopt;
	}
	if (obj.containsKey("endTime")) {
		dst.endTime = obj["endTime"].as<decltype(dst.endTime)::value_type>();
	} else {
		dst.endTime = std::nullopt;
	}

}
bool convertToJson(const DaysOfWeekType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.monday) {
		obj["monday"] = *src.monday;
	}
	if (src.tuesday) {
		obj["tuesday"] = *src.tuesday;
	}
	if (src.wednesday) {
		obj["wednesday"] = *src.wednesday;
	}
	if (src.thursday) {
		obj["thursday"] = *src.thursday;
	}
	if (src.friday) {
		obj["friday"] = *src.friday;
	}
	if (src.saturday) {
		obj["saturday"] = *src.saturday;
	}
	if (src.sunday) {
		obj["sunday"] = *src.sunday;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DaysOfWeekType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("monday")) {
		dst.monday = obj["monday"].as<decltype(dst.monday)::value_type>();
	} else {
		dst.monday = std::nullopt;
	}
	if (obj.containsKey("tuesday")) {
		dst.tuesday = obj["tuesday"].as<decltype(dst.tuesday)::value_type>();
	} else {
		dst.tuesday = std::nullopt;
	}
	if (obj.containsKey("wednesday")) {
		dst.wednesday = obj["wednesday"].as<decltype(dst.wednesday)::value_type>();
	} else {
		dst.wednesday = std::nullopt;
	}
	if (obj.containsKey("thursday")) {
		dst.thursday = obj["thursday"].as<decltype(dst.thursday)::value_type>();
	} else {
		dst.thursday = std::nullopt;
	}
	if (obj.containsKey("friday")) {
		dst.friday = obj["friday"].as<decltype(dst.friday)::value_type>();
	} else {
		dst.friday = std::nullopt;
	}
	if (obj.containsKey("saturday")) {
		dst.saturday = obj["saturday"].as<decltype(dst.saturday)::value_type>();
	} else {
		dst.saturday = std::nullopt;
	}
	if (obj.containsKey("sunday")) {
		dst.sunday = obj["sunday"].as<decltype(dst.sunday)::value_type>();
	} else {
		dst.sunday = std::nullopt;
	}

}
bool convertToJson(const AbsoluteOrRecurringTimeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.dateTime) {
		obj["dateTime"] = *src.dateTime;
	}
	if (src.month) {
		obj["month"] = *src.month;
	}
	if (src.dayOfMonth) {
		obj["dayOfMonth"] = *src.dayOfMonth;
	}
	if (src.calendarWeek) {
		obj["calendarWeek"] = *src.calendarWeek;
	}
	if (src.dayOfWeekOccurrence) {
		obj["dayOfWeekOccurrence"] = *src.dayOfWeekOccurrence;
	}
	if (src.daysOfWeek) {
		obj["daysOfWeek"] = *src.daysOfWeek;
	}
	if (src.time) {
		obj["time"] = *src.time;
	}
	if (src.relative) {
		obj["relative"] = *src.relative;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, AbsoluteOrRecurringTimeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("dateTime")) {
		dst.dateTime = obj["dateTime"].as<decltype(dst.dateTime)::value_type>();
	} else {
		dst.dateTime = std::nullopt;
	}
	if (obj.containsKey("month")) {
		dst.month = obj["month"].as<decltype(dst.month)::value_type>();
	} else {
		dst.month = std::nullopt;
	}
	if (obj.containsKey("dayOfMonth")) {
		dst.dayOfMonth = obj["dayOfMonth"].as<decltype(dst.dayOfMonth)::value_type>();
	} else {
		dst.dayOfMonth = std::nullopt;
	}
	if (obj.containsKey("calendarWeek")) {
		dst.calendarWeek = obj["calendarWeek"].as<decltype(dst.calendarWeek)::value_type>();
	} else {
		dst.calendarWeek = std::nullopt;
	}
	if (obj.containsKey("dayOfWeekOccurrence")) {
		dst.dayOfWeekOccurrence = obj["dayOfWeekOccurrence"].as<decltype(dst.dayOfWeekOccurrence)::value_type>();
	} else {
		dst.dayOfWeekOccurrence = std::nullopt;
	}
	if (obj.containsKey("daysOfWeek")) {
		dst.daysOfWeek = obj["daysOfWeek"].as<decltype(dst.daysOfWeek)::value_type>();
	} else {
		dst.daysOfWeek = std::nullopt;
	}
	if (obj.containsKey("time")) {
		dst.time = obj["time"].as<decltype(dst.time)::value_type>();
	} else {
		dst.time = std::nullopt;
	}
	if (obj.containsKey("relative")) {
		dst.relative = obj["relative"].as<decltype(dst.relative)::value_type>();
	} else {
		dst.relative = std::nullopt;
	}

}
bool convertToJson(const AbsoluteOrRecurringTimeElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.dateTime) {
		obj["dateTime"] = *src.dateTime;
	}
	if (src.month) {
		obj["month"] = *src.month;
	}
	if (src.dayOfMonth) {
		obj["dayOfMonth"] = *src.dayOfMonth;
	}
	if (src.calendarWeek) {
		obj["calendarWeek"] = *src.calendarWeek;
	}
	if (src.dayOfWeekOccurrence) {
		obj["dayOfWeekOccurrence"] = *src.dayOfWeekOccurrence;
	}
	if (src.daysOfWeek) {
		obj["daysOfWeek"] = *src.daysOfWeek;
	}
	if (src.time) {
		obj["time"] = *src.time;
	}
	if (src.relative) {
		obj["relative"] = *src.relative;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, AbsoluteOrRecurringTimeElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("dateTime")) {
		dst.dateTime = obj["dateTime"].as<decltype(dst.dateTime)::value_type>();
	} else {
		dst.dateTime = std::nullopt;
	}
	if (obj.containsKey("month")) {
		dst.month = obj["month"].as<decltype(dst.month)::value_type>();
	} else {
		dst.month = std::nullopt;
	}
	if (obj.containsKey("dayOfMonth")) {
		dst.dayOfMonth = obj["dayOfMonth"].as<decltype(dst.dayOfMonth)::value_type>();
	} else {
		dst.dayOfMonth = std::nullopt;
	}
	if (obj.containsKey("calendarWeek")) {
		dst.calendarWeek = obj["calendarWeek"].as<decltype(dst.calendarWeek)::value_type>();
	} else {
		dst.calendarWeek = std::nullopt;
	}
	if (obj.containsKey("dayOfWeekOccurrence")) {
		dst.dayOfWeekOccurrence = obj["dayOfWeekOccurrence"].as<decltype(dst.dayOfWeekOccurrence)::value_type>();
	} else {
		dst.dayOfWeekOccurrence = std::nullopt;
	}
	if (obj.containsKey("daysOfWeek")) {
		dst.daysOfWeek = obj["daysOfWeek"].as<decltype(dst.daysOfWeek)::value_type>();
	} else {
		dst.daysOfWeek = std::nullopt;
	}
	if (obj.containsKey("time")) {
		dst.time = obj["time"].as<decltype(dst.time)::value_type>();
	} else {
		dst.time = std::nullopt;
	}
	if (obj.containsKey("relative")) {
		dst.relative = obj["relative"].as<decltype(dst.relative)::value_type>();
	} else {
		dst.relative = std::nullopt;
	}

}
bool convertToJson(const RecurrenceInformationType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.recurringInterval) {
		obj["recurringInterval"] = *src.recurringInterval;
	}
	if (src.recurringIntervalStep) {
		obj["recurringIntervalStep"] = *src.recurringIntervalStep;
	}
	if (src.firstExecution) {
		obj["firstExecution"] = *src.firstExecution;
	}
	if (src.executionCount) {
		obj["executionCount"] = *src.executionCount;
	}
	if (src.lastExecution) {
		obj["lastExecution"] = *src.lastExecution;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, RecurrenceInformationType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("recurringInterval")) {
		dst.recurringInterval = obj["recurringInterval"].as<decltype(dst.recurringInterval)::value_type>();
	} else {
		dst.recurringInterval = std::nullopt;
	}
	if (obj.containsKey("recurringIntervalStep")) {
		dst.recurringIntervalStep = obj["recurringIntervalStep"].as<decltype(dst.recurringIntervalStep)::value_type>();
	} else {
		dst.recurringIntervalStep = std::nullopt;
	}
	if (obj.containsKey("firstExecution")) {
		dst.firstExecution = obj["firstExecution"].as<decltype(dst.firstExecution)::value_type>();
	} else {
		dst.firstExecution = std::nullopt;
	}
	if (obj.containsKey("executionCount")) {
		dst.executionCount = obj["executionCount"].as<decltype(dst.executionCount)::value_type>();
	} else {
		dst.executionCount = std::nullopt;
	}
	if (obj.containsKey("lastExecution")) {
		dst.lastExecution = obj["lastExecution"].as<decltype(dst.lastExecution)::value_type>();
	} else {
		dst.lastExecution = std::nullopt;
	}

}
bool convertToJson(const RecurrenceInformationElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.recurringInterval) {
		obj["recurringInterval"] = *src.recurringInterval;
	}
	if (src.recurringIntervalStep) {
		obj["recurringIntervalStep"] = *src.recurringIntervalStep;
	}
	if (src.firstExecution) {
		obj["firstExecution"] = *src.firstExecution;
	}
	if (src.executionCount) {
		obj["executionCount"] = *src.executionCount;
	}
	if (src.lastExecution) {
		obj["lastExecution"] = *src.lastExecution;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, RecurrenceInformationElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("recurringInterval")) {
		dst.recurringInterval = obj["recurringInterval"].as<decltype(dst.recurringInterval)::value_type>();
	} else {
		dst.recurringInterval = std::nullopt;
	}
	if (obj.containsKey("recurringIntervalStep")) {
		dst.recurringIntervalStep = obj["recurringIntervalStep"].as<decltype(dst.recurringIntervalStep)::value_type>();
	} else {
		dst.recurringIntervalStep = std::nullopt;
	}
	if (obj.containsKey("firstExecution")) {
		dst.firstExecution = obj["firstExecution"].as<decltype(dst.firstExecution)::value_type>();
	} else {
		dst.firstExecution = std::nullopt;
	}
	if (obj.containsKey("executionCount")) {
		dst.executionCount = obj["executionCount"].as<decltype(dst.executionCount)::value_type>();
	} else {
		dst.executionCount = std::nullopt;
	}
	if (obj.containsKey("lastExecution")) {
		dst.lastExecution = obj["lastExecution"].as<decltype(dst.lastExecution)::value_type>();
	} else {
		dst.lastExecution = std::nullopt;
	}

}
bool convertToJson(const ScaledNumberRangeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.min) {
		obj["min"] = *src.min;
	}
	if (src.max) {
		obj["max"] = *src.max;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ScaledNumberRangeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("min")) {
		dst.min = obj["min"].as<decltype(dst.min)::value_type>();
	} else {
		dst.min = std::nullopt;
	}
	if (obj.containsKey("max")) {
		dst.max = obj["max"].as<decltype(dst.max)::value_type>();
	} else {
		dst.max = std::nullopt;
	}

}
bool convertToJson(const ScaledNumberRangeElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.min) {
		obj["min"] = *src.min;
	}
	if (src.max) {
		obj["max"] = *src.max;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ScaledNumberRangeElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("min")) {
		dst.min = obj["min"].as<decltype(dst.min)::value_type>();
	} else {
		dst.min = std::nullopt;
	}
	if (obj.containsKey("max")) {
		dst.max = obj["max"].as<decltype(dst.max)::value_type>();
	} else {
		dst.max = std::nullopt;
	}

}
bool convertToJson(const ScaledNumberSetType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.range) {
		obj["range"] = *src.range;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ScaledNumberSetType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("range")) {
		dst.range = obj["range"].as<decltype(dst.range)::value_type>();
	} else {
		dst.range = std::nullopt;
	}

}
bool convertToJson(const ScaledNumberSetElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.range) {
		obj["range"] = *src.range;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ScaledNumberSetElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("range")) {
		dst.range = obj["range"].as<decltype(dst.range)::value_type>();
	} else {
		dst.range = std::nullopt;
	}

}
bool convertToJson(const ScaledNumberType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.number) {
		obj["number"] = *src.number;
	}
	if (src.scale) {
		obj["scale"] = *src.scale;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ScaledNumberType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("number")) {
		dst.number = obj["number"].as<decltype(dst.number)::value_type>();
	} else {
		dst.number = std::nullopt;
	}
	if (obj.containsKey("scale")) {
		dst.scale = obj["scale"].as<decltype(dst.scale)::value_type>();
	} else {
		dst.scale = std::nullopt;
	}

}
bool convertToJson(const ScaledNumberElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.number) {
		obj["number"] = *src.number;
	}
	if (src.scale) {
		obj["scale"] = *src.scale;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ScaledNumberElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("number")) {
		dst.number = obj["number"].as<decltype(dst.number)::value_type>();
	} else {
		dst.number = std::nullopt;
	}
	if (obj.containsKey("scale")) {
		dst.scale = obj["scale"].as<decltype(dst.scale)::value_type>();
	} else {
		dst.scale = std::nullopt;
	}

}
bool convertToJson(const DeviceAddressType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.device) {
		obj["device"] = *src.device;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceAddressType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("device")) {
		dst.device = obj["device"].as<decltype(dst.device)::value_type>();
	} else {
		dst.device = std::nullopt;
	}

}
bool convertToJson(const DeviceAddressElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.device) {
		obj["device"] = *src.device;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceAddressElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("device")) {
		dst.device = obj["device"].as<decltype(dst.device)::value_type>();
	} else {
		dst.device = std::nullopt;
	}

}
bool convertToJson(const EntityAddressType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.device) {
		obj["device"] = *src.device;
	}
	if (src.entity) {
		obj["entity"] = *src.entity;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, EntityAddressType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("device")) {
		dst.device = obj["device"].as<decltype(dst.device)::value_type>();
	} else {
		dst.device = std::nullopt;
	}
	if (obj.containsKey("entity")) {
		dst.entity = obj["entity"].as<decltype(dst.entity)::value_type>();
	} else {
		dst.entity = std::nullopt;
	}

}
bool convertToJson(const EntityAddressElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.device) {
		obj["device"] = *src.device;
	}
	if (src.entity) {
		obj["entity"] = *src.entity;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, EntityAddressElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("device")) {
		dst.device = obj["device"].as<decltype(dst.device)::value_type>();
	} else {
		dst.device = std::nullopt;
	}
	if (obj.containsKey("entity")) {
		dst.entity = obj["entity"].as<decltype(dst.entity)::value_type>();
	} else {
		dst.entity = std::nullopt;
	}

}
bool convertToJson(const FeatureAddressType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.device) {
		obj["device"] = *src.device;
	}
	if (src.entity) {
		obj["entity"] = *src.entity;
	}
	if (src.feature) {
		obj["feature"] = *src.feature;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, FeatureAddressType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("device")) {
		dst.device = obj["device"].as<decltype(dst.device)::value_type>();
	} else {
		dst.device = std::nullopt;
	}
	if (obj.containsKey("entity")) {
		dst.entity = obj["entity"].as<decltype(dst.entity)::value_type>();
	} else {
		dst.entity = std::nullopt;
	}
	if (obj.containsKey("feature")) {
		dst.feature = obj["feature"].as<decltype(dst.feature)::value_type>();
	} else {
		dst.feature = std::nullopt;
	}

}
bool convertToJson(const FeatureAddressElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.device) {
		obj["device"] = *src.device;
	}
	if (src.entity) {
		obj["entity"] = *src.entity;
	}
	if (src.feature) {
		obj["feature"] = *src.feature;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, FeatureAddressElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("device")) {
		dst.device = obj["device"].as<decltype(dst.device)::value_type>();
	} else {
		dst.device = std::nullopt;
	}
	if (obj.containsKey("entity")) {
		dst.entity = obj["entity"].as<decltype(dst.entity)::value_type>();
	} else {
		dst.entity = std::nullopt;
	}
	if (obj.containsKey("feature")) {
		dst.feature = obj["feature"].as<decltype(dst.feature)::value_type>();
	} else {
		dst.feature = std::nullopt;
	}

}
bool convertToJson(const PossibleOperationsClassifierType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.partial) {
		obj["partial"] = *src.partial;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PossibleOperationsClassifierType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("partial")) {
		dst.partial = obj["partial"].as<decltype(dst.partial)::value_type>();
	} else {
		dst.partial = std::nullopt;
	}

}
bool convertToJson(const PossibleOperationsReadType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.partial) {
		obj["partial"] = *src.partial;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PossibleOperationsReadType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("partial")) {
		dst.partial = obj["partial"].as<decltype(dst.partial)::value_type>();
	} else {
		dst.partial = std::nullopt;
	}

}
bool convertToJson(const PossibleOperationsWriteType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.partial) {
		obj["partial"] = *src.partial;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PossibleOperationsWriteType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("partial")) {
		dst.partial = obj["partial"].as<decltype(dst.partial)::value_type>();
	} else {
		dst.partial = std::nullopt;
	}

}
bool convertToJson(const PossibleOperationsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.read) {
		obj["read"] = *src.read;
	}
	if (src.write) {
		obj["write"] = *src.write;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PossibleOperationsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("read")) {
		dst.read = obj["read"].as<decltype(dst.read)::value_type>();
	} else {
		dst.read = std::nullopt;
	}
	if (obj.containsKey("write")) {
		dst.write = obj["write"].as<decltype(dst.write)::value_type>();
	} else {
		dst.write = std::nullopt;
	}

}
bool convertToJson(const PossibleOperationsElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.read) {
		obj["read"] = *src.read;
	}
	if (src.write) {
		obj["write"] = *src.write;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PossibleOperationsElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("read")) {
		dst.read = obj["read"].as<decltype(dst.read)::value_type>();
	} else {
		dst.read = std::nullopt;
	}
	if (obj.containsKey("write")) {
		dst.write = obj["write"].as<decltype(dst.write)::value_type>();
	} else {
		dst.write = std::nullopt;
	}

}
bool convertToJson(const FunctionPropertyType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.function) {
		obj["function"] = *src.function;
	}
	if (src.possibleOperations) {
		obj["possibleOperations"] = *src.possibleOperations;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, FunctionPropertyType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("function")) {
		dst.function = obj["function"].as<decltype(dst.function)::value_type>();
	} else {
		dst.function = std::nullopt;
	}
	if (obj.containsKey("possibleOperations")) {
		dst.possibleOperations = obj["possibleOperations"].as<decltype(dst.possibleOperations)::value_type>();
	} else {
		dst.possibleOperations = std::nullopt;
	}

}
bool convertToJson(const FunctionPropertyElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.function) {
		obj["function"] = *src.function;
	}
	if (src.possibleOperations) {
		obj["possibleOperations"] = *src.possibleOperations;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, FunctionPropertyElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("function")) {
		dst.function = obj["function"].as<decltype(dst.function)::value_type>();
	} else {
		dst.function = std::nullopt;
	}
	if (obj.containsKey("possibleOperations")) {
		dst.possibleOperations = obj["possibleOperations"].as<decltype(dst.possibleOperations)::value_type>();
	} else {
		dst.possibleOperations = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeseriestypeenumtype) {
		obj["TimeSeriesTypeEnumType"] = *src.timeseriestypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, TimeSeriesTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("TimeSeriesTypeEnumType")) {
		dst.timeseriestypeenumtype = obj["TimeSeriesTypeEnumType"].as<decltype(dst.timeseriestypeenumtype)::value_type>();
	} else {
		dst.timeseriestypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const MeasurementTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementtypeenumtype) {
		obj["MeasurementTypeEnumType"] = *src.measurementtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, MeasurementTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("MeasurementTypeEnumType")) {
		dst.measurementtypeenumtype = obj["MeasurementTypeEnumType"].as<decltype(dst.measurementtypeenumtype)::value_type>();
	} else {
		dst.measurementtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const MeasurementValueTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementvaluetypeenumtype) {
		obj["MeasurementValueTypeEnumType"] = *src.measurementvaluetypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, MeasurementValueTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("MeasurementValueTypeEnumType")) {
		dst.measurementvaluetypeenumtype = obj["MeasurementValueTypeEnumType"].as<decltype(dst.measurementvaluetypeenumtype)::value_type>();
	} else {
		dst.measurementvaluetypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const MeasurementValueSourceType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementvaluesourceenumtype) {
		obj["MeasurementValueSourceEnumType"] = *src.measurementvaluesourceenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, MeasurementValueSourceType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("MeasurementValueSourceEnumType")) {
		dst.measurementvaluesourceenumtype = obj["MeasurementValueSourceEnumType"].as<decltype(dst.measurementvaluesourceenumtype)::value_type>();
	} else {
		dst.measurementvaluesourceenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const MeasurementValueTendencyType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementvaluetendencyenumtype) {
		obj["MeasurementValueTendencyEnumType"] = *src.measurementvaluetendencyenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, MeasurementValueTendencyType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("MeasurementValueTendencyEnumType")) {
		dst.measurementvaluetendencyenumtype = obj["MeasurementValueTendencyEnumType"].as<decltype(dst.measurementvaluetendencyenumtype)::value_type>();
	} else {
		dst.measurementvaluetendencyenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const MeasurementValueStateType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementvaluestateenumtype) {
		obj["MeasurementValueStateEnumType"] = *src.measurementvaluestateenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, MeasurementValueStateType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("MeasurementValueStateEnumType")) {
		dst.measurementvaluestateenumtype = obj["MeasurementValueStateEnumType"].as<decltype(dst.measurementvaluestateenumtype)::value_type>();
	} else {
		dst.measurementvaluestateenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ThresholdTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdtypeenumtype) {
		obj["ThresholdTypeEnumType"] = *src.thresholdtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ThresholdTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ThresholdTypeEnumType")) {
		dst.thresholdtypeenumtype = obj["ThresholdTypeEnumType"].as<decltype(dst.thresholdtypeenumtype)::value_type>();
	} else {
		dst.thresholdtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const TimeSeriesSlotType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesSlotId) {
		obj["timeSeriesSlotId"] = *src.timeSeriesSlotId;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.duration) {
		obj["duration"] = *src.duration;
	}
	if (src.recurrenceInformation) {
		obj["recurrenceInformation"] = *src.recurrenceInformation;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.minValue) {
		obj["minValue"] = *src.minValue;
	}
	if (src.maxValue) {
		obj["maxValue"] = *src.maxValue;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesSlotType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesSlotId")) {
		dst.timeSeriesSlotId = obj["timeSeriesSlotId"].as<decltype(dst.timeSeriesSlotId)::value_type>();
	} else {
		dst.timeSeriesSlotId = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("duration")) {
		dst.duration = obj["duration"].as<decltype(dst.duration)::value_type>();
	} else {
		dst.duration = std::nullopt;
	}
	if (obj.containsKey("recurrenceInformation")) {
		dst.recurrenceInformation = obj["recurrenceInformation"].as<decltype(dst.recurrenceInformation)::value_type>();
	} else {
		dst.recurrenceInformation = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("minValue")) {
		dst.minValue = obj["minValue"].as<decltype(dst.minValue)::value_type>();
	} else {
		dst.minValue = std::nullopt;
	}
	if (obj.containsKey("maxValue")) {
		dst.maxValue = obj["maxValue"].as<decltype(dst.maxValue)::value_type>();
	} else {
		dst.maxValue = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesSlotElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesSlotId) {
		obj["timeSeriesSlotId"] = *src.timeSeriesSlotId;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.duration) {
		obj["duration"] = *src.duration;
	}
	if (src.recurrenceInformation) {
		obj["recurrenceInformation"] = *src.recurrenceInformation;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.minValue) {
		obj["minValue"] = *src.minValue;
	}
	if (src.maxValue) {
		obj["maxValue"] = *src.maxValue;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesSlotElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesSlotId")) {
		dst.timeSeriesSlotId = obj["timeSeriesSlotId"].as<decltype(dst.timeSeriesSlotId)::value_type>();
	} else {
		dst.timeSeriesSlotId = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("duration")) {
		dst.duration = obj["duration"].as<decltype(dst.duration)::value_type>();
	} else {
		dst.duration = std::nullopt;
	}
	if (obj.containsKey("recurrenceInformation")) {
		dst.recurrenceInformation = obj["recurrenceInformation"].as<decltype(dst.recurrenceInformation)::value_type>();
	} else {
		dst.recurrenceInformation = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("minValue")) {
		dst.minValue = obj["minValue"].as<decltype(dst.minValue)::value_type>();
	} else {
		dst.minValue = std::nullopt;
	}
	if (obj.containsKey("maxValue")) {
		dst.maxValue = obj["maxValue"].as<decltype(dst.maxValue)::value_type>();
	} else {
		dst.maxValue = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.timeSeriesSlot) {
		obj["timeSeriesSlot"] = *src.timeSeriesSlot;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("timeSeriesSlot")) {
		dst.timeSeriesSlot = obj["timeSeriesSlot"].as<decltype(dst.timeSeriesSlot)::value_type>();
	} else {
		dst.timeSeriesSlot = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.timeSeriesSlot) {
		obj["timeSeriesSlot"] = *src.timeSeriesSlot;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("timeSeriesSlot")) {
		dst.timeSeriesSlot = obj["timeSeriesSlot"].as<decltype(dst.timeSeriesSlot)::value_type>();
	} else {
		dst.timeSeriesSlot = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesData) {
		obj["timeSeriesData"] = *src.timeSeriesData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesData")) {
		dst.timeSeriesData = obj["timeSeriesData"].as<decltype(dst.timeSeriesData)::value_type>();
	} else {
		dst.timeSeriesData = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}
	if (src.timeSeriesSlotId) {
		obj["timeSeriesSlotId"] = *src.timeSeriesSlotId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}
	if (obj.containsKey("timeSeriesSlotId")) {
		dst.timeSeriesSlotId = obj["timeSeriesSlotId"].as<decltype(dst.timeSeriesSlotId)::value_type>();
	} else {
		dst.timeSeriesSlotId = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}
	if (src.timeSeriesType) {
		obj["timeSeriesType"] = *src.timeSeriesType;
	}
	if (src.timeSeriesWriteable) {
		obj["timeSeriesWriteable"] = *src.timeSeriesWriteable;
	}
	if (src.updateRequired) {
		obj["updateRequired"] = *src.updateRequired;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}
	if (obj.containsKey("timeSeriesType")) {
		dst.timeSeriesType = obj["timeSeriesType"].as<decltype(dst.timeSeriesType)::value_type>();
	} else {
		dst.timeSeriesType = std::nullopt;
	}
	if (obj.containsKey("timeSeriesWriteable")) {
		dst.timeSeriesWriteable = obj["timeSeriesWriteable"].as<decltype(dst.timeSeriesWriteable)::value_type>();
	} else {
		dst.timeSeriesWriteable = std::nullopt;
	}
	if (obj.containsKey("updateRequired")) {
		dst.updateRequired = obj["updateRequired"].as<decltype(dst.updateRequired)::value_type>();
	} else {
		dst.updateRequired = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}
	if (src.timeSeriesType) {
		obj["timeSeriesType"] = *src.timeSeriesType;
	}
	if (src.timeSeriesWriteable) {
		obj["timeSeriesWriteable"] = *src.timeSeriesWriteable;
	}
	if (src.updateRequired) {
		obj["updateRequired"] = *src.updateRequired;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}
	if (obj.containsKey("timeSeriesType")) {
		dst.timeSeriesType = obj["timeSeriesType"].as<decltype(dst.timeSeriesType)::value_type>();
	} else {
		dst.timeSeriesType = std::nullopt;
	}
	if (obj.containsKey("timeSeriesWriteable")) {
		dst.timeSeriesWriteable = obj["timeSeriesWriteable"].as<decltype(dst.timeSeriesWriteable)::value_type>();
	} else {
		dst.timeSeriesWriteable = std::nullopt;
	}
	if (obj.containsKey("updateRequired")) {
		dst.updateRequired = obj["updateRequired"].as<decltype(dst.updateRequired)::value_type>();
	} else {
		dst.updateRequired = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesDescriptionData) {
		obj["timeSeriesDescriptionData"] = *src.timeSeriesDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesDescriptionData")) {
		dst.timeSeriesDescriptionData = obj["timeSeriesDescriptionData"].as<decltype(dst.timeSeriesDescriptionData)::value_type>();
	} else {
		dst.timeSeriesDescriptionData = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}
	if (src.timeSeriesType) {
		obj["timeSeriesType"] = *src.timeSeriesType;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}
	if (obj.containsKey("timeSeriesType")) {
		dst.timeSeriesType = obj["timeSeriesType"].as<decltype(dst.timeSeriesType)::value_type>();
	} else {
		dst.timeSeriesType = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}
	if (src.slotCountMin) {
		obj["slotCountMin"] = *src.slotCountMin;
	}
	if (src.slotCountMax) {
		obj["slotCountMax"] = *src.slotCountMax;
	}
	if (src.slotDurationMin) {
		obj["slotDurationMin"] = *src.slotDurationMin;
	}
	if (src.slotDurationMax) {
		obj["slotDurationMax"] = *src.slotDurationMax;
	}
	if (src.slotDurationStepSize) {
		obj["slotDurationStepSize"] = *src.slotDurationStepSize;
	}
	if (src.earliestTimeSeriesStartTime) {
		obj["earliestTimeSeriesStartTime"] = *src.earliestTimeSeriesStartTime;
	}
	if (src.latestTimeSeriesEndTime) {
		obj["latestTimeSeriesEndTime"] = *src.latestTimeSeriesEndTime;
	}
	if (src.slotValueMin) {
		obj["slotValueMin"] = *src.slotValueMin;
	}
	if (src.slotValueMax) {
		obj["slotValueMax"] = *src.slotValueMax;
	}
	if (src.slotValueStepSize) {
		obj["slotValueStepSize"] = *src.slotValueStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}
	if (obj.containsKey("slotCountMin")) {
		dst.slotCountMin = obj["slotCountMin"].as<decltype(dst.slotCountMin)::value_type>();
	} else {
		dst.slotCountMin = std::nullopt;
	}
	if (obj.containsKey("slotCountMax")) {
		dst.slotCountMax = obj["slotCountMax"].as<decltype(dst.slotCountMax)::value_type>();
	} else {
		dst.slotCountMax = std::nullopt;
	}
	if (obj.containsKey("slotDurationMin")) {
		dst.slotDurationMin = obj["slotDurationMin"].as<decltype(dst.slotDurationMin)::value_type>();
	} else {
		dst.slotDurationMin = std::nullopt;
	}
	if (obj.containsKey("slotDurationMax")) {
		dst.slotDurationMax = obj["slotDurationMax"].as<decltype(dst.slotDurationMax)::value_type>();
	} else {
		dst.slotDurationMax = std::nullopt;
	}
	if (obj.containsKey("slotDurationStepSize")) {
		dst.slotDurationStepSize = obj["slotDurationStepSize"].as<decltype(dst.slotDurationStepSize)::value_type>();
	} else {
		dst.slotDurationStepSize = std::nullopt;
	}
	if (obj.containsKey("earliestTimeSeriesStartTime")) {
		dst.earliestTimeSeriesStartTime = obj["earliestTimeSeriesStartTime"].as<decltype(dst.earliestTimeSeriesStartTime)::value_type>();
	} else {
		dst.earliestTimeSeriesStartTime = std::nullopt;
	}
	if (obj.containsKey("latestTimeSeriesEndTime")) {
		dst.latestTimeSeriesEndTime = obj["latestTimeSeriesEndTime"].as<decltype(dst.latestTimeSeriesEndTime)::value_type>();
	} else {
		dst.latestTimeSeriesEndTime = std::nullopt;
	}
	if (obj.containsKey("slotValueMin")) {
		dst.slotValueMin = obj["slotValueMin"].as<decltype(dst.slotValueMin)::value_type>();
	} else {
		dst.slotValueMin = std::nullopt;
	}
	if (obj.containsKey("slotValueMax")) {
		dst.slotValueMax = obj["slotValueMax"].as<decltype(dst.slotValueMax)::value_type>();
	} else {
		dst.slotValueMax = std::nullopt;
	}
	if (obj.containsKey("slotValueStepSize")) {
		dst.slotValueStepSize = obj["slotValueStepSize"].as<decltype(dst.slotValueStepSize)::value_type>();
	} else {
		dst.slotValueStepSize = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}
	if (src.slotCountMin) {
		obj["slotCountMin"] = *src.slotCountMin;
	}
	if (src.slotCountMax) {
		obj["slotCountMax"] = *src.slotCountMax;
	}
	if (src.slotDurationMin) {
		obj["slotDurationMin"] = *src.slotDurationMin;
	}
	if (src.slotDurationMax) {
		obj["slotDurationMax"] = *src.slotDurationMax;
	}
	if (src.slotDurationStepSize) {
		obj["slotDurationStepSize"] = *src.slotDurationStepSize;
	}
	if (src.earliestTimeSeriesStartTime) {
		obj["earliestTimeSeriesStartTime"] = *src.earliestTimeSeriesStartTime;
	}
	if (src.latestTimeSeriesEndTime) {
		obj["latestTimeSeriesEndTime"] = *src.latestTimeSeriesEndTime;
	}
	if (src.slotValueMin) {
		obj["slotValueMin"] = *src.slotValueMin;
	}
	if (src.slotValueMax) {
		obj["slotValueMax"] = *src.slotValueMax;
	}
	if (src.slotValueStepSize) {
		obj["slotValueStepSize"] = *src.slotValueStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}
	if (obj.containsKey("slotCountMin")) {
		dst.slotCountMin = obj["slotCountMin"].as<decltype(dst.slotCountMin)::value_type>();
	} else {
		dst.slotCountMin = std::nullopt;
	}
	if (obj.containsKey("slotCountMax")) {
		dst.slotCountMax = obj["slotCountMax"].as<decltype(dst.slotCountMax)::value_type>();
	} else {
		dst.slotCountMax = std::nullopt;
	}
	if (obj.containsKey("slotDurationMin")) {
		dst.slotDurationMin = obj["slotDurationMin"].as<decltype(dst.slotDurationMin)::value_type>();
	} else {
		dst.slotDurationMin = std::nullopt;
	}
	if (obj.containsKey("slotDurationMax")) {
		dst.slotDurationMax = obj["slotDurationMax"].as<decltype(dst.slotDurationMax)::value_type>();
	} else {
		dst.slotDurationMax = std::nullopt;
	}
	if (obj.containsKey("slotDurationStepSize")) {
		dst.slotDurationStepSize = obj["slotDurationStepSize"].as<decltype(dst.slotDurationStepSize)::value_type>();
	} else {
		dst.slotDurationStepSize = std::nullopt;
	}
	if (obj.containsKey("earliestTimeSeriesStartTime")) {
		dst.earliestTimeSeriesStartTime = obj["earliestTimeSeriesStartTime"].as<decltype(dst.earliestTimeSeriesStartTime)::value_type>();
	} else {
		dst.earliestTimeSeriesStartTime = std::nullopt;
	}
	if (obj.containsKey("latestTimeSeriesEndTime")) {
		dst.latestTimeSeriesEndTime = obj["latestTimeSeriesEndTime"].as<decltype(dst.latestTimeSeriesEndTime)::value_type>();
	} else {
		dst.latestTimeSeriesEndTime = std::nullopt;
	}
	if (obj.containsKey("slotValueMin")) {
		dst.slotValueMin = obj["slotValueMin"].as<decltype(dst.slotValueMin)::value_type>();
	} else {
		dst.slotValueMin = std::nullopt;
	}
	if (obj.containsKey("slotValueMax")) {
		dst.slotValueMax = obj["slotValueMax"].as<decltype(dst.slotValueMax)::value_type>();
	} else {
		dst.slotValueMax = std::nullopt;
	}
	if (obj.containsKey("slotValueStepSize")) {
		dst.slotValueStepSize = obj["slotValueStepSize"].as<decltype(dst.slotValueStepSize)::value_type>();
	} else {
		dst.slotValueStepSize = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesConstraintsData) {
		obj["timeSeriesConstraintsData"] = *src.timeSeriesConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesConstraintsData")) {
		dst.timeSeriesConstraintsData = obj["timeSeriesConstraintsData"].as<decltype(dst.timeSeriesConstraintsData)::value_type>();
	} else {
		dst.timeSeriesConstraintsData = std::nullopt;
	}

}
bool convertToJson(const TimeSeriesConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeSeriesId) {
		obj["timeSeriesId"] = *src.timeSeriesId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeSeriesConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeSeriesId")) {
		dst.timeSeriesId = obj["timeSeriesId"].as<decltype(dst.timeSeriesId)::value_type>();
	} else {
		dst.timeSeriesId = std::nullopt;
	}

}
bool convertToJson(const MeasurementDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.evaluationPeriod) {
		obj["evaluationPeriod"] = *src.evaluationPeriod;
	}
	if (src.valueSource) {
		obj["valueSource"] = *src.valueSource;
	}
	if (src.valueTendency) {
		obj["valueTendency"] = *src.valueTendency;
	}
	if (src.valueState) {
		obj["valueState"] = *src.valueState;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("evaluationPeriod")) {
		dst.evaluationPeriod = obj["evaluationPeriod"].as<decltype(dst.evaluationPeriod)::value_type>();
	} else {
		dst.evaluationPeriod = std::nullopt;
	}
	if (obj.containsKey("valueSource")) {
		dst.valueSource = obj["valueSource"].as<decltype(dst.valueSource)::value_type>();
	} else {
		dst.valueSource = std::nullopt;
	}
	if (obj.containsKey("valueTendency")) {
		dst.valueTendency = obj["valueTendency"].as<decltype(dst.valueTendency)::value_type>();
	} else {
		dst.valueTendency = std::nullopt;
	}
	if (obj.containsKey("valueState")) {
		dst.valueState = obj["valueState"].as<decltype(dst.valueState)::value_type>();
	} else {
		dst.valueState = std::nullopt;
	}

}
bool convertToJson(const MeasurementDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.evaluationPeriod) {
		obj["evaluationPeriod"] = *src.evaluationPeriod;
	}
	if (src.valueSource) {
		obj["valueSource"] = *src.valueSource;
	}
	if (src.valueTendency) {
		obj["valueTendency"] = *src.valueTendency;
	}
	if (src.valueState) {
		obj["valueState"] = *src.valueState;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("evaluationPeriod")) {
		dst.evaluationPeriod = obj["evaluationPeriod"].as<decltype(dst.evaluationPeriod)::value_type>();
	} else {
		dst.evaluationPeriod = std::nullopt;
	}
	if (obj.containsKey("valueSource")) {
		dst.valueSource = obj["valueSource"].as<decltype(dst.valueSource)::value_type>();
	} else {
		dst.valueSource = std::nullopt;
	}
	if (obj.containsKey("valueTendency")) {
		dst.valueTendency = obj["valueTendency"].as<decltype(dst.valueTendency)::value_type>();
	} else {
		dst.valueTendency = std::nullopt;
	}
	if (obj.containsKey("valueState")) {
		dst.valueState = obj["valueState"].as<decltype(dst.valueState)::value_type>();
	} else {
		dst.valueState = std::nullopt;
	}

}
bool convertToJson(const MeasurementListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementData) {
		obj["measurementData"] = *src.measurementData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementData")) {
		dst.measurementData = obj["measurementData"].as<decltype(dst.measurementData)::value_type>();
	} else {
		dst.measurementData = std::nullopt;
	}

}
bool convertToJson(const MeasurementListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}

}
bool convertToJson(const MeasurementSeriesDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.evaluationPeriod) {
		obj["evaluationPeriod"] = *src.evaluationPeriod;
	}
	if (src.valueSource) {
		obj["valueSource"] = *src.valueSource;
	}
	if (src.valueTendency) {
		obj["valueTendency"] = *src.valueTendency;
	}
	if (src.valueState) {
		obj["valueState"] = *src.valueState;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementSeriesDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("evaluationPeriod")) {
		dst.evaluationPeriod = obj["evaluationPeriod"].as<decltype(dst.evaluationPeriod)::value_type>();
	} else {
		dst.evaluationPeriod = std::nullopt;
	}
	if (obj.containsKey("valueSource")) {
		dst.valueSource = obj["valueSource"].as<decltype(dst.valueSource)::value_type>();
	} else {
		dst.valueSource = std::nullopt;
	}
	if (obj.containsKey("valueTendency")) {
		dst.valueTendency = obj["valueTendency"].as<decltype(dst.valueTendency)::value_type>();
	} else {
		dst.valueTendency = std::nullopt;
	}
	if (obj.containsKey("valueState")) {
		dst.valueState = obj["valueState"].as<decltype(dst.valueState)::value_type>();
	} else {
		dst.valueState = std::nullopt;
	}

}
bool convertToJson(const MeasurementSeriesDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.evaluationPeriod) {
		obj["evaluationPeriod"] = *src.evaluationPeriod;
	}
	if (src.valueSource) {
		obj["valueSource"] = *src.valueSource;
	}
	if (src.valueTendency) {
		obj["valueTendency"] = *src.valueTendency;
	}
	if (src.valueState) {
		obj["valueState"] = *src.valueState;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementSeriesDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("evaluationPeriod")) {
		dst.evaluationPeriod = obj["evaluationPeriod"].as<decltype(dst.evaluationPeriod)::value_type>();
	} else {
		dst.evaluationPeriod = std::nullopt;
	}
	if (obj.containsKey("valueSource")) {
		dst.valueSource = obj["valueSource"].as<decltype(dst.valueSource)::value_type>();
	} else {
		dst.valueSource = std::nullopt;
	}
	if (obj.containsKey("valueTendency")) {
		dst.valueTendency = obj["valueTendency"].as<decltype(dst.valueTendency)::value_type>();
	} else {
		dst.valueTendency = std::nullopt;
	}
	if (obj.containsKey("valueState")) {
		dst.valueState = obj["valueState"].as<decltype(dst.valueState)::value_type>();
	} else {
		dst.valueState = std::nullopt;
	}

}
bool convertToJson(const MeasurementSeriesListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementSeriesData) {
		obj["measurementSeriesData"] = *src.measurementSeriesData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementSeriesListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementSeriesData")) {
		dst.measurementSeriesData = obj["measurementSeriesData"].as<decltype(dst.measurementSeriesData)::value_type>();
	} else {
		dst.measurementSeriesData = std::nullopt;
	}

}
bool convertToJson(const MeasurementSeriesListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementSeriesListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}

}
bool convertToJson(const MeasurementConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.valueRangeMin) {
		obj["valueRangeMin"] = *src.valueRangeMin;
	}
	if (src.valueRangeMax) {
		obj["valueRangeMax"] = *src.valueRangeMax;
	}
	if (src.valueStepSize) {
		obj["valueStepSize"] = *src.valueStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("valueRangeMin")) {
		dst.valueRangeMin = obj["valueRangeMin"].as<decltype(dst.valueRangeMin)::value_type>();
	} else {
		dst.valueRangeMin = std::nullopt;
	}
	if (obj.containsKey("valueRangeMax")) {
		dst.valueRangeMax = obj["valueRangeMax"].as<decltype(dst.valueRangeMax)::value_type>();
	} else {
		dst.valueRangeMax = std::nullopt;
	}
	if (obj.containsKey("valueStepSize")) {
		dst.valueStepSize = obj["valueStepSize"].as<decltype(dst.valueStepSize)::value_type>();
	} else {
		dst.valueStepSize = std::nullopt;
	}

}
bool convertToJson(const MeasurementConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.valueRangeMin) {
		obj["valueRangeMin"] = *src.valueRangeMin;
	}
	if (src.valueRangeMax) {
		obj["valueRangeMax"] = *src.valueRangeMax;
	}
	if (src.valueStepSize) {
		obj["valueStepSize"] = *src.valueStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("valueRangeMin")) {
		dst.valueRangeMin = obj["valueRangeMin"].as<decltype(dst.valueRangeMin)::value_type>();
	} else {
		dst.valueRangeMin = std::nullopt;
	}
	if (obj.containsKey("valueRangeMax")) {
		dst.valueRangeMax = obj["valueRangeMax"].as<decltype(dst.valueRangeMax)::value_type>();
	} else {
		dst.valueRangeMax = std::nullopt;
	}
	if (obj.containsKey("valueStepSize")) {
		dst.valueStepSize = obj["valueStepSize"].as<decltype(dst.valueStepSize)::value_type>();
	} else {
		dst.valueStepSize = std::nullopt;
	}

}
bool convertToJson(const MeasurementConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementConstraintsData) {
		obj["measurementConstraintsData"] = *src.measurementConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementConstraintsData")) {
		dst.measurementConstraintsData = obj["measurementConstraintsData"].as<decltype(dst.measurementConstraintsData)::value_type>();
	} else {
		dst.measurementConstraintsData = std::nullopt;
	}

}
bool convertToJson(const MeasurementConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}

}
bool convertToJson(const MeasurementDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.measurementType) {
		obj["measurementType"] = *src.measurementType;
	}
	if (src.commodityType) {
		obj["commodityType"] = *src.commodityType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.calibrationValue) {
		obj["calibrationValue"] = *src.calibrationValue;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("measurementType")) {
		dst.measurementType = obj["measurementType"].as<decltype(dst.measurementType)::value_type>();
	} else {
		dst.measurementType = std::nullopt;
	}
	if (obj.containsKey("commodityType")) {
		dst.commodityType = obj["commodityType"].as<decltype(dst.commodityType)::value_type>();
	} else {
		dst.commodityType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("calibrationValue")) {
		dst.calibrationValue = obj["calibrationValue"].as<decltype(dst.calibrationValue)::value_type>();
	} else {
		dst.calibrationValue = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const MeasurementDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.measurementType) {
		obj["measurementType"] = *src.measurementType;
	}
	if (src.commodityType) {
		obj["commodityType"] = *src.commodityType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.calibrationValue) {
		obj["calibrationValue"] = *src.calibrationValue;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("measurementType")) {
		dst.measurementType = obj["measurementType"].as<decltype(dst.measurementType)::value_type>();
	} else {
		dst.measurementType = std::nullopt;
	}
	if (obj.containsKey("commodityType")) {
		dst.commodityType = obj["commodityType"].as<decltype(dst.commodityType)::value_type>();
	} else {
		dst.commodityType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("calibrationValue")) {
		dst.calibrationValue = obj["calibrationValue"].as<decltype(dst.calibrationValue)::value_type>();
	} else {
		dst.calibrationValue = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const MeasurementDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementDescriptionData) {
		obj["measurementDescriptionData"] = *src.measurementDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementDescriptionData")) {
		dst.measurementDescriptionData = obj["measurementDescriptionData"].as<decltype(dst.measurementDescriptionData)::value_type>();
	} else {
		dst.measurementDescriptionData = std::nullopt;
	}

}
bool convertToJson(const MeasurementDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.measurementType) {
		obj["measurementType"] = *src.measurementType;
	}
	if (src.commodityType) {
		obj["commodityType"] = *src.commodityType;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("measurementType")) {
		dst.measurementType = obj["measurementType"].as<decltype(dst.measurementType)::value_type>();
	} else {
		dst.measurementType = std::nullopt;
	}
	if (obj.containsKey("commodityType")) {
		dst.commodityType = obj["commodityType"].as<decltype(dst.commodityType)::value_type>();
	} else {
		dst.commodityType = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const MeasurementThresholdRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementThresholdRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}

}
bool convertToJson(const MeasurementThresholdRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementThresholdRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}

}
bool convertToJson(const MeasurementThresholdRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementThresholdRelationData) {
		obj["measurementThresholdRelationData"] = *src.measurementThresholdRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementThresholdRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementThresholdRelationData")) {
		dst.measurementThresholdRelationData = obj["measurementThresholdRelationData"].as<decltype(dst.measurementThresholdRelationData)::value_type>();
	} else {
		dst.measurementThresholdRelationData = std::nullopt;
	}

}
bool convertToJson(const MeasurementThresholdRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MeasurementThresholdRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}

}
bool convertToJson(const ThresholdDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.thresholdValue) {
		obj["thresholdValue"] = *src.thresholdValue;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("thresholdValue")) {
		dst.thresholdValue = obj["thresholdValue"].as<decltype(dst.thresholdValue)::value_type>();
	} else {
		dst.thresholdValue = std::nullopt;
	}

}
bool convertToJson(const ThresholdDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.thresholdValue) {
		obj["thresholdValue"] = *src.thresholdValue;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("thresholdValue")) {
		dst.thresholdValue = obj["thresholdValue"].as<decltype(dst.thresholdValue)::value_type>();
	} else {
		dst.thresholdValue = std::nullopt;
	}

}
bool convertToJson(const ThresholdListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdData) {
		obj["thresholdData"] = *src.thresholdData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdData")) {
		dst.thresholdData = obj["thresholdData"].as<decltype(dst.thresholdData)::value_type>();
	} else {
		dst.thresholdData = std::nullopt;
	}

}
bool convertToJson(const ThresholdListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}

}
bool convertToJson(const ThresholdConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.thresholdRangeMin) {
		obj["thresholdRangeMin"] = *src.thresholdRangeMin;
	}
	if (src.thresholdRangeMax) {
		obj["thresholdRangeMax"] = *src.thresholdRangeMax;
	}
	if (src.thresholdStepSize) {
		obj["thresholdStepSize"] = *src.thresholdStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("thresholdRangeMin")) {
		dst.thresholdRangeMin = obj["thresholdRangeMin"].as<decltype(dst.thresholdRangeMin)::value_type>();
	} else {
		dst.thresholdRangeMin = std::nullopt;
	}
	if (obj.containsKey("thresholdRangeMax")) {
		dst.thresholdRangeMax = obj["thresholdRangeMax"].as<decltype(dst.thresholdRangeMax)::value_type>();
	} else {
		dst.thresholdRangeMax = std::nullopt;
	}
	if (obj.containsKey("thresholdStepSize")) {
		dst.thresholdStepSize = obj["thresholdStepSize"].as<decltype(dst.thresholdStepSize)::value_type>();
	} else {
		dst.thresholdStepSize = std::nullopt;
	}

}
bool convertToJson(const ThresholdConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.thresholdRangeMin) {
		obj["thresholdRangeMin"] = *src.thresholdRangeMin;
	}
	if (src.thresholdRangeMax) {
		obj["thresholdRangeMax"] = *src.thresholdRangeMax;
	}
	if (src.thresholdStepSize) {
		obj["thresholdStepSize"] = *src.thresholdStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("thresholdRangeMin")) {
		dst.thresholdRangeMin = obj["thresholdRangeMin"].as<decltype(dst.thresholdRangeMin)::value_type>();
	} else {
		dst.thresholdRangeMin = std::nullopt;
	}
	if (obj.containsKey("thresholdRangeMax")) {
		dst.thresholdRangeMax = obj["thresholdRangeMax"].as<decltype(dst.thresholdRangeMax)::value_type>();
	} else {
		dst.thresholdRangeMax = std::nullopt;
	}
	if (obj.containsKey("thresholdStepSize")) {
		dst.thresholdStepSize = obj["thresholdStepSize"].as<decltype(dst.thresholdStepSize)::value_type>();
	} else {
		dst.thresholdStepSize = std::nullopt;
	}

}
bool convertToJson(const ThresholdConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdConstraintsData) {
		obj["thresholdConstraintsData"] = *src.thresholdConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdConstraintsData")) {
		dst.thresholdConstraintsData = obj["thresholdConstraintsData"].as<decltype(dst.thresholdConstraintsData)::value_type>();
	} else {
		dst.thresholdConstraintsData = std::nullopt;
	}

}
bool convertToJson(const ThresholdConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}

}
bool convertToJson(const ThresholdDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.thresholdType) {
		obj["thresholdType"] = *src.thresholdType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("thresholdType")) {
		dst.thresholdType = obj["thresholdType"].as<decltype(dst.thresholdType)::value_type>();
	} else {
		dst.thresholdType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const ThresholdDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.thresholdType) {
		obj["thresholdType"] = *src.thresholdType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("thresholdType")) {
		dst.thresholdType = obj["thresholdType"].as<decltype(dst.thresholdType)::value_type>();
	} else {
		dst.thresholdType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const ThresholdDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdDescriptionData) {
		obj["thresholdDescriptionData"] = *src.thresholdDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdDescriptionData")) {
		dst.thresholdDescriptionData = obj["thresholdDescriptionData"].as<decltype(dst.thresholdDescriptionData)::value_type>();
	} else {
		dst.thresholdDescriptionData = std::nullopt;
	}

}
bool convertToJson(const ThresholdDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ThresholdDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const DirectControlActivityStateType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.directcontrolactivitystateenumtype) {
		obj["DirectControlActivityStateEnumType"] = *src.directcontrolactivitystateenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, DirectControlActivityStateType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("DirectControlActivityStateEnumType")) {
		dst.directcontrolactivitystateenumtype = obj["DirectControlActivityStateEnumType"].as<decltype(dst.directcontrolactivitystateenumtype)::value_type>();
	} else {
		dst.directcontrolactivitystateenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const PowerTimeSlotValueTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powertimeslotvaluetypeenumtype) {
		obj["PowerTimeSlotValueTypeEnumType"] = *src.powertimeslotvaluetypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotValueTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("PowerTimeSlotValueTypeEnumType")) {
		dst.powertimeslotvaluetypeenumtype = obj["PowerTimeSlotValueTypeEnumType"].as<decltype(dst.powertimeslotvaluetypeenumtype)::value_type>();
	} else {
		dst.powertimeslotvaluetypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const PowerSequenceScopeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powersequencescopeenumtype) {
		obj["PowerSequenceScopeEnumType"] = *src.powersequencescopeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, PowerSequenceScopeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("PowerSequenceScopeEnumType")) {
		dst.powersequencescopeenumtype = obj["PowerSequenceScopeEnumType"].as<decltype(dst.powersequencescopeenumtype)::value_type>();
	} else {
		dst.powersequencescopeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const PowerSequenceStateType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powersequencestateenumtype) {
		obj["PowerSequenceStateEnumType"] = *src.powersequencestateenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, PowerSequenceStateType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("PowerSequenceStateEnumType")) {
		dst.powersequencestateenumtype = obj["PowerSequenceStateEnumType"].as<decltype(dst.powersequencestateenumtype)::value_type>();
	} else {
		dst.powersequencestateenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const DirectControlActivityDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.activityState) {
		obj["activityState"] = *src.activityState;
	}
	if (src.isActivityStateChangeable) {
		obj["isActivityStateChangeable"] = *src.isActivityStateChangeable;
	}
	if (src.energyMode) {
		obj["energyMode"] = *src.energyMode;
	}
	if (src.isEnergyModeChangeable) {
		obj["isEnergyModeChangeable"] = *src.isEnergyModeChangeable;
	}
	if (src.power) {
		obj["power"] = *src.power;
	}
	if (src.isPowerChangeable) {
		obj["isPowerChangeable"] = *src.isPowerChangeable;
	}
	if (src.energy) {
		obj["energy"] = *src.energy;
	}
	if (src.isEnergyChangeable) {
		obj["isEnergyChangeable"] = *src.isEnergyChangeable;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DirectControlActivityDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("activityState")) {
		dst.activityState = obj["activityState"].as<decltype(dst.activityState)::value_type>();
	} else {
		dst.activityState = std::nullopt;
	}
	if (obj.containsKey("isActivityStateChangeable")) {
		dst.isActivityStateChangeable = obj["isActivityStateChangeable"].as<decltype(dst.isActivityStateChangeable)::value_type>();
	} else {
		dst.isActivityStateChangeable = std::nullopt;
	}
	if (obj.containsKey("energyMode")) {
		dst.energyMode = obj["energyMode"].as<decltype(dst.energyMode)::value_type>();
	} else {
		dst.energyMode = std::nullopt;
	}
	if (obj.containsKey("isEnergyModeChangeable")) {
		dst.isEnergyModeChangeable = obj["isEnergyModeChangeable"].as<decltype(dst.isEnergyModeChangeable)::value_type>();
	} else {
		dst.isEnergyModeChangeable = std::nullopt;
	}
	if (obj.containsKey("power")) {
		dst.power = obj["power"].as<decltype(dst.power)::value_type>();
	} else {
		dst.power = std::nullopt;
	}
	if (obj.containsKey("isPowerChangeable")) {
		dst.isPowerChangeable = obj["isPowerChangeable"].as<decltype(dst.isPowerChangeable)::value_type>();
	} else {
		dst.isPowerChangeable = std::nullopt;
	}
	if (obj.containsKey("energy")) {
		dst.energy = obj["energy"].as<decltype(dst.energy)::value_type>();
	} else {
		dst.energy = std::nullopt;
	}
	if (obj.containsKey("isEnergyChangeable")) {
		dst.isEnergyChangeable = obj["isEnergyChangeable"].as<decltype(dst.isEnergyChangeable)::value_type>();
	} else {
		dst.isEnergyChangeable = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const DirectControlActivityDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.activityState) {
		obj["activityState"] = *src.activityState;
	}
	if (src.isActivityStateChangeable) {
		obj["isActivityStateChangeable"] = *src.isActivityStateChangeable;
	}
	if (src.energyMode) {
		obj["energyMode"] = *src.energyMode;
	}
	if (src.isEnergyModeChangeable) {
		obj["isEnergyModeChangeable"] = *src.isEnergyModeChangeable;
	}
	if (src.power) {
		obj["power"] = *src.power;
	}
	if (src.isPowerChangeable) {
		obj["isPowerChangeable"] = *src.isPowerChangeable;
	}
	if (src.energy) {
		obj["energy"] = *src.energy;
	}
	if (src.isEnergyChangeable) {
		obj["isEnergyChangeable"] = *src.isEnergyChangeable;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DirectControlActivityDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("activityState")) {
		dst.activityState = obj["activityState"].as<decltype(dst.activityState)::value_type>();
	} else {
		dst.activityState = std::nullopt;
	}
	if (obj.containsKey("isActivityStateChangeable")) {
		dst.isActivityStateChangeable = obj["isActivityStateChangeable"].as<decltype(dst.isActivityStateChangeable)::value_type>();
	} else {
		dst.isActivityStateChangeable = std::nullopt;
	}
	if (obj.containsKey("energyMode")) {
		dst.energyMode = obj["energyMode"].as<decltype(dst.energyMode)::value_type>();
	} else {
		dst.energyMode = std::nullopt;
	}
	if (obj.containsKey("isEnergyModeChangeable")) {
		dst.isEnergyModeChangeable = obj["isEnergyModeChangeable"].as<decltype(dst.isEnergyModeChangeable)::value_type>();
	} else {
		dst.isEnergyModeChangeable = std::nullopt;
	}
	if (obj.containsKey("power")) {
		dst.power = obj["power"].as<decltype(dst.power)::value_type>();
	} else {
		dst.power = std::nullopt;
	}
	if (obj.containsKey("isPowerChangeable")) {
		dst.isPowerChangeable = obj["isPowerChangeable"].as<decltype(dst.isPowerChangeable)::value_type>();
	} else {
		dst.isPowerChangeable = std::nullopt;
	}
	if (obj.containsKey("energy")) {
		dst.energy = obj["energy"].as<decltype(dst.energy)::value_type>();
	} else {
		dst.energy = std::nullopt;
	}
	if (obj.containsKey("isEnergyChangeable")) {
		dst.isEnergyChangeable = obj["isEnergyChangeable"].as<decltype(dst.isEnergyChangeable)::value_type>();
	} else {
		dst.isEnergyChangeable = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const DirectControlActivityListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.directControlActivityData) {
		obj["directControlActivityData"] = *src.directControlActivityData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DirectControlActivityListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("directControlActivityData")) {
		dst.directControlActivityData = obj["directControlActivityData"].as<decltype(dst.directControlActivityData)::value_type>();
	} else {
		dst.directControlActivityData = std::nullopt;
	}

}
bool convertToJson(const DirectControlActivityListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DirectControlActivityListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}

}
bool convertToJson(const DirectControlDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.powerUnit) {
		obj["powerUnit"] = *src.powerUnit;
	}
	if (src.energyUnit) {
		obj["energyUnit"] = *src.energyUnit;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DirectControlDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("powerUnit")) {
		dst.powerUnit = obj["powerUnit"].as<decltype(dst.powerUnit)::value_type>();
	} else {
		dst.powerUnit = std::nullopt;
	}
	if (obj.containsKey("energyUnit")) {
		dst.energyUnit = obj["energyUnit"].as<decltype(dst.energyUnit)::value_type>();
	} else {
		dst.energyUnit = std::nullopt;
	}

}
bool convertToJson(const DirectControlDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.powerUnit) {
		obj["powerUnit"] = *src.powerUnit;
	}
	if (src.energyUnit) {
		obj["energyUnit"] = *src.energyUnit;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DirectControlDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("powerUnit")) {
		dst.powerUnit = obj["powerUnit"].as<decltype(dst.powerUnit)::value_type>();
	} else {
		dst.powerUnit = std::nullopt;
	}
	if (obj.containsKey("energyUnit")) {
		dst.energyUnit = obj["energyUnit"].as<decltype(dst.energyUnit)::value_type>();
	} else {
		dst.energyUnit = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotScheduleDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.defaultDuration) {
		obj["defaultDuration"] = *src.defaultDuration;
	}
	if (src.durationUncertainty) {
		obj["durationUncertainty"] = *src.durationUncertainty;
	}
	if (src.slotActivated) {
		obj["slotActivated"] = *src.slotActivated;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotScheduleDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("defaultDuration")) {
		dst.defaultDuration = obj["defaultDuration"].as<decltype(dst.defaultDuration)::value_type>();
	} else {
		dst.defaultDuration = std::nullopt;
	}
	if (obj.containsKey("durationUncertainty")) {
		dst.durationUncertainty = obj["durationUncertainty"].as<decltype(dst.durationUncertainty)::value_type>();
	} else {
		dst.durationUncertainty = std::nullopt;
	}
	if (obj.containsKey("slotActivated")) {
		dst.slotActivated = obj["slotActivated"].as<decltype(dst.slotActivated)::value_type>();
	} else {
		dst.slotActivated = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotScheduleDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.defaultDuration) {
		obj["defaultDuration"] = *src.defaultDuration;
	}
	if (src.durationUncertainty) {
		obj["durationUncertainty"] = *src.durationUncertainty;
	}
	if (src.slotActivated) {
		obj["slotActivated"] = *src.slotActivated;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotScheduleDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("defaultDuration")) {
		dst.defaultDuration = obj["defaultDuration"].as<decltype(dst.defaultDuration)::value_type>();
	} else {
		dst.defaultDuration = std::nullopt;
	}
	if (obj.containsKey("durationUncertainty")) {
		dst.durationUncertainty = obj["durationUncertainty"].as<decltype(dst.durationUncertainty)::value_type>();
	} else {
		dst.durationUncertainty = std::nullopt;
	}
	if (obj.containsKey("slotActivated")) {
		dst.slotActivated = obj["slotActivated"].as<decltype(dst.slotActivated)::value_type>();
	} else {
		dst.slotActivated = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotScheduleListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerTimeSlotScheduleData) {
		obj["powerTimeSlotScheduleData"] = *src.powerTimeSlotScheduleData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotScheduleListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerTimeSlotScheduleData")) {
		dst.powerTimeSlotScheduleData = obj["powerTimeSlotScheduleData"].as<decltype(dst.powerTimeSlotScheduleData)::value_type>();
	} else {
		dst.powerTimeSlotScheduleData = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotScheduleListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotScheduleListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotValueDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotValueDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotValueDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotValueDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotValueListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerTimeSlotValueData) {
		obj["powerTimeSlotValueData"] = *src.powerTimeSlotValueData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotValueListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerTimeSlotValueData")) {
		dst.powerTimeSlotValueData = obj["powerTimeSlotValueData"].as<decltype(dst.powerTimeSlotValueData)::value_type>();
	} else {
		dst.powerTimeSlotValueData = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotValueListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotValueListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotScheduleConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}
	if (src.earliestStartTime) {
		obj["earliestStartTime"] = *src.earliestStartTime;
	}
	if (src.latestEndTime) {
		obj["latestEndTime"] = *src.latestEndTime;
	}
	if (src.minDuration) {
		obj["minDuration"] = *src.minDuration;
	}
	if (src.maxDuration) {
		obj["maxDuration"] = *src.maxDuration;
	}
	if (src.optionalSlot) {
		obj["optionalSlot"] = *src.optionalSlot;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotScheduleConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}
	if (obj.containsKey("earliestStartTime")) {
		dst.earliestStartTime = obj["earliestStartTime"].as<decltype(dst.earliestStartTime)::value_type>();
	} else {
		dst.earliestStartTime = std::nullopt;
	}
	if (obj.containsKey("latestEndTime")) {
		dst.latestEndTime = obj["latestEndTime"].as<decltype(dst.latestEndTime)::value_type>();
	} else {
		dst.latestEndTime = std::nullopt;
	}
	if (obj.containsKey("minDuration")) {
		dst.minDuration = obj["minDuration"].as<decltype(dst.minDuration)::value_type>();
	} else {
		dst.minDuration = std::nullopt;
	}
	if (obj.containsKey("maxDuration")) {
		dst.maxDuration = obj["maxDuration"].as<decltype(dst.maxDuration)::value_type>();
	} else {
		dst.maxDuration = std::nullopt;
	}
	if (obj.containsKey("optionalSlot")) {
		dst.optionalSlot = obj["optionalSlot"].as<decltype(dst.optionalSlot)::value_type>();
	} else {
		dst.optionalSlot = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotScheduleConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}
	if (src.earliestStartTime) {
		obj["earliestStartTime"] = *src.earliestStartTime;
	}
	if (src.latestEndTime) {
		obj["latestEndTime"] = *src.latestEndTime;
	}
	if (src.minDuration) {
		obj["minDuration"] = *src.minDuration;
	}
	if (src.maxDuration) {
		obj["maxDuration"] = *src.maxDuration;
	}
	if (src.optionalSlot) {
		obj["optionalSlot"] = *src.optionalSlot;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotScheduleConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}
	if (obj.containsKey("earliestStartTime")) {
		dst.earliestStartTime = obj["earliestStartTime"].as<decltype(dst.earliestStartTime)::value_type>();
	} else {
		dst.earliestStartTime = std::nullopt;
	}
	if (obj.containsKey("latestEndTime")) {
		dst.latestEndTime = obj["latestEndTime"].as<decltype(dst.latestEndTime)::value_type>();
	} else {
		dst.latestEndTime = std::nullopt;
	}
	if (obj.containsKey("minDuration")) {
		dst.minDuration = obj["minDuration"].as<decltype(dst.minDuration)::value_type>();
	} else {
		dst.minDuration = std::nullopt;
	}
	if (obj.containsKey("maxDuration")) {
		dst.maxDuration = obj["maxDuration"].as<decltype(dst.maxDuration)::value_type>();
	} else {
		dst.maxDuration = std::nullopt;
	}
	if (obj.containsKey("optionalSlot")) {
		dst.optionalSlot = obj["optionalSlot"].as<decltype(dst.optionalSlot)::value_type>();
	} else {
		dst.optionalSlot = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotScheduleConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerTimeSlotScheduleConstraintsData) {
		obj["powerTimeSlotScheduleConstraintsData"] = *src.powerTimeSlotScheduleConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotScheduleConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerTimeSlotScheduleConstraintsData")) {
		dst.powerTimeSlotScheduleConstraintsData = obj["powerTimeSlotScheduleConstraintsData"].as<decltype(dst.powerTimeSlotScheduleConstraintsData)::value_type>();
	} else {
		dst.powerTimeSlotScheduleConstraintsData = std::nullopt;
	}

}
bool convertToJson(const PowerTimeSlotScheduleConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.slotNumber) {
		obj["slotNumber"] = *src.slotNumber;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotScheduleConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("slotNumber")) {
		dst.slotNumber = obj["slotNumber"].as<decltype(dst.slotNumber)::value_type>();
	} else {
		dst.slotNumber = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceAlternativesRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alternativesId) {
		obj["alternativesId"] = *src.alternativesId;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceAlternativesRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alternativesId")) {
		dst.alternativesId = obj["alternativesId"].as<decltype(dst.alternativesId)::value_type>();
	} else {
		dst.alternativesId = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceAlternativesRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alternativesId) {
		obj["alternativesId"] = *src.alternativesId;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceAlternativesRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alternativesId")) {
		dst.alternativesId = obj["alternativesId"].as<decltype(dst.alternativesId)::value_type>();
	} else {
		dst.alternativesId = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceAlternativesRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerSequenceAlternativesRelationData) {
		obj["powerSequenceAlternativesRelationData"] = *src.powerSequenceAlternativesRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceAlternativesRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerSequenceAlternativesRelationData")) {
		dst.powerSequenceAlternativesRelationData = obj["powerSequenceAlternativesRelationData"].as<decltype(dst.powerSequenceAlternativesRelationData)::value_type>();
	} else {
		dst.powerSequenceAlternativesRelationData = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceAlternativesRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alternativesId) {
		obj["alternativesId"] = *src.alternativesId;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceAlternativesRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alternativesId")) {
		dst.alternativesId = obj["alternativesId"].as<decltype(dst.alternativesId)::value_type>();
	} else {
		dst.alternativesId = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.powerUnit) {
		obj["powerUnit"] = *src.powerUnit;
	}
	if (src.energyUnit) {
		obj["energyUnit"] = *src.energyUnit;
	}
	if (src.valueSource) {
		obj["valueSource"] = *src.valueSource;
	}
	if (src.scope) {
		obj["scope"] = *src.scope;
	}
	if (src.taskIdentifier) {
		obj["taskIdentifier"] = *src.taskIdentifier;
	}
	if (src.repetitionsTotal) {
		obj["repetitionsTotal"] = *src.repetitionsTotal;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("powerUnit")) {
		dst.powerUnit = obj["powerUnit"].as<decltype(dst.powerUnit)::value_type>();
	} else {
		dst.powerUnit = std::nullopt;
	}
	if (obj.containsKey("energyUnit")) {
		dst.energyUnit = obj["energyUnit"].as<decltype(dst.energyUnit)::value_type>();
	} else {
		dst.energyUnit = std::nullopt;
	}
	if (obj.containsKey("valueSource")) {
		dst.valueSource = obj["valueSource"].as<decltype(dst.valueSource)::value_type>();
	} else {
		dst.valueSource = std::nullopt;
	}
	if (obj.containsKey("scope")) {
		dst.scope = obj["scope"].as<decltype(dst.scope)::value_type>();
	} else {
		dst.scope = std::nullopt;
	}
	if (obj.containsKey("taskIdentifier")) {
		dst.taskIdentifier = obj["taskIdentifier"].as<decltype(dst.taskIdentifier)::value_type>();
	} else {
		dst.taskIdentifier = std::nullopt;
	}
	if (obj.containsKey("repetitionsTotal")) {
		dst.repetitionsTotal = obj["repetitionsTotal"].as<decltype(dst.repetitionsTotal)::value_type>();
	} else {
		dst.repetitionsTotal = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.powerUnit) {
		obj["powerUnit"] = *src.powerUnit;
	}
	if (src.energyUnit) {
		obj["energyUnit"] = *src.energyUnit;
	}
	if (src.valueSource) {
		obj["valueSource"] = *src.valueSource;
	}
	if (src.scope) {
		obj["scope"] = *src.scope;
	}
	if (src.taskIdentifier) {
		obj["taskIdentifier"] = *src.taskIdentifier;
	}
	if (src.repetitionsTotal) {
		obj["repetitionsTotal"] = *src.repetitionsTotal;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("powerUnit")) {
		dst.powerUnit = obj["powerUnit"].as<decltype(dst.powerUnit)::value_type>();
	} else {
		dst.powerUnit = std::nullopt;
	}
	if (obj.containsKey("energyUnit")) {
		dst.energyUnit = obj["energyUnit"].as<decltype(dst.energyUnit)::value_type>();
	} else {
		dst.energyUnit = std::nullopt;
	}
	if (obj.containsKey("valueSource")) {
		dst.valueSource = obj["valueSource"].as<decltype(dst.valueSource)::value_type>();
	} else {
		dst.valueSource = std::nullopt;
	}
	if (obj.containsKey("scope")) {
		dst.scope = obj["scope"].as<decltype(dst.scope)::value_type>();
	} else {
		dst.scope = std::nullopt;
	}
	if (obj.containsKey("taskIdentifier")) {
		dst.taskIdentifier = obj["taskIdentifier"].as<decltype(dst.taskIdentifier)::value_type>();
	} else {
		dst.taskIdentifier = std::nullopt;
	}
	if (obj.containsKey("repetitionsTotal")) {
		dst.repetitionsTotal = obj["repetitionsTotal"].as<decltype(dst.repetitionsTotal)::value_type>();
	} else {
		dst.repetitionsTotal = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerSequenceDescriptionData) {
		obj["powerSequenceDescriptionData"] = *src.powerSequenceDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerSequenceDescriptionData")) {
		dst.powerSequenceDescriptionData = obj["powerSequenceDescriptionData"].as<decltype(dst.powerSequenceDescriptionData)::value_type>();
	} else {
		dst.powerSequenceDescriptionData = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceStateDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.state) {
		obj["state"] = *src.state;
	}
	if (src.activeSlotNumber) {
		obj["activeSlotNumber"] = *src.activeSlotNumber;
	}
	if (src.elapsedSlotTime) {
		obj["elapsedSlotTime"] = *src.elapsedSlotTime;
	}
	if (src.remainingSlotTime) {
		obj["remainingSlotTime"] = *src.remainingSlotTime;
	}
	if (src.sequenceRemoteControllable) {
		obj["sequenceRemoteControllable"] = *src.sequenceRemoteControllable;
	}
	if (src.activeRepetitionNumber) {
		obj["activeRepetitionNumber"] = *src.activeRepetitionNumber;
	}
	if (src.remainingPauseTime) {
		obj["remainingPauseTime"] = *src.remainingPauseTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceStateDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("state")) {
		dst.state = obj["state"].as<decltype(dst.state)::value_type>();
	} else {
		dst.state = std::nullopt;
	}
	if (obj.containsKey("activeSlotNumber")) {
		dst.activeSlotNumber = obj["activeSlotNumber"].as<decltype(dst.activeSlotNumber)::value_type>();
	} else {
		dst.activeSlotNumber = std::nullopt;
	}
	if (obj.containsKey("elapsedSlotTime")) {
		dst.elapsedSlotTime = obj["elapsedSlotTime"].as<decltype(dst.elapsedSlotTime)::value_type>();
	} else {
		dst.elapsedSlotTime = std::nullopt;
	}
	if (obj.containsKey("remainingSlotTime")) {
		dst.remainingSlotTime = obj["remainingSlotTime"].as<decltype(dst.remainingSlotTime)::value_type>();
	} else {
		dst.remainingSlotTime = std::nullopt;
	}
	if (obj.containsKey("sequenceRemoteControllable")) {
		dst.sequenceRemoteControllable = obj["sequenceRemoteControllable"].as<decltype(dst.sequenceRemoteControllable)::value_type>();
	} else {
		dst.sequenceRemoteControllable = std::nullopt;
	}
	if (obj.containsKey("activeRepetitionNumber")) {
		dst.activeRepetitionNumber = obj["activeRepetitionNumber"].as<decltype(dst.activeRepetitionNumber)::value_type>();
	} else {
		dst.activeRepetitionNumber = std::nullopt;
	}
	if (obj.containsKey("remainingPauseTime")) {
		dst.remainingPauseTime = obj["remainingPauseTime"].as<decltype(dst.remainingPauseTime)::value_type>();
	} else {
		dst.remainingPauseTime = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceStateDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.state) {
		obj["state"] = *src.state;
	}
	if (src.activeSlotNumber) {
		obj["activeSlotNumber"] = *src.activeSlotNumber;
	}
	if (src.elapsedSlotTime) {
		obj["elapsedSlotTime"] = *src.elapsedSlotTime;
	}
	if (src.remainingSlotTime) {
		obj["remainingSlotTime"] = *src.remainingSlotTime;
	}
	if (src.sequenceRemoteControllable) {
		obj["sequenceRemoteControllable"] = *src.sequenceRemoteControllable;
	}
	if (src.activeRepetitionNumber) {
		obj["activeRepetitionNumber"] = *src.activeRepetitionNumber;
	}
	if (src.remainingPauseTime) {
		obj["remainingPauseTime"] = *src.remainingPauseTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceStateDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("state")) {
		dst.state = obj["state"].as<decltype(dst.state)::value_type>();
	} else {
		dst.state = std::nullopt;
	}
	if (obj.containsKey("activeSlotNumber")) {
		dst.activeSlotNumber = obj["activeSlotNumber"].as<decltype(dst.activeSlotNumber)::value_type>();
	} else {
		dst.activeSlotNumber = std::nullopt;
	}
	if (obj.containsKey("elapsedSlotTime")) {
		dst.elapsedSlotTime = obj["elapsedSlotTime"].as<decltype(dst.elapsedSlotTime)::value_type>();
	} else {
		dst.elapsedSlotTime = std::nullopt;
	}
	if (obj.containsKey("remainingSlotTime")) {
		dst.remainingSlotTime = obj["remainingSlotTime"].as<decltype(dst.remainingSlotTime)::value_type>();
	} else {
		dst.remainingSlotTime = std::nullopt;
	}
	if (obj.containsKey("sequenceRemoteControllable")) {
		dst.sequenceRemoteControllable = obj["sequenceRemoteControllable"].as<decltype(dst.sequenceRemoteControllable)::value_type>();
	} else {
		dst.sequenceRemoteControllable = std::nullopt;
	}
	if (obj.containsKey("activeRepetitionNumber")) {
		dst.activeRepetitionNumber = obj["activeRepetitionNumber"].as<decltype(dst.activeRepetitionNumber)::value_type>();
	} else {
		dst.activeRepetitionNumber = std::nullopt;
	}
	if (obj.containsKey("remainingPauseTime")) {
		dst.remainingPauseTime = obj["remainingPauseTime"].as<decltype(dst.remainingPauseTime)::value_type>();
	} else {
		dst.remainingPauseTime = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceStateListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerSequenceStateData) {
		obj["powerSequenceStateData"] = *src.powerSequenceStateData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceStateListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerSequenceStateData")) {
		dst.powerSequenceStateData = obj["powerSequenceStateData"].as<decltype(dst.powerSequenceStateData)::value_type>();
	} else {
		dst.powerSequenceStateData = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceStateListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceStateListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.startTime) {
		obj["startTime"] = *src.startTime;
	}
	if (src.endTime) {
		obj["endTime"] = *src.endTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("startTime")) {
		dst.startTime = obj["startTime"].as<decltype(dst.startTime)::value_type>();
	} else {
		dst.startTime = std::nullopt;
	}
	if (obj.containsKey("endTime")) {
		dst.endTime = obj["endTime"].as<decltype(dst.endTime)::value_type>();
	} else {
		dst.endTime = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.startTime) {
		obj["startTime"] = *src.startTime;
	}
	if (src.endTime) {
		obj["endTime"] = *src.endTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("startTime")) {
		dst.startTime = obj["startTime"].as<decltype(dst.startTime)::value_type>();
	} else {
		dst.startTime = std::nullopt;
	}
	if (obj.containsKey("endTime")) {
		dst.endTime = obj["endTime"].as<decltype(dst.endTime)::value_type>();
	} else {
		dst.endTime = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerSequenceScheduleData) {
		obj["powerSequenceScheduleData"] = *src.powerSequenceScheduleData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerSequenceScheduleData")) {
		dst.powerSequenceScheduleData = obj["powerSequenceScheduleData"].as<decltype(dst.powerSequenceScheduleData)::value_type>();
	} else {
		dst.powerSequenceScheduleData = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.earliestStartTime) {
		obj["earliestStartTime"] = *src.earliestStartTime;
	}
	if (src.latestStartTime) {
		obj["latestStartTime"] = *src.latestStartTime;
	}
	if (src.earliestEndTime) {
		obj["earliestEndTime"] = *src.earliestEndTime;
	}
	if (src.latestEndTime) {
		obj["latestEndTime"] = *src.latestEndTime;
	}
	if (src.optionalSequence) {
		obj["optionalSequence"] = *src.optionalSequence;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("earliestStartTime")) {
		dst.earliestStartTime = obj["earliestStartTime"].as<decltype(dst.earliestStartTime)::value_type>();
	} else {
		dst.earliestStartTime = std::nullopt;
	}
	if (obj.containsKey("latestStartTime")) {
		dst.latestStartTime = obj["latestStartTime"].as<decltype(dst.latestStartTime)::value_type>();
	} else {
		dst.latestStartTime = std::nullopt;
	}
	if (obj.containsKey("earliestEndTime")) {
		dst.earliestEndTime = obj["earliestEndTime"].as<decltype(dst.earliestEndTime)::value_type>();
	} else {
		dst.earliestEndTime = std::nullopt;
	}
	if (obj.containsKey("latestEndTime")) {
		dst.latestEndTime = obj["latestEndTime"].as<decltype(dst.latestEndTime)::value_type>();
	} else {
		dst.latestEndTime = std::nullopt;
	}
	if (obj.containsKey("optionalSequence")) {
		dst.optionalSequence = obj["optionalSequence"].as<decltype(dst.optionalSequence)::value_type>();
	} else {
		dst.optionalSequence = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.earliestStartTime) {
		obj["earliestStartTime"] = *src.earliestStartTime;
	}
	if (src.latestStartTime) {
		obj["latestStartTime"] = *src.latestStartTime;
	}
	if (src.earliestEndTime) {
		obj["earliestEndTime"] = *src.earliestEndTime;
	}
	if (src.latestEndTime) {
		obj["latestEndTime"] = *src.latestEndTime;
	}
	if (src.optionalSequence) {
		obj["optionalSequence"] = *src.optionalSequence;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("earliestStartTime")) {
		dst.earliestStartTime = obj["earliestStartTime"].as<decltype(dst.earliestStartTime)::value_type>();
	} else {
		dst.earliestStartTime = std::nullopt;
	}
	if (obj.containsKey("latestStartTime")) {
		dst.latestStartTime = obj["latestStartTime"].as<decltype(dst.latestStartTime)::value_type>();
	} else {
		dst.latestStartTime = std::nullopt;
	}
	if (obj.containsKey("earliestEndTime")) {
		dst.earliestEndTime = obj["earliestEndTime"].as<decltype(dst.earliestEndTime)::value_type>();
	} else {
		dst.earliestEndTime = std::nullopt;
	}
	if (obj.containsKey("latestEndTime")) {
		dst.latestEndTime = obj["latestEndTime"].as<decltype(dst.latestEndTime)::value_type>();
	} else {
		dst.latestEndTime = std::nullopt;
	}
	if (obj.containsKey("optionalSequence")) {
		dst.optionalSequence = obj["optionalSequence"].as<decltype(dst.optionalSequence)::value_type>();
	} else {
		dst.optionalSequence = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerSequenceScheduleConstraintsData) {
		obj["powerSequenceScheduleConstraintsData"] = *src.powerSequenceScheduleConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerSequenceScheduleConstraintsData")) {
		dst.powerSequenceScheduleConstraintsData = obj["powerSequenceScheduleConstraintsData"].as<decltype(dst.powerSequenceScheduleConstraintsData)::value_type>();
	} else {
		dst.powerSequenceScheduleConstraintsData = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequencePriceDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.potentialStartTime) {
		obj["potentialStartTime"] = *src.potentialStartTime;
	}
	if (src.price) {
		obj["price"] = *src.price;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequencePriceDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("potentialStartTime")) {
		dst.potentialStartTime = obj["potentialStartTime"].as<decltype(dst.potentialStartTime)::value_type>();
	} else {
		dst.potentialStartTime = std::nullopt;
	}
	if (obj.containsKey("price")) {
		dst.price = obj["price"].as<decltype(dst.price)::value_type>();
	} else {
		dst.price = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}

}
bool convertToJson(const PowerSequencePriceDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.potentialStartTime) {
		obj["potentialStartTime"] = *src.potentialStartTime;
	}
	if (src.price) {
		obj["price"] = *src.price;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequencePriceDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("potentialStartTime")) {
		dst.potentialStartTime = obj["potentialStartTime"].as<decltype(dst.potentialStartTime)::value_type>();
	} else {
		dst.potentialStartTime = std::nullopt;
	}
	if (obj.containsKey("price")) {
		dst.price = obj["price"].as<decltype(dst.price)::value_type>();
	} else {
		dst.price = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}

}
bool convertToJson(const PowerSequencePriceListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerSequencePriceData) {
		obj["powerSequencePriceData"] = *src.powerSequencePriceData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequencePriceListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerSequencePriceData")) {
		dst.powerSequencePriceData = obj["powerSequencePriceData"].as<decltype(dst.powerSequencePriceData)::value_type>();
	} else {
		dst.powerSequencePriceData = std::nullopt;
	}

}
bool convertToJson(const PowerSequencePriceListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.potentialStartTimeInterval) {
		obj["potentialStartTimeInterval"] = *src.potentialStartTimeInterval;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequencePriceListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("potentialStartTimeInterval")) {
		dst.potentialStartTimeInterval = obj["potentialStartTimeInterval"].as<decltype(dst.potentialStartTimeInterval)::value_type>();
	} else {
		dst.potentialStartTimeInterval = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceSchedulePreferenceDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.greenest) {
		obj["greenest"] = *src.greenest;
	}
	if (src.cheapest) {
		obj["cheapest"] = *src.cheapest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceSchedulePreferenceDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("greenest")) {
		dst.greenest = obj["greenest"].as<decltype(dst.greenest)::value_type>();
	} else {
		dst.greenest = std::nullopt;
	}
	if (obj.containsKey("cheapest")) {
		dst.cheapest = obj["cheapest"].as<decltype(dst.cheapest)::value_type>();
	} else {
		dst.cheapest = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceSchedulePreferenceDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.greenest) {
		obj["greenest"] = *src.greenest;
	}
	if (src.cheapest) {
		obj["cheapest"] = *src.cheapest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceSchedulePreferenceDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("greenest")) {
		dst.greenest = obj["greenest"].as<decltype(dst.greenest)::value_type>();
	} else {
		dst.greenest = std::nullopt;
	}
	if (obj.containsKey("cheapest")) {
		dst.cheapest = obj["cheapest"].as<decltype(dst.cheapest)::value_type>();
	} else {
		dst.cheapest = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceSchedulePreferenceListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powerSequenceSchedulePreferenceData) {
		obj["powerSequenceSchedulePreferenceData"] = *src.powerSequenceSchedulePreferenceData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceSchedulePreferenceListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("powerSequenceSchedulePreferenceData")) {
		dst.powerSequenceSchedulePreferenceData = obj["powerSequenceSchedulePreferenceData"].as<decltype(dst.powerSequenceSchedulePreferenceData)::value_type>();
	} else {
		dst.powerSequenceSchedulePreferenceData = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceSchedulePreferenceListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceSchedulePreferenceListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceNodeScheduleInformationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeRemoteControllable) {
		obj["nodeRemoteControllable"] = *src.nodeRemoteControllable;
	}
	if (src.supportsSingleSlotSchedulingOnly) {
		obj["supportsSingleSlotSchedulingOnly"] = *src.supportsSingleSlotSchedulingOnly;
	}
	if (src.alternativesCount) {
		obj["alternativesCount"] = *src.alternativesCount;
	}
	if (src.totalSequencesCountMax) {
		obj["totalSequencesCountMax"] = *src.totalSequencesCountMax;
	}
	if (src.supportsReselection) {
		obj["supportsReselection"] = *src.supportsReselection;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceNodeScheduleInformationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeRemoteControllable")) {
		dst.nodeRemoteControllable = obj["nodeRemoteControllable"].as<decltype(dst.nodeRemoteControllable)::value_type>();
	} else {
		dst.nodeRemoteControllable = std::nullopt;
	}
	if (obj.containsKey("supportsSingleSlotSchedulingOnly")) {
		dst.supportsSingleSlotSchedulingOnly = obj["supportsSingleSlotSchedulingOnly"].as<decltype(dst.supportsSingleSlotSchedulingOnly)::value_type>();
	} else {
		dst.supportsSingleSlotSchedulingOnly = std::nullopt;
	}
	if (obj.containsKey("alternativesCount")) {
		dst.alternativesCount = obj["alternativesCount"].as<decltype(dst.alternativesCount)::value_type>();
	} else {
		dst.alternativesCount = std::nullopt;
	}
	if (obj.containsKey("totalSequencesCountMax")) {
		dst.totalSequencesCountMax = obj["totalSequencesCountMax"].as<decltype(dst.totalSequencesCountMax)::value_type>();
	} else {
		dst.totalSequencesCountMax = std::nullopt;
	}
	if (obj.containsKey("supportsReselection")) {
		dst.supportsReselection = obj["supportsReselection"].as<decltype(dst.supportsReselection)::value_type>();
	} else {
		dst.supportsReselection = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceNodeScheduleInformationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeRemoteControllable) {
		obj["nodeRemoteControllable"] = *src.nodeRemoteControllable;
	}
	if (src.supportsSingleSlotSchedulingOnly) {
		obj["supportsSingleSlotSchedulingOnly"] = *src.supportsSingleSlotSchedulingOnly;
	}
	if (src.alternativesCount) {
		obj["alternativesCount"] = *src.alternativesCount;
	}
	if (src.totalSequencesCountMax) {
		obj["totalSequencesCountMax"] = *src.totalSequencesCountMax;
	}
	if (src.supportsReselection) {
		obj["supportsReselection"] = *src.supportsReselection;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceNodeScheduleInformationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeRemoteControllable")) {
		dst.nodeRemoteControllable = obj["nodeRemoteControllable"].as<decltype(dst.nodeRemoteControllable)::value_type>();
	} else {
		dst.nodeRemoteControllable = std::nullopt;
	}
	if (obj.containsKey("supportsSingleSlotSchedulingOnly")) {
		dst.supportsSingleSlotSchedulingOnly = obj["supportsSingleSlotSchedulingOnly"].as<decltype(dst.supportsSingleSlotSchedulingOnly)::value_type>();
	} else {
		dst.supportsSingleSlotSchedulingOnly = std::nullopt;
	}
	if (obj.containsKey("alternativesCount")) {
		dst.alternativesCount = obj["alternativesCount"].as<decltype(dst.alternativesCount)::value_type>();
	} else {
		dst.alternativesCount = std::nullopt;
	}
	if (obj.containsKey("totalSequencesCountMax")) {
		dst.totalSequencesCountMax = obj["totalSequencesCountMax"].as<decltype(dst.totalSequencesCountMax)::value_type>();
	} else {
		dst.totalSequencesCountMax = std::nullopt;
	}
	if (obj.containsKey("supportsReselection")) {
		dst.supportsReselection = obj["supportsReselection"].as<decltype(dst.supportsReselection)::value_type>();
	} else {
		dst.supportsReselection = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleConfigurationRequestCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleConfigurationRequestCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequenceScheduleConfigurationRequestCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequenceScheduleConfigurationRequestCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const PowerSequencePriceCalculationRequestCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.potentialStartTime) {
		obj["potentialStartTime"] = *src.potentialStartTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequencePriceCalculationRequestCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("potentialStartTime")) {
		dst.potentialStartTime = obj["potentialStartTime"].as<decltype(dst.potentialStartTime)::value_type>();
	} else {
		dst.potentialStartTime = std::nullopt;
	}

}
bool convertToJson(const PowerSequencePriceCalculationRequestCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.potentialStartTime) {
		obj["potentialStartTime"] = *src.potentialStartTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, PowerSequencePriceCalculationRequestCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("potentialStartTime")) {
		dst.potentialStartTime = obj["potentialStartTime"].as<decltype(dst.potentialStartTime)::value_type>();
	} else {
		dst.potentialStartTime = std::nullopt;
	}

}
bool convertToJson(const ResultDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.errorNumber) {
		obj["errorNumber"] = *src.errorNumber;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ResultDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("errorNumber")) {
		dst.errorNumber = obj["errorNumber"].as<decltype(dst.errorNumber)::value_type>();
	} else {
		dst.errorNumber = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const BindingManagementEntryDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingId) {
		obj["bindingId"] = *src.bindingId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BindingManagementEntryDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingId")) {
		dst.bindingId = obj["bindingId"].as<decltype(dst.bindingId)::value_type>();
	} else {
		dst.bindingId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const BindingManagementEntryDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingId) {
		obj["bindingId"] = *src.bindingId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BindingManagementEntryDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingId")) {
		dst.bindingId = obj["bindingId"].as<decltype(dst.bindingId)::value_type>();
	} else {
		dst.bindingId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const BindingManagementEntryListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingManagementEntryData) {
		obj["bindingManagementEntryData"] = *src.bindingManagementEntryData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BindingManagementEntryListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingManagementEntryData")) {
		dst.bindingManagementEntryData = obj["bindingManagementEntryData"].as<decltype(dst.bindingManagementEntryData)::value_type>();
	} else {
		dst.bindingManagementEntryData = std::nullopt;
	}

}
bool convertToJson(const BindingManagementEntryListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingId) {
		obj["bindingId"] = *src.bindingId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BindingManagementEntryListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingId")) {
		dst.bindingId = obj["bindingId"].as<decltype(dst.bindingId)::value_type>();
	} else {
		dst.bindingId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}

}
bool convertToJson(const BindingManagementRequestCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}
	if (src.serverFeatureType) {
		obj["serverFeatureType"] = *src.serverFeatureType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BindingManagementRequestCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}
	if (obj.containsKey("serverFeatureType")) {
		dst.serverFeatureType = obj["serverFeatureType"].as<decltype(dst.serverFeatureType)::value_type>();
	} else {
		dst.serverFeatureType = std::nullopt;
	}

}
bool convertToJson(const BindingManagementRequestCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}
	if (src.serverFeatureType) {
		obj["serverFeatureType"] = *src.serverFeatureType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BindingManagementRequestCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}
	if (obj.containsKey("serverFeatureType")) {
		dst.serverFeatureType = obj["serverFeatureType"].as<decltype(dst.serverFeatureType)::value_type>();
	} else {
		dst.serverFeatureType = std::nullopt;
	}

}
bool convertToJson(const BindingManagementDeleteCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingId) {
		obj["bindingId"] = *src.bindingId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BindingManagementDeleteCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingId")) {
		dst.bindingId = obj["bindingId"].as<decltype(dst.bindingId)::value_type>();
	} else {
		dst.bindingId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}

}
bool convertToJson(const BindingManagementDeleteCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingId) {
		obj["bindingId"] = *src.bindingId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BindingManagementDeleteCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingId")) {
		dst.bindingId = obj["bindingId"].as<decltype(dst.bindingId)::value_type>();
	} else {
		dst.bindingId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}

}
bool convertToJson(const ActuatorLevelFctType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.actuatorlevelfctenumtype) {
		obj["ActuatorLevelFctEnumType"] = *src.actuatorlevelfctenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ActuatorLevelFctType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ActuatorLevelFctEnumType")) {
		dst.actuatorlevelfctenumtype = obj["ActuatorLevelFctEnumType"].as<decltype(dst.actuatorlevelfctenumtype)::value_type>();
	} else {
		dst.actuatorlevelfctenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ActuatorLevelDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.function) {
		obj["function"] = *src.function;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorLevelDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("function")) {
		dst.function = obj["function"].as<decltype(dst.function)::value_type>();
	} else {
		dst.function = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const ActuatorLevelDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.function) {
		obj["function"] = *src.function;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorLevelDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("function")) {
		dst.function = obj["function"].as<decltype(dst.function)::value_type>();
	} else {
		dst.function = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const ActuatorLevelDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.levelDefaultUnit) {
		obj["levelDefaultUnit"] = *src.levelDefaultUnit;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorLevelDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("levelDefaultUnit")) {
		dst.levelDefaultUnit = obj["levelDefaultUnit"].as<decltype(dst.levelDefaultUnit)::value_type>();
	} else {
		dst.levelDefaultUnit = std::nullopt;
	}

}
bool convertToJson(const ActuatorLevelDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.levelDefaultUnit) {
		obj["levelDefaultUnit"] = *src.levelDefaultUnit;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorLevelDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("levelDefaultUnit")) {
		dst.levelDefaultUnit = obj["levelDefaultUnit"].as<decltype(dst.levelDefaultUnit)::value_type>();
	} else {
		dst.levelDefaultUnit = std::nullopt;
	}

}
bool convertToJson(const ActuatorSwitchFctType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.actuatorswitchfctenumtype) {
		obj["ActuatorSwitchFctEnumType"] = *src.actuatorswitchfctenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ActuatorSwitchFctType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ActuatorSwitchFctEnumType")) {
		dst.actuatorswitchfctenumtype = obj["ActuatorSwitchFctEnumType"].as<decltype(dst.actuatorswitchfctenumtype)::value_type>();
	} else {
		dst.actuatorswitchfctenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const AlarmTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alarmtypeenumtype) {
		obj["AlarmTypeEnumType"] = *src.alarmtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, AlarmTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("AlarmTypeEnumType")) {
		dst.alarmtypeenumtype = obj["AlarmTypeEnumType"].as<decltype(dst.alarmtypeenumtype)::value_type>();
	} else {
		dst.alarmtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const BillTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billtypeenumtype) {
		obj["BillTypeEnumType"] = *src.billtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, BillTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("BillTypeEnumType")) {
		dst.billtypeenumtype = obj["BillTypeEnumType"].as<decltype(dst.billtypeenumtype)::value_type>();
	} else {
		dst.billtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const BillPositionTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billpositiontypeenumtype) {
		obj["BillPositionTypeEnumType"] = *src.billpositiontypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, BillPositionTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("BillPositionTypeEnumType")) {
		dst.billpositiontypeenumtype = obj["BillPositionTypeEnumType"].as<decltype(dst.billpositiontypeenumtype)::value_type>();
	} else {
		dst.billpositiontypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const BillCostTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billcosttypeenumtype) {
		obj["BillCostTypeEnumType"] = *src.billcosttypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, BillCostTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("BillCostTypeEnumType")) {
		dst.billcosttypeenumtype = obj["BillCostTypeEnumType"].as<decltype(dst.billcosttypeenumtype)::value_type>();
	} else {
		dst.billcosttypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const IdentificationTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.identificationtypeenumtype) {
		obj["IdentificationTypeEnumType"] = *src.identificationtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, IdentificationTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("IdentificationTypeEnumType")) {
		dst.identificationtypeenumtype = obj["IdentificationTypeEnumType"].as<decltype(dst.identificationtypeenumtype)::value_type>();
	} else {
		dst.identificationtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const PowerSourceType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powersourceenumtype) {
		obj["PowerSourceEnumType"] = *src.powersourceenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, PowerSourceType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("PowerSourceEnumType")) {
		dst.powersourceenumtype = obj["PowerSourceEnumType"].as<decltype(dst.powersourceenumtype)::value_type>();
	} else {
		dst.powersourceenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const DeviceConfigurationKeyNameType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceconfigurationkeynameenumtype) {
		obj["DeviceConfigurationKeyNameEnumType"] = *src.deviceconfigurationkeynameenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyNameType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("DeviceConfigurationKeyNameEnumType")) {
		dst.deviceconfigurationkeynameenumtype = obj["DeviceConfigurationKeyNameEnumType"].as<decltype(dst.deviceconfigurationkeynameenumtype)::value_type>();
	} else {
		dst.deviceconfigurationkeynameenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const DeviceDiagnosisOperatingStateType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.devicediagnosisoperatingstateenumtype) {
		obj["DeviceDiagnosisOperatingStateEnumType"] = *src.devicediagnosisoperatingstateenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisOperatingStateType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("DeviceDiagnosisOperatingStateEnumType")) {
		dst.devicediagnosisoperatingstateenumtype = obj["DeviceDiagnosisOperatingStateEnumType"].as<decltype(dst.devicediagnosisoperatingstateenumtype)::value_type>();
	} else {
		dst.devicediagnosisoperatingstateenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const PowerSupplyConditionType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.powersupplyconditionenumtype) {
		obj["PowerSupplyConditionEnumType"] = *src.powersupplyconditionenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, PowerSupplyConditionType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("PowerSupplyConditionEnumType")) {
		dst.powersupplyconditionenumtype = obj["PowerSupplyConditionEnumType"].as<decltype(dst.powersupplyconditionenumtype)::value_type>();
	} else {
		dst.powersupplyconditionenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ElectricalConnectionMeasurandVariantType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalconnectionmeasurandvariantenumtype) {
		obj["ElectricalConnectionMeasurandVariantEnumType"] = *src.electricalconnectionmeasurandvariantenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionMeasurandVariantType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ElectricalConnectionMeasurandVariantEnumType")) {
		dst.electricalconnectionmeasurandvariantenumtype = obj["ElectricalConnectionMeasurandVariantEnumType"].as<decltype(dst.electricalconnectionmeasurandvariantenumtype)::value_type>();
	} else {
		dst.electricalconnectionmeasurandvariantenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ElectricalConnectionVoltageTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalconnectionvoltagetypeenumtype) {
		obj["ElectricalConnectionVoltageTypeEnumType"] = *src.electricalconnectionvoltagetypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionVoltageTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ElectricalConnectionVoltageTypeEnumType")) {
		dst.electricalconnectionvoltagetypeenumtype = obj["ElectricalConnectionVoltageTypeEnumType"].as<decltype(dst.electricalconnectionvoltagetypeenumtype)::value_type>();
	} else {
		dst.electricalconnectionvoltagetypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ElectricalConnectionAcMeasurementTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalconnectionacmeasurementtypeenumtype) {
		obj["ElectricalConnectionAcMeasurementTypeEnumType"] = *src.electricalconnectionacmeasurementtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionAcMeasurementTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ElectricalConnectionAcMeasurementTypeEnumType")) {
		dst.electricalconnectionacmeasurementtypeenumtype = obj["ElectricalConnectionAcMeasurementTypeEnumType"].as<decltype(dst.electricalconnectionacmeasurementtypeenumtype)::value_type>();
	} else {
		dst.electricalconnectionacmeasurementtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ElectricalConnectionPhaseNameType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalconnectionphasenameenumtype) {
		obj["ElectricalConnectionPhaseNameEnumType"] = *src.electricalconnectionphasenameenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionPhaseNameType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ElectricalConnectionPhaseNameEnumType")) {
		dst.electricalconnectionphasenameenumtype = obj["ElectricalConnectionPhaseNameEnumType"].as<decltype(dst.electricalconnectionphasenameenumtype)::value_type>();
	} else {
		dst.electricalconnectionphasenameenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ElectricalConnectionCharacteristicContextType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalconnectioncharacteristiccontextenumtype) {
		obj["ElectricalConnectionCharacteristicContextEnumType"] = *src.electricalconnectioncharacteristiccontextenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicContextType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ElectricalConnectionCharacteristicContextEnumType")) {
		dst.electricalconnectioncharacteristiccontextenumtype = obj["ElectricalConnectionCharacteristicContextEnumType"].as<decltype(dst.electricalconnectioncharacteristiccontextenumtype)::value_type>();
	} else {
		dst.electricalconnectioncharacteristiccontextenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const ElectricalConnectionCharacteristicTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalconnectioncharacteristictypeenumtype) {
		obj["ElectricalConnectionCharacteristicTypeEnumType"] = *src.electricalconnectioncharacteristictypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("ElectricalConnectionCharacteristicTypeEnumType")) {
		dst.electricalconnectioncharacteristictypeenumtype = obj["ElectricalConnectionCharacteristicTypeEnumType"].as<decltype(dst.electricalconnectioncharacteristictypeenumtype)::value_type>();
	} else {
		dst.electricalconnectioncharacteristictypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const HvacSystemFunctionTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacsystemfunctiontypeenumtype) {
		obj["HvacSystemFunctionTypeEnumType"] = *src.hvacsystemfunctiontypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("HvacSystemFunctionTypeEnumType")) {
		dst.hvacsystemfunctiontypeenumtype = obj["HvacSystemFunctionTypeEnumType"].as<decltype(dst.hvacsystemfunctiontypeenumtype)::value_type>();
	} else {
		dst.hvacsystemfunctiontypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const HvacOperationModeTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacoperationmodetypeenumtype) {
		obj["HvacOperationModeTypeEnumType"] = *src.hvacoperationmodetypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, HvacOperationModeTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("HvacOperationModeTypeEnumType")) {
		dst.hvacoperationmodetypeenumtype = obj["HvacOperationModeTypeEnumType"].as<decltype(dst.hvacoperationmodetypeenumtype)::value_type>();
	} else {
		dst.hvacoperationmodetypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const HvacOverrunTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacoverruntypeenumtype) {
		obj["HvacOverrunTypeEnumType"] = *src.hvacoverruntypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, HvacOverrunTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("HvacOverrunTypeEnumType")) {
		dst.hvacoverruntypeenumtype = obj["HvacOverrunTypeEnumType"].as<decltype(dst.hvacoverruntypeenumtype)::value_type>();
	} else {
		dst.hvacoverruntypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const HvacOverrunStatusType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacoverrunstatusenumtype) {
		obj["HvacOverrunStatusEnumType"] = *src.hvacoverrunstatusenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, HvacOverrunStatusType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("HvacOverrunStatusEnumType")) {
		dst.hvacoverrunstatusenumtype = obj["HvacOverrunStatusEnumType"].as<decltype(dst.hvacoverrunstatusenumtype)::value_type>();
	} else {
		dst.hvacoverrunstatusenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const SetpointTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointtypeenumtype) {
		obj["SetpointTypeEnumType"] = *src.setpointtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, SetpointTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("SetpointTypeEnumType")) {
		dst.setpointtypeenumtype = obj["SetpointTypeEnumType"].as<decltype(dst.setpointtypeenumtype)::value_type>();
	} else {
		dst.setpointtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const TimeSlotTimeModeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeslottimemodeenumtype) {
		obj["TimeSlotTimeModeEnumType"] = *src.timeslottimemodeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, TimeSlotTimeModeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("TimeSlotTimeModeEnumType")) {
		dst.timeslottimemodeenumtype = obj["TimeSlotTimeModeEnumType"].as<decltype(dst.timeslottimemodeenumtype)::value_type>();
	} else {
		dst.timeslottimemodeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const TierBoundaryTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierboundarytypeenumtype) {
		obj["TierBoundaryTypeEnumType"] = *src.tierboundarytypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, TierBoundaryTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("TierBoundaryTypeEnumType")) {
		dst.tierboundarytypeenumtype = obj["TierBoundaryTypeEnumType"].as<decltype(dst.tierboundarytypeenumtype)::value_type>();
	} else {
		dst.tierboundarytypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const TierTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tiertypeenumtype) {
		obj["TierTypeEnumType"] = *src.tiertypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, TierTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("TierTypeEnumType")) {
		dst.tiertypeenumtype = obj["TierTypeEnumType"].as<decltype(dst.tiertypeenumtype)::value_type>();
	} else {
		dst.tiertypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const IncentiveTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentivetypeenumtype) {
		obj["IncentiveTypeEnumType"] = *src.incentivetypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, IncentiveTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("IncentiveTypeEnumType")) {
		dst.incentivetypeenumtype = obj["IncentiveTypeEnumType"].as<decltype(dst.incentivetypeenumtype)::value_type>();
	} else {
		dst.incentivetypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const IncentiveValueTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentivevaluetypeenumtype) {
		obj["IncentiveValueTypeEnumType"] = *src.incentivevaluetypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, IncentiveValueTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("IncentiveValueTypeEnumType")) {
		dst.incentivevaluetypeenumtype = obj["IncentiveValueTypeEnumType"].as<decltype(dst.incentivevaluetypeenumtype)::value_type>();
	} else {
		dst.incentivevaluetypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const LoadControlEventActionType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadcontroleventactionenumtype) {
		obj["LoadControlEventActionEnumType"] = *src.loadcontroleventactionenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, LoadControlEventActionType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("LoadControlEventActionEnumType")) {
		dst.loadcontroleventactionenumtype = obj["LoadControlEventActionEnumType"].as<decltype(dst.loadcontroleventactionenumtype)::value_type>();
	} else {
		dst.loadcontroleventactionenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const LoadControlEventStateType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadcontroleventstateenumtype) {
		obj["LoadControlEventStateEnumType"] = *src.loadcontroleventstateenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, LoadControlEventStateType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("LoadControlEventStateEnumType")) {
		dst.loadcontroleventstateenumtype = obj["LoadControlEventStateEnumType"].as<decltype(dst.loadcontroleventstateenumtype)::value_type>();
	} else {
		dst.loadcontroleventstateenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const LoadControlLimitTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadcontrollimittypeenumtype) {
		obj["LoadControlLimitTypeEnumType"] = *src.loadcontrollimittypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, LoadControlLimitTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("LoadControlLimitTypeEnumType")) {
		dst.loadcontrollimittypeenumtype = obj["LoadControlLimitTypeEnumType"].as<decltype(dst.loadcontrollimittypeenumtype)::value_type>();
	} else {
		dst.loadcontrollimittypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const LoadControlCategoryType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadcontrolcategoryenumtype) {
		obj["LoadControlCategoryEnumType"] = *src.loadcontrolcategoryenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, LoadControlCategoryType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("LoadControlCategoryEnumType")) {
		dst.loadcontrolcategoryenumtype = obj["LoadControlCategoryEnumType"].as<decltype(dst.loadcontrolcategoryenumtype)::value_type>();
	} else {
		dst.loadcontrolcategoryenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const UseCaseActorType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.usecaseactorenumtype) {
		obj["UseCaseActorEnumType"] = *src.usecaseactorenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, UseCaseActorType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("UseCaseActorEnumType")) {
		dst.usecaseactorenumtype = obj["UseCaseActorEnumType"].as<decltype(dst.usecaseactorenumtype)::value_type>();
	} else {
		dst.usecaseactorenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const UseCaseNameType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.usecasenameenumtype) {
		obj["UseCaseNameEnumType"] = *src.usecasenameenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, UseCaseNameType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("UseCaseNameEnumType")) {
		dst.usecasenameenumtype = obj["UseCaseNameEnumType"].as<decltype(dst.usecasenameenumtype)::value_type>();
	} else {
		dst.usecasenameenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const SensingStateType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sensingstateenumtype) {
		obj["SensingStateEnumType"] = *src.sensingstateenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, SensingStateType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("SensingStateEnumType")) {
		dst.sensingstateenumtype = obj["SensingStateEnumType"].as<decltype(dst.sensingstateenumtype)::value_type>();
	} else {
		dst.sensingstateenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const SensingTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sensingtypeenumtype) {
		obj["SensingTypeEnumType"] = *src.sensingtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, SensingTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("SensingTypeEnumType")) {
		dst.sensingtypeenumtype = obj["SensingTypeEnumType"].as<decltype(dst.sensingtypeenumtype)::value_type>();
	} else {
		dst.sensingtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const StateInformationType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.stateinformationfunctionalityenumtype) {
		obj["StateInformationFunctionalityEnumType"] = *src.stateinformationfunctionalityenumtype;
	}
	if (src.stateinformationfailureenumtype) {
		obj["StateInformationFailureEnumType"] = *src.stateinformationfailureenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, StateInformationType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("StateInformationFunctionalityEnumType")) {
		dst.stateinformationfunctionalityenumtype = obj["StateInformationFunctionalityEnumType"].as<decltype(dst.stateinformationfunctionalityenumtype)::value_type>();
	} else {
		dst.stateinformationfunctionalityenumtype = std::nullopt;
	}
	if (obj.containsKey("StateInformationFailureEnumType")) {
		dst.stateinformationfailureenumtype = obj["StateInformationFailureEnumType"].as<decltype(dst.stateinformationfailureenumtype)::value_type>();
	} else {
		dst.stateinformationfailureenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const StateInformationCategoryType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.stateinformationcategoryenumtype) {
		obj["StateInformationCategoryEnumType"] = *src.stateinformationcategoryenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, StateInformationCategoryType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("StateInformationCategoryEnumType")) {
		dst.stateinformationcategoryenumtype = obj["StateInformationCategoryEnumType"].as<decltype(dst.stateinformationcategoryenumtype)::value_type>();
	} else {
		dst.stateinformationcategoryenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const SupplyConditionEventTypeType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.supplyconditioneventtypeenumtype) {
		obj["SupplyConditionEventTypeEnumType"] = *src.supplyconditioneventtypeenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, SupplyConditionEventTypeType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("SupplyConditionEventTypeEnumType")) {
		dst.supplyconditioneventtypeenumtype = obj["SupplyConditionEventTypeEnumType"].as<decltype(dst.supplyconditioneventtypeenumtype)::value_type>();
	} else {
		dst.supplyconditioneventtypeenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const SupplyConditionOriginatorType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.supplyconditionoriginatorenumtype) {
		obj["SupplyConditionOriginatorEnumType"] = *src.supplyconditionoriginatorenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, SupplyConditionOriginatorType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("SupplyConditionOriginatorEnumType")) {
		dst.supplyconditionoriginatorenumtype = obj["SupplyConditionOriginatorEnumType"].as<decltype(dst.supplyconditionoriginatorenumtype)::value_type>();
	} else {
		dst.supplyconditionoriginatorenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const GridConditionType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.gridconditionenumtype) {
		obj["GridConditionEnumType"] = *src.gridconditionenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, GridConditionType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("GridConditionEnumType")) {
		dst.gridconditionenumtype = obj["GridConditionEnumType"].as<decltype(dst.gridconditionenumtype)::value_type>();
	} else {
		dst.gridconditionenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const TaskManagementJobStateType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.directcontrolactivitystateenumtype) {
		obj["DirectControlActivityStateEnumType"] = *src.directcontrolactivitystateenumtype;
	}
	if (src.hvacoverrunstatusenumtype) {
		obj["HvacOverrunStatusEnumType"] = *src.hvacoverrunstatusenumtype;
	}
	if (src.loadcontroleventstateenumtype) {
		obj["LoadControlEventStateEnumType"] = *src.loadcontroleventstateenumtype;
	}
	if (src.powersequencestateenumtype) {
		obj["PowerSequenceStateEnumType"] = *src.powersequencestateenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, TaskManagementJobStateType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("DirectControlActivityStateEnumType")) {
		dst.directcontrolactivitystateenumtype = obj["DirectControlActivityStateEnumType"].as<decltype(dst.directcontrolactivitystateenumtype)::value_type>();
	} else {
		dst.directcontrolactivitystateenumtype = std::nullopt;
	}
	if (obj.containsKey("HvacOverrunStatusEnumType")) {
		dst.hvacoverrunstatusenumtype = obj["HvacOverrunStatusEnumType"].as<decltype(dst.hvacoverrunstatusenumtype)::value_type>();
	} else {
		dst.hvacoverrunstatusenumtype = std::nullopt;
	}
	if (obj.containsKey("LoadControlEventStateEnumType")) {
		dst.loadcontroleventstateenumtype = obj["LoadControlEventStateEnumType"].as<decltype(dst.loadcontroleventstateenumtype)::value_type>();
	} else {
		dst.loadcontroleventstateenumtype = std::nullopt;
	}
	if (obj.containsKey("PowerSequenceStateEnumType")) {
		dst.powersequencestateenumtype = obj["PowerSequenceStateEnumType"].as<decltype(dst.powersequencestateenumtype)::value_type>();
	} else {
		dst.powersequencestateenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const TaskManagementJobSourceType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.taskmanagementjobsourceenumtype) {
		obj["TaskManagementJobSourceEnumType"] = *src.taskmanagementjobsourceenumtype;
	}
	if (src.enumextendtype) {
		obj["EnumExtendType"] = *src.enumextendtype;
	}

	return true;
};
void convertFromJson(const JsonVariantConst& src, TaskManagementJobSourceType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("TaskManagementJobSourceEnumType")) {
		dst.taskmanagementjobsourceenumtype = obj["TaskManagementJobSourceEnumType"].as<decltype(dst.taskmanagementjobsourceenumtype)::value_type>();
	} else {
		dst.taskmanagementjobsourceenumtype = std::nullopt;
	}
	if (obj.containsKey("EnumExtendType")) {
		dst.enumextendtype = obj["EnumExtendType"].as<decltype(dst.enumextendtype)::value_type>();
	} else {
		dst.enumextendtype = std::nullopt;
	}
};
bool convertToJson(const CmdControlType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.var_delete) {
		obj["delete"] = *src.var_delete;
	}
	if (src.partial) {
		obj["partial"] = *src.partial;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, CmdControlType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("delete")) {
		dst.var_delete = obj["delete"].as<decltype(dst.var_delete)::value_type>();
	} else {
		dst.var_delete = std::nullopt;
	}
	if (obj.containsKey("partial")) {
		dst.partial = obj["partial"].as<decltype(dst.partial)::value_type>();
	} else {
		dst.partial = std::nullopt;
	}

}
bool convertToJson(const CmdType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.PayloadContributionGroup) {
		obj["PayloadContributionGroup"] = *src.PayloadContributionGroup;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, CmdType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("PayloadContributionGroup")) {
		dst.PayloadContributionGroup = obj["PayloadContributionGroup"].as<decltype(dst.PayloadContributionGroup)::value_type>();
	} else {
		dst.PayloadContributionGroup = std::nullopt;
	}

}
bool convertToJson(const ActuatorSwitchDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.function) {
		obj["function"] = *src.function;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorSwitchDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("function")) {
		dst.function = obj["function"].as<decltype(dst.function)::value_type>();
	} else {
		dst.function = std::nullopt;
	}

}
bool convertToJson(const ActuatorSwitchDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.function) {
		obj["function"] = *src.function;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorSwitchDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("function")) {
		dst.function = obj["function"].as<decltype(dst.function)::value_type>();
	} else {
		dst.function = std::nullopt;
	}

}
bool convertToJson(const ActuatorSwitchDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorSwitchDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const ActuatorSwitchDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ActuatorSwitchDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const AlarmDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alarmId) {
		obj["alarmId"] = *src.alarmId;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.alarmType) {
		obj["alarmType"] = *src.alarmType;
	}
	if (src.measuredValue) {
		obj["measuredValue"] = *src.measuredValue;
	}
	if (src.evaluationPeriod) {
		obj["evaluationPeriod"] = *src.evaluationPeriod;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, AlarmDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alarmId")) {
		dst.alarmId = obj["alarmId"].as<decltype(dst.alarmId)::value_type>();
	} else {
		dst.alarmId = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("alarmType")) {
		dst.alarmType = obj["alarmType"].as<decltype(dst.alarmType)::value_type>();
	} else {
		dst.alarmType = std::nullopt;
	}
	if (obj.containsKey("measuredValue")) {
		dst.measuredValue = obj["measuredValue"].as<decltype(dst.measuredValue)::value_type>();
	} else {
		dst.measuredValue = std::nullopt;
	}
	if (obj.containsKey("evaluationPeriod")) {
		dst.evaluationPeriod = obj["evaluationPeriod"].as<decltype(dst.evaluationPeriod)::value_type>();
	} else {
		dst.evaluationPeriod = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const AlarmDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alarmId) {
		obj["alarmId"] = *src.alarmId;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.alarmType) {
		obj["alarmType"] = *src.alarmType;
	}
	if (src.measuredValue) {
		obj["measuredValue"] = *src.measuredValue;
	}
	if (src.evaluationPeriod) {
		obj["evaluationPeriod"] = *src.evaluationPeriod;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, AlarmDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alarmId")) {
		dst.alarmId = obj["alarmId"].as<decltype(dst.alarmId)::value_type>();
	} else {
		dst.alarmId = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("alarmType")) {
		dst.alarmType = obj["alarmType"].as<decltype(dst.alarmType)::value_type>();
	} else {
		dst.alarmType = std::nullopt;
	}
	if (obj.containsKey("measuredValue")) {
		dst.measuredValue = obj["measuredValue"].as<decltype(dst.measuredValue)::value_type>();
	} else {
		dst.measuredValue = std::nullopt;
	}
	if (obj.containsKey("evaluationPeriod")) {
		dst.evaluationPeriod = obj["evaluationPeriod"].as<decltype(dst.evaluationPeriod)::value_type>();
	} else {
		dst.evaluationPeriod = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const AlarmListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alarmData) {
		obj["alarmData"] = *src.alarmData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, AlarmListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alarmData")) {
		dst.alarmData = obj["alarmData"].as<decltype(dst.alarmData)::value_type>();
	} else {
		dst.alarmData = std::nullopt;
	}

}
bool convertToJson(const AlarmListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alarmId) {
		obj["alarmId"] = *src.alarmId;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, AlarmListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alarmId")) {
		dst.alarmId = obj["alarmId"].as<decltype(dst.alarmId)::value_type>();
	} else {
		dst.alarmId = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const BillValueType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.valueId) {
		obj["valueId"] = *src.valueId;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.valuePercentage) {
		obj["valuePercentage"] = *src.valuePercentage;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillValueType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("valueId")) {
		dst.valueId = obj["valueId"].as<decltype(dst.valueId)::value_type>();
	} else {
		dst.valueId = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("valuePercentage")) {
		dst.valuePercentage = obj["valuePercentage"].as<decltype(dst.valuePercentage)::value_type>();
	} else {
		dst.valuePercentage = std::nullopt;
	}

}
bool convertToJson(const BillValueElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.valueId) {
		obj["valueId"] = *src.valueId;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.valuePercentage) {
		obj["valuePercentage"] = *src.valuePercentage;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillValueElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("valueId")) {
		dst.valueId = obj["valueId"].as<decltype(dst.valueId)::value_type>();
	} else {
		dst.valueId = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("valuePercentage")) {
		dst.valuePercentage = obj["valuePercentage"].as<decltype(dst.valuePercentage)::value_type>();
	} else {
		dst.valuePercentage = std::nullopt;
	}

}
bool convertToJson(const BillCostType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.costId) {
		obj["costId"] = *src.costId;
	}
	if (src.costType) {
		obj["costType"] = *src.costType;
	}
	if (src.valueId) {
		obj["valueId"] = *src.valueId;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}
	if (src.cost) {
		obj["cost"] = *src.cost;
	}
	if (src.costPercentage) {
		obj["costPercentage"] = *src.costPercentage;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillCostType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("costId")) {
		dst.costId = obj["costId"].as<decltype(dst.costId)::value_type>();
	} else {
		dst.costId = std::nullopt;
	}
	if (obj.containsKey("costType")) {
		dst.costType = obj["costType"].as<decltype(dst.costType)::value_type>();
	} else {
		dst.costType = std::nullopt;
	}
	if (obj.containsKey("valueId")) {
		dst.valueId = obj["valueId"].as<decltype(dst.valueId)::value_type>();
	} else {
		dst.valueId = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}
	if (obj.containsKey("cost")) {
		dst.cost = obj["cost"].as<decltype(dst.cost)::value_type>();
	} else {
		dst.cost = std::nullopt;
	}
	if (obj.containsKey("costPercentage")) {
		dst.costPercentage = obj["costPercentage"].as<decltype(dst.costPercentage)::value_type>();
	} else {
		dst.costPercentage = std::nullopt;
	}

}
bool convertToJson(const BillCostElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.costId) {
		obj["costId"] = *src.costId;
	}
	if (src.costType) {
		obj["costType"] = *src.costType;
	}
	if (src.valueId) {
		obj["valueId"] = *src.valueId;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}
	if (src.cost) {
		obj["cost"] = *src.cost;
	}
	if (src.costPercentage) {
		obj["costPercentage"] = *src.costPercentage;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillCostElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("costId")) {
		dst.costId = obj["costId"].as<decltype(dst.costId)::value_type>();
	} else {
		dst.costId = std::nullopt;
	}
	if (obj.containsKey("costType")) {
		dst.costType = obj["costType"].as<decltype(dst.costType)::value_type>();
	} else {
		dst.costType = std::nullopt;
	}
	if (obj.containsKey("valueId")) {
		dst.valueId = obj["valueId"].as<decltype(dst.valueId)::value_type>();
	} else {
		dst.valueId = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}
	if (obj.containsKey("cost")) {
		dst.cost = obj["cost"].as<decltype(dst.cost)::value_type>();
	} else {
		dst.cost = std::nullopt;
	}
	if (obj.containsKey("costPercentage")) {
		dst.costPercentage = obj["costPercentage"].as<decltype(dst.costPercentage)::value_type>();
	} else {
		dst.costPercentage = std::nullopt;
	}

}
bool convertToJson(const BillPositionType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.positionId) {
		obj["positionId"] = *src.positionId;
	}
	if (src.positionType) {
		obj["positionType"] = *src.positionType;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.cost) {
		obj["cost"] = *src.cost;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillPositionType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("positionId")) {
		dst.positionId = obj["positionId"].as<decltype(dst.positionId)::value_type>();
	} else {
		dst.positionId = std::nullopt;
	}
	if (obj.containsKey("positionType")) {
		dst.positionType = obj["positionType"].as<decltype(dst.positionType)::value_type>();
	} else {
		dst.positionType = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("cost")) {
		dst.cost = obj["cost"].as<decltype(dst.cost)::value_type>();
	} else {
		dst.cost = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const BillPositionElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.positionId) {
		obj["positionId"] = *src.positionId;
	}
	if (src.positionType) {
		obj["positionType"] = *src.positionType;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.cost) {
		obj["cost"] = *src.cost;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillPositionElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("positionId")) {
		dst.positionId = obj["positionId"].as<decltype(dst.positionId)::value_type>();
	} else {
		dst.positionId = std::nullopt;
	}
	if (obj.containsKey("positionType")) {
		dst.positionType = obj["positionType"].as<decltype(dst.positionType)::value_type>();
	} else {
		dst.positionType = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("cost")) {
		dst.cost = obj["cost"].as<decltype(dst.cost)::value_type>();
	} else {
		dst.cost = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const BillDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}
	if (src.billType) {
		obj["billType"] = *src.billType;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.total) {
		obj["total"] = *src.total;
	}
	if (src.position) {
		obj["position"] = *src.position;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}
	if (obj.containsKey("billType")) {
		dst.billType = obj["billType"].as<decltype(dst.billType)::value_type>();
	} else {
		dst.billType = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("total")) {
		dst.total = obj["total"].as<decltype(dst.total)::value_type>();
	} else {
		dst.total = std::nullopt;
	}
	if (obj.containsKey("position")) {
		dst.position = obj["position"].as<decltype(dst.position)::value_type>();
	} else {
		dst.position = std::nullopt;
	}

}
bool convertToJson(const BillDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}
	if (src.billType) {
		obj["billType"] = *src.billType;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.total) {
		obj["total"] = *src.total;
	}
	if (src.position) {
		obj["position"] = *src.position;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}
	if (obj.containsKey("billType")) {
		dst.billType = obj["billType"].as<decltype(dst.billType)::value_type>();
	} else {
		dst.billType = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("total")) {
		dst.total = obj["total"].as<decltype(dst.total)::value_type>();
	} else {
		dst.total = std::nullopt;
	}
	if (obj.containsKey("position")) {
		dst.position = obj["position"].as<decltype(dst.position)::value_type>();
	} else {
		dst.position = std::nullopt;
	}

}
bool convertToJson(const BillListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billData) {
		obj["billData"] = *src.billData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billData")) {
		dst.billData = obj["billData"].as<decltype(dst.billData)::value_type>();
	} else {
		dst.billData = std::nullopt;
	}

}
bool convertToJson(const BillListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const BillConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}
	if (src.positionCountMin) {
		obj["positionCountMin"] = *src.positionCountMin;
	}
	if (src.positionCountMax) {
		obj["positionCountMax"] = *src.positionCountMax;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}
	if (obj.containsKey("positionCountMin")) {
		dst.positionCountMin = obj["positionCountMin"].as<decltype(dst.positionCountMin)::value_type>();
	} else {
		dst.positionCountMin = std::nullopt;
	}
	if (obj.containsKey("positionCountMax")) {
		dst.positionCountMax = obj["positionCountMax"].as<decltype(dst.positionCountMax)::value_type>();
	} else {
		dst.positionCountMax = std::nullopt;
	}

}
bool convertToJson(const BillConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}
	if (src.positionCountMin) {
		obj["positionCountMin"] = *src.positionCountMin;
	}
	if (src.positionCountMax) {
		obj["positionCountMax"] = *src.positionCountMax;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}
	if (obj.containsKey("positionCountMin")) {
		dst.positionCountMin = obj["positionCountMin"].as<decltype(dst.positionCountMin)::value_type>();
	} else {
		dst.positionCountMin = std::nullopt;
	}
	if (obj.containsKey("positionCountMax")) {
		dst.positionCountMax = obj["positionCountMax"].as<decltype(dst.positionCountMax)::value_type>();
	} else {
		dst.positionCountMax = std::nullopt;
	}

}
bool convertToJson(const BillConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billConstraintsData) {
		obj["billConstraintsData"] = *src.billConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billConstraintsData")) {
		dst.billConstraintsData = obj["billConstraintsData"].as<decltype(dst.billConstraintsData)::value_type>();
	} else {
		dst.billConstraintsData = std::nullopt;
	}

}
bool convertToJson(const BillConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}

}
bool convertToJson(const BillDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}
	if (src.billWriteable) {
		obj["billWriteable"] = *src.billWriteable;
	}
	if (src.updateRequired) {
		obj["updateRequired"] = *src.updateRequired;
	}
	if (src.supportedBillType) {
		obj["supportedBillType"] = *src.supportedBillType;
	}
	if (src.sessionId) {
		obj["sessionId"] = *src.sessionId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}
	if (obj.containsKey("billWriteable")) {
		dst.billWriteable = obj["billWriteable"].as<decltype(dst.billWriteable)::value_type>();
	} else {
		dst.billWriteable = std::nullopt;
	}
	if (obj.containsKey("updateRequired")) {
		dst.updateRequired = obj["updateRequired"].as<decltype(dst.updateRequired)::value_type>();
	} else {
		dst.updateRequired = std::nullopt;
	}
	if (obj.containsKey("supportedBillType")) {
		dst.supportedBillType = obj["supportedBillType"].as<decltype(dst.supportedBillType)::value_type>();
	} else {
		dst.supportedBillType = std::nullopt;
	}
	if (obj.containsKey("sessionId")) {
		dst.sessionId = obj["sessionId"].as<decltype(dst.sessionId)::value_type>();
	} else {
		dst.sessionId = std::nullopt;
	}

}
bool convertToJson(const BillDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}
	if (src.billWriteable) {
		obj["billWriteable"] = *src.billWriteable;
	}
	if (src.updateRequired) {
		obj["updateRequired"] = *src.updateRequired;
	}
	if (src.supportedBillType) {
		obj["supportedBillType"] = *src.supportedBillType;
	}
	if (src.sessionId) {
		obj["sessionId"] = *src.sessionId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}
	if (obj.containsKey("billWriteable")) {
		dst.billWriteable = obj["billWriteable"].as<decltype(dst.billWriteable)::value_type>();
	} else {
		dst.billWriteable = std::nullopt;
	}
	if (obj.containsKey("updateRequired")) {
		dst.updateRequired = obj["updateRequired"].as<decltype(dst.updateRequired)::value_type>();
	} else {
		dst.updateRequired = std::nullopt;
	}
	if (obj.containsKey("supportedBillType")) {
		dst.supportedBillType = obj["supportedBillType"].as<decltype(dst.supportedBillType)::value_type>();
	} else {
		dst.supportedBillType = std::nullopt;
	}
	if (obj.containsKey("sessionId")) {
		dst.sessionId = obj["sessionId"].as<decltype(dst.sessionId)::value_type>();
	} else {
		dst.sessionId = std::nullopt;
	}

}
bool convertToJson(const BillDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billDescriptionData) {
		obj["billDescriptionData"] = *src.billDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billDescriptionData")) {
		dst.billDescriptionData = obj["billDescriptionData"].as<decltype(dst.billDescriptionData)::value_type>();
	} else {
		dst.billDescriptionData = std::nullopt;
	}

}
bool convertToJson(const BillDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.billId) {
		obj["billId"] = *src.billId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, BillDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("billId")) {
		dst.billId = obj["billId"].as<decltype(dst.billId)::value_type>();
	} else {
		dst.billId = std::nullopt;
	}

}
bool convertToJson(const IdentificationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.identificationId) {
		obj["identificationId"] = *src.identificationId;
	}
	if (src.identificationType) {
		obj["identificationType"] = *src.identificationType;
	}
	if (src.identificationValue) {
		obj["identificationValue"] = *src.identificationValue;
	}
	if (src.authorized) {
		obj["authorized"] = *src.authorized;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IdentificationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("identificationId")) {
		dst.identificationId = obj["identificationId"].as<decltype(dst.identificationId)::value_type>();
	} else {
		dst.identificationId = std::nullopt;
	}
	if (obj.containsKey("identificationType")) {
		dst.identificationType = obj["identificationType"].as<decltype(dst.identificationType)::value_type>();
	} else {
		dst.identificationType = std::nullopt;
	}
	if (obj.containsKey("identificationValue")) {
		dst.identificationValue = obj["identificationValue"].as<decltype(dst.identificationValue)::value_type>();
	} else {
		dst.identificationValue = std::nullopt;
	}
	if (obj.containsKey("authorized")) {
		dst.authorized = obj["authorized"].as<decltype(dst.authorized)::value_type>();
	} else {
		dst.authorized = std::nullopt;
	}

}
bool convertToJson(const IdentificationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.identificationId) {
		obj["identificationId"] = *src.identificationId;
	}
	if (src.identificationType) {
		obj["identificationType"] = *src.identificationType;
	}
	if (src.identificationValue) {
		obj["identificationValue"] = *src.identificationValue;
	}
	if (src.authorized) {
		obj["authorized"] = *src.authorized;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IdentificationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("identificationId")) {
		dst.identificationId = obj["identificationId"].as<decltype(dst.identificationId)::value_type>();
	} else {
		dst.identificationId = std::nullopt;
	}
	if (obj.containsKey("identificationType")) {
		dst.identificationType = obj["identificationType"].as<decltype(dst.identificationType)::value_type>();
	} else {
		dst.identificationType = std::nullopt;
	}
	if (obj.containsKey("identificationValue")) {
		dst.identificationValue = obj["identificationValue"].as<decltype(dst.identificationValue)::value_type>();
	} else {
		dst.identificationValue = std::nullopt;
	}
	if (obj.containsKey("authorized")) {
		dst.authorized = obj["authorized"].as<decltype(dst.authorized)::value_type>();
	} else {
		dst.authorized = std::nullopt;
	}

}
bool convertToJson(const IdentificationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.identificationData) {
		obj["identificationData"] = *src.identificationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IdentificationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("identificationData")) {
		dst.identificationData = obj["identificationData"].as<decltype(dst.identificationData)::value_type>();
	} else {
		dst.identificationData = std::nullopt;
	}

}
bool convertToJson(const IdentificationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.identificationId) {
		obj["identificationId"] = *src.identificationId;
	}
	if (src.identificationType) {
		obj["identificationType"] = *src.identificationType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IdentificationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("identificationId")) {
		dst.identificationId = obj["identificationId"].as<decltype(dst.identificationId)::value_type>();
	} else {
		dst.identificationId = std::nullopt;
	}
	if (obj.containsKey("identificationType")) {
		dst.identificationType = obj["identificationType"].as<decltype(dst.identificationType)::value_type>();
	} else {
		dst.identificationType = std::nullopt;
	}

}
bool convertToJson(const SessionIdentificationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sessionId) {
		obj["sessionId"] = *src.sessionId;
	}
	if (src.identificationId) {
		obj["identificationId"] = *src.identificationId;
	}
	if (src.isLatestSession) {
		obj["isLatestSession"] = *src.isLatestSession;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SessionIdentificationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sessionId")) {
		dst.sessionId = obj["sessionId"].as<decltype(dst.sessionId)::value_type>();
	} else {
		dst.sessionId = std::nullopt;
	}
	if (obj.containsKey("identificationId")) {
		dst.identificationId = obj["identificationId"].as<decltype(dst.identificationId)::value_type>();
	} else {
		dst.identificationId = std::nullopt;
	}
	if (obj.containsKey("isLatestSession")) {
		dst.isLatestSession = obj["isLatestSession"].as<decltype(dst.isLatestSession)::value_type>();
	} else {
		dst.isLatestSession = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}

}
bool convertToJson(const SessionIdentificationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sessionId) {
		obj["sessionId"] = *src.sessionId;
	}
	if (src.identificationId) {
		obj["identificationId"] = *src.identificationId;
	}
	if (src.isLatestSession) {
		obj["isLatestSession"] = *src.isLatestSession;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SessionIdentificationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sessionId")) {
		dst.sessionId = obj["sessionId"].as<decltype(dst.sessionId)::value_type>();
	} else {
		dst.sessionId = std::nullopt;
	}
	if (obj.containsKey("identificationId")) {
		dst.identificationId = obj["identificationId"].as<decltype(dst.identificationId)::value_type>();
	} else {
		dst.identificationId = std::nullopt;
	}
	if (obj.containsKey("isLatestSession")) {
		dst.isLatestSession = obj["isLatestSession"].as<decltype(dst.isLatestSession)::value_type>();
	} else {
		dst.isLatestSession = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}

}
bool convertToJson(const SessionIdentificationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sessionIdentificationData) {
		obj["sessionIdentificationData"] = *src.sessionIdentificationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SessionIdentificationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sessionIdentificationData")) {
		dst.sessionIdentificationData = obj["sessionIdentificationData"].as<decltype(dst.sessionIdentificationData)::value_type>();
	} else {
		dst.sessionIdentificationData = std::nullopt;
	}

}
bool convertToJson(const SessionIdentificationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sessionId) {
		obj["sessionId"] = *src.sessionId;
	}
	if (src.identificationId) {
		obj["identificationId"] = *src.identificationId;
	}
	if (src.isLatestSession) {
		obj["isLatestSession"] = *src.isLatestSession;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SessionIdentificationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sessionId")) {
		dst.sessionId = obj["sessionId"].as<decltype(dst.sessionId)::value_type>();
	} else {
		dst.sessionId = std::nullopt;
	}
	if (obj.containsKey("identificationId")) {
		dst.identificationId = obj["identificationId"].as<decltype(dst.identificationId)::value_type>();
	} else {
		dst.identificationId = std::nullopt;
	}
	if (obj.containsKey("isLatestSession")) {
		dst.isLatestSession = obj["isLatestSession"].as<decltype(dst.isLatestSession)::value_type>();
	} else {
		dst.isLatestSession = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}

}
bool convertToJson(const SessionMeasurementRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sessionId) {
		obj["sessionId"] = *src.sessionId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SessionMeasurementRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sessionId")) {
		dst.sessionId = obj["sessionId"].as<decltype(dst.sessionId)::value_type>();
	} else {
		dst.sessionId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}

}
bool convertToJson(const SessionMeasurementRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sessionId) {
		obj["sessionId"] = *src.sessionId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SessionMeasurementRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sessionId")) {
		dst.sessionId = obj["sessionId"].as<decltype(dst.sessionId)::value_type>();
	} else {
		dst.sessionId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}

}
bool convertToJson(const SessionMeasurementRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sessionMeasurementRelationData) {
		obj["sessionMeasurementRelationData"] = *src.sessionMeasurementRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SessionMeasurementRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sessionMeasurementRelationData")) {
		dst.sessionMeasurementRelationData = obj["sessionMeasurementRelationData"].as<decltype(dst.sessionMeasurementRelationData)::value_type>();
	} else {
		dst.sessionMeasurementRelationData = std::nullopt;
	}

}
bool convertToJson(const SessionMeasurementRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sessionId) {
		obj["sessionId"] = *src.sessionId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SessionMeasurementRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sessionId")) {
		dst.sessionId = obj["sessionId"].as<decltype(dst.sessionId)::value_type>();
	} else {
		dst.sessionId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}

}
bool convertToJson(const DataTunnelingHeaderType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.purposeId) {
		obj["purposeId"] = *src.purposeId;
	}
	if (src.channelId) {
		obj["channelId"] = *src.channelId;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DataTunnelingHeaderType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("purposeId")) {
		dst.purposeId = obj["purposeId"].as<decltype(dst.purposeId)::value_type>();
	} else {
		dst.purposeId = std::nullopt;
	}
	if (obj.containsKey("channelId")) {
		dst.channelId = obj["channelId"].as<decltype(dst.channelId)::value_type>();
	} else {
		dst.channelId = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const DataTunnelingHeaderElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.purposeId) {
		obj["purposeId"] = *src.purposeId;
	}
	if (src.channelId) {
		obj["channelId"] = *src.channelId;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DataTunnelingHeaderElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("purposeId")) {
		dst.purposeId = obj["purposeId"].as<decltype(dst.purposeId)::value_type>();
	} else {
		dst.purposeId = std::nullopt;
	}
	if (obj.containsKey("channelId")) {
		dst.channelId = obj["channelId"].as<decltype(dst.channelId)::value_type>();
	} else {
		dst.channelId = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const DataTunnelingCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.header) {
		obj["header"] = *src.header;
	}
	if (src.payload) {
		obj["payload"] = *src.payload;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DataTunnelingCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("header")) {
		dst.header = obj["header"].as<decltype(dst.header)::value_type>();
	} else {
		dst.header = std::nullopt;
	}
	if (obj.containsKey("payload")) {
		dst.payload = obj["payload"].as<decltype(dst.payload)::value_type>();
	} else {
		dst.payload = std::nullopt;
	}

}
bool convertToJson(const DataTunnelingCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.header) {
		obj["header"] = *src.header;
	}
	if (src.payload) {
		obj["payload"] = *src.payload;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DataTunnelingCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("header")) {
		dst.header = obj["header"].as<decltype(dst.header)::value_type>();
	} else {
		dst.header = std::nullopt;
	}
	if (obj.containsKey("payload")) {
		dst.payload = obj["payload"].as<decltype(dst.payload)::value_type>();
	} else {
		dst.payload = std::nullopt;
	}

}
bool convertToJson(const DeviceClassificationManufacturerDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceName) {
		obj["deviceName"] = *src.deviceName;
	}
	if (src.deviceCode) {
		obj["deviceCode"] = *src.deviceCode;
	}
	if (src.serialNumber) {
		obj["serialNumber"] = *src.serialNumber;
	}
	if (src.softwareRevision) {
		obj["softwareRevision"] = *src.softwareRevision;
	}
	if (src.hardwareRevision) {
		obj["hardwareRevision"] = *src.hardwareRevision;
	}
	if (src.vendorName) {
		obj["vendorName"] = *src.vendorName;
	}
	if (src.vendorCode) {
		obj["vendorCode"] = *src.vendorCode;
	}
	if (src.brandName) {
		obj["brandName"] = *src.brandName;
	}
	if (src.powerSource) {
		obj["powerSource"] = *src.powerSource;
	}
	if (src.manufacturerNodeIdentification) {
		obj["manufacturerNodeIdentification"] = *src.manufacturerNodeIdentification;
	}
	if (src.manufacturerLabel) {
		obj["manufacturerLabel"] = *src.manufacturerLabel;
	}
	if (src.manufacturerDescription) {
		obj["manufacturerDescription"] = *src.manufacturerDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceClassificationManufacturerDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceName")) {
		dst.deviceName = obj["deviceName"].as<decltype(dst.deviceName)::value_type>();
	} else {
		dst.deviceName = std::nullopt;
	}
	if (obj.containsKey("deviceCode")) {
		dst.deviceCode = obj["deviceCode"].as<decltype(dst.deviceCode)::value_type>();
	} else {
		dst.deviceCode = std::nullopt;
	}
	if (obj.containsKey("serialNumber")) {
		dst.serialNumber = obj["serialNumber"].as<decltype(dst.serialNumber)::value_type>();
	} else {
		dst.serialNumber = std::nullopt;
	}
	if (obj.containsKey("softwareRevision")) {
		dst.softwareRevision = obj["softwareRevision"].as<decltype(dst.softwareRevision)::value_type>();
	} else {
		dst.softwareRevision = std::nullopt;
	}
	if (obj.containsKey("hardwareRevision")) {
		dst.hardwareRevision = obj["hardwareRevision"].as<decltype(dst.hardwareRevision)::value_type>();
	} else {
		dst.hardwareRevision = std::nullopt;
	}
	if (obj.containsKey("vendorName")) {
		dst.vendorName = obj["vendorName"].as<decltype(dst.vendorName)::value_type>();
	} else {
		dst.vendorName = std::nullopt;
	}
	if (obj.containsKey("vendorCode")) {
		dst.vendorCode = obj["vendorCode"].as<decltype(dst.vendorCode)::value_type>();
	} else {
		dst.vendorCode = std::nullopt;
	}
	if (obj.containsKey("brandName")) {
		dst.brandName = obj["brandName"].as<decltype(dst.brandName)::value_type>();
	} else {
		dst.brandName = std::nullopt;
	}
	if (obj.containsKey("powerSource")) {
		dst.powerSource = obj["powerSource"].as<decltype(dst.powerSource)::value_type>();
	} else {
		dst.powerSource = std::nullopt;
	}
	if (obj.containsKey("manufacturerNodeIdentification")) {
		dst.manufacturerNodeIdentification = obj["manufacturerNodeIdentification"].as<decltype(dst.manufacturerNodeIdentification)::value_type>();
	} else {
		dst.manufacturerNodeIdentification = std::nullopt;
	}
	if (obj.containsKey("manufacturerLabel")) {
		dst.manufacturerLabel = obj["manufacturerLabel"].as<decltype(dst.manufacturerLabel)::value_type>();
	} else {
		dst.manufacturerLabel = std::nullopt;
	}
	if (obj.containsKey("manufacturerDescription")) {
		dst.manufacturerDescription = obj["manufacturerDescription"].as<decltype(dst.manufacturerDescription)::value_type>();
	} else {
		dst.manufacturerDescription = std::nullopt;
	}

}
bool convertToJson(const DeviceClassificationManufacturerDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceName) {
		obj["deviceName"] = *src.deviceName;
	}
	if (src.deviceCode) {
		obj["deviceCode"] = *src.deviceCode;
	}
	if (src.serialNumber) {
		obj["serialNumber"] = *src.serialNumber;
	}
	if (src.softwareRevision) {
		obj["softwareRevision"] = *src.softwareRevision;
	}
	if (src.hardwareRevision) {
		obj["hardwareRevision"] = *src.hardwareRevision;
	}
	if (src.vendorName) {
		obj["vendorName"] = *src.vendorName;
	}
	if (src.vendorCode) {
		obj["vendorCode"] = *src.vendorCode;
	}
	if (src.brandName) {
		obj["brandName"] = *src.brandName;
	}
	if (src.powerSource) {
		obj["powerSource"] = *src.powerSource;
	}
	if (src.manufacturerNodeIdentification) {
		obj["manufacturerNodeIdentification"] = *src.manufacturerNodeIdentification;
	}
	if (src.manufacturerLabel) {
		obj["manufacturerLabel"] = *src.manufacturerLabel;
	}
	if (src.manufacturerDescription) {
		obj["manufacturerDescription"] = *src.manufacturerDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceClassificationManufacturerDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceName")) {
		dst.deviceName = obj["deviceName"].as<decltype(dst.deviceName)::value_type>();
	} else {
		dst.deviceName = std::nullopt;
	}
	if (obj.containsKey("deviceCode")) {
		dst.deviceCode = obj["deviceCode"].as<decltype(dst.deviceCode)::value_type>();
	} else {
		dst.deviceCode = std::nullopt;
	}
	if (obj.containsKey("serialNumber")) {
		dst.serialNumber = obj["serialNumber"].as<decltype(dst.serialNumber)::value_type>();
	} else {
		dst.serialNumber = std::nullopt;
	}
	if (obj.containsKey("softwareRevision")) {
		dst.softwareRevision = obj["softwareRevision"].as<decltype(dst.softwareRevision)::value_type>();
	} else {
		dst.softwareRevision = std::nullopt;
	}
	if (obj.containsKey("hardwareRevision")) {
		dst.hardwareRevision = obj["hardwareRevision"].as<decltype(dst.hardwareRevision)::value_type>();
	} else {
		dst.hardwareRevision = std::nullopt;
	}
	if (obj.containsKey("vendorName")) {
		dst.vendorName = obj["vendorName"].as<decltype(dst.vendorName)::value_type>();
	} else {
		dst.vendorName = std::nullopt;
	}
	if (obj.containsKey("vendorCode")) {
		dst.vendorCode = obj["vendorCode"].as<decltype(dst.vendorCode)::value_type>();
	} else {
		dst.vendorCode = std::nullopt;
	}
	if (obj.containsKey("brandName")) {
		dst.brandName = obj["brandName"].as<decltype(dst.brandName)::value_type>();
	} else {
		dst.brandName = std::nullopt;
	}
	if (obj.containsKey("powerSource")) {
		dst.powerSource = obj["powerSource"].as<decltype(dst.powerSource)::value_type>();
	} else {
		dst.powerSource = std::nullopt;
	}
	if (obj.containsKey("manufacturerNodeIdentification")) {
		dst.manufacturerNodeIdentification = obj["manufacturerNodeIdentification"].as<decltype(dst.manufacturerNodeIdentification)::value_type>();
	} else {
		dst.manufacturerNodeIdentification = std::nullopt;
	}
	if (obj.containsKey("manufacturerLabel")) {
		dst.manufacturerLabel = obj["manufacturerLabel"].as<decltype(dst.manufacturerLabel)::value_type>();
	} else {
		dst.manufacturerLabel = std::nullopt;
	}
	if (obj.containsKey("manufacturerDescription")) {
		dst.manufacturerDescription = obj["manufacturerDescription"].as<decltype(dst.manufacturerDescription)::value_type>();
	} else {
		dst.manufacturerDescription = std::nullopt;
	}

}
bool convertToJson(const DeviceClassificationUserDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.userNodeIdentification) {
		obj["userNodeIdentification"] = *src.userNodeIdentification;
	}
	if (src.userLabel) {
		obj["userLabel"] = *src.userLabel;
	}
	if (src.userDescription) {
		obj["userDescription"] = *src.userDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceClassificationUserDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("userNodeIdentification")) {
		dst.userNodeIdentification = obj["userNodeIdentification"].as<decltype(dst.userNodeIdentification)::value_type>();
	} else {
		dst.userNodeIdentification = std::nullopt;
	}
	if (obj.containsKey("userLabel")) {
		dst.userLabel = obj["userLabel"].as<decltype(dst.userLabel)::value_type>();
	} else {
		dst.userLabel = std::nullopt;
	}
	if (obj.containsKey("userDescription")) {
		dst.userDescription = obj["userDescription"].as<decltype(dst.userDescription)::value_type>();
	} else {
		dst.userDescription = std::nullopt;
	}

}
bool convertToJson(const DeviceClassificationUserDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.userNodeIdentification) {
		obj["userNodeIdentification"] = *src.userNodeIdentification;
	}
	if (src.userLabel) {
		obj["userLabel"] = *src.userLabel;
	}
	if (src.userDescription) {
		obj["userDescription"] = *src.userDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceClassificationUserDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("userNodeIdentification")) {
		dst.userNodeIdentification = obj["userNodeIdentification"].as<decltype(dst.userNodeIdentification)::value_type>();
	} else {
		dst.userNodeIdentification = std::nullopt;
	}
	if (obj.containsKey("userLabel")) {
		dst.userLabel = obj["userLabel"].as<decltype(dst.userLabel)::value_type>();
	} else {
		dst.userLabel = std::nullopt;
	}
	if (obj.containsKey("userDescription")) {
		dst.userDescription = obj["userDescription"].as<decltype(dst.userDescription)::value_type>();
	} else {
		dst.userDescription = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueValueType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.boolean) {
		obj["boolean"] = *src.boolean;
	}
	if (src.date) {
		obj["date"] = *src.date;
	}
	if (src.dateTime) {
		obj["dateTime"] = *src.dateTime;
	}
	if (src.duration) {
		obj["duration"] = *src.duration;
	}
	if (src.string) {
		obj["string"] = *src.string;
	}
	if (src.time) {
		obj["time"] = *src.time;
	}
	if (src.scaledNumber) {
		obj["scaledNumber"] = *src.scaledNumber;
	}
	if (src.integer) {
		obj["integer"] = *src.integer;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueValueType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("boolean")) {
		dst.boolean = obj["boolean"].as<decltype(dst.boolean)::value_type>();
	} else {
		dst.boolean = std::nullopt;
	}
	if (obj.containsKey("date")) {
		dst.date = obj["date"].as<decltype(dst.date)::value_type>();
	} else {
		dst.date = std::nullopt;
	}
	if (obj.containsKey("dateTime")) {
		dst.dateTime = obj["dateTime"].as<decltype(dst.dateTime)::value_type>();
	} else {
		dst.dateTime = std::nullopt;
	}
	if (obj.containsKey("duration")) {
		dst.duration = obj["duration"].as<decltype(dst.duration)::value_type>();
	} else {
		dst.duration = std::nullopt;
	}
	if (obj.containsKey("string")) {
		dst.string = obj["string"].as<decltype(dst.string)::value_type>();
	} else {
		dst.string = std::nullopt;
	}
	if (obj.containsKey("time")) {
		dst.time = obj["time"].as<decltype(dst.time)::value_type>();
	} else {
		dst.time = std::nullopt;
	}
	if (obj.containsKey("scaledNumber")) {
		dst.scaledNumber = obj["scaledNumber"].as<decltype(dst.scaledNumber)::value_type>();
	} else {
		dst.scaledNumber = std::nullopt;
	}
	if (obj.containsKey("integer")) {
		dst.integer = obj["integer"].as<decltype(dst.integer)::value_type>();
	} else {
		dst.integer = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueValueElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.boolean) {
		obj["boolean"] = *src.boolean;
	}
	if (src.date) {
		obj["date"] = *src.date;
	}
	if (src.dateTime) {
		obj["dateTime"] = *src.dateTime;
	}
	if (src.duration) {
		obj["duration"] = *src.duration;
	}
	if (src.string) {
		obj["string"] = *src.string;
	}
	if (src.time) {
		obj["time"] = *src.time;
	}
	if (src.scaledNumber) {
		obj["scaledNumber"] = *src.scaledNumber;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueValueElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("boolean")) {
		dst.boolean = obj["boolean"].as<decltype(dst.boolean)::value_type>();
	} else {
		dst.boolean = std::nullopt;
	}
	if (obj.containsKey("date")) {
		dst.date = obj["date"].as<decltype(dst.date)::value_type>();
	} else {
		dst.date = std::nullopt;
	}
	if (obj.containsKey("dateTime")) {
		dst.dateTime = obj["dateTime"].as<decltype(dst.dateTime)::value_type>();
	} else {
		dst.dateTime = std::nullopt;
	}
	if (obj.containsKey("duration")) {
		dst.duration = obj["duration"].as<decltype(dst.duration)::value_type>();
	} else {
		dst.duration = std::nullopt;
	}
	if (obj.containsKey("string")) {
		dst.string = obj["string"].as<decltype(dst.string)::value_type>();
	} else {
		dst.string = std::nullopt;
	}
	if (obj.containsKey("time")) {
		dst.time = obj["time"].as<decltype(dst.time)::value_type>();
	} else {
		dst.time = std::nullopt;
	}
	if (obj.containsKey("scaledNumber")) {
		dst.scaledNumber = obj["scaledNumber"].as<decltype(dst.scaledNumber)::value_type>();
	} else {
		dst.scaledNumber = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.isValueChangeable) {
		obj["isValueChangeable"] = *src.isValueChangeable;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("isValueChangeable")) {
		dst.isValueChangeable = obj["isValueChangeable"].as<decltype(dst.isValueChangeable)::value_type>();
	} else {
		dst.isValueChangeable = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.isValueChangeable) {
		obj["isValueChangeable"] = *src.isValueChangeable;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("isValueChangeable")) {
		dst.isValueChangeable = obj["isValueChangeable"].as<decltype(dst.isValueChangeable)::value_type>();
	} else {
		dst.isValueChangeable = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceConfigurationKeyValueData) {
		obj["deviceConfigurationKeyValueData"] = *src.deviceConfigurationKeyValueData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceConfigurationKeyValueData")) {
		dst.deviceConfigurationKeyValueData = obj["deviceConfigurationKeyValueData"].as<decltype(dst.deviceConfigurationKeyValueData)::value_type>();
	} else {
		dst.deviceConfigurationKeyValueData = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}
	if (src.keyName) {
		obj["keyName"] = *src.keyName;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}
	if (obj.containsKey("keyName")) {
		dst.keyName = obj["keyName"].as<decltype(dst.keyName)::value_type>();
	} else {
		dst.keyName = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}
	if (src.keyName) {
		obj["keyName"] = *src.keyName;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}
	if (obj.containsKey("keyName")) {
		dst.keyName = obj["keyName"].as<decltype(dst.keyName)::value_type>();
	} else {
		dst.keyName = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceConfigurationKeyValueDescriptionData) {
		obj["deviceConfigurationKeyValueDescriptionData"] = *src.deviceConfigurationKeyValueDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceConfigurationKeyValueDescriptionData")) {
		dst.deviceConfigurationKeyValueDescriptionData = obj["deviceConfigurationKeyValueDescriptionData"].as<decltype(dst.deviceConfigurationKeyValueDescriptionData)::value_type>();
	} else {
		dst.deviceConfigurationKeyValueDescriptionData = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}
	if (src.keyName) {
		obj["keyName"] = *src.keyName;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}
	if (obj.containsKey("keyName")) {
		dst.keyName = obj["keyName"].as<decltype(dst.keyName)::value_type>();
	} else {
		dst.keyName = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}
	if (src.valueRangeMin) {
		obj["valueRangeMin"] = *src.valueRangeMin;
	}
	if (src.valueRangeMax) {
		obj["valueRangeMax"] = *src.valueRangeMax;
	}
	if (src.valueStepSize) {
		obj["valueStepSize"] = *src.valueStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}
	if (obj.containsKey("valueRangeMin")) {
		dst.valueRangeMin = obj["valueRangeMin"].as<decltype(dst.valueRangeMin)::value_type>();
	} else {
		dst.valueRangeMin = std::nullopt;
	}
	if (obj.containsKey("valueRangeMax")) {
		dst.valueRangeMax = obj["valueRangeMax"].as<decltype(dst.valueRangeMax)::value_type>();
	} else {
		dst.valueRangeMax = std::nullopt;
	}
	if (obj.containsKey("valueStepSize")) {
		dst.valueStepSize = obj["valueStepSize"].as<decltype(dst.valueStepSize)::value_type>();
	} else {
		dst.valueStepSize = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}
	if (src.valueRangeMin) {
		obj["valueRangeMin"] = *src.valueRangeMin;
	}
	if (src.valueRangeMax) {
		obj["valueRangeMax"] = *src.valueRangeMax;
	}
	if (src.valueStepSize) {
		obj["valueStepSize"] = *src.valueStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}
	if (obj.containsKey("valueRangeMin")) {
		dst.valueRangeMin = obj["valueRangeMin"].as<decltype(dst.valueRangeMin)::value_type>();
	} else {
		dst.valueRangeMin = std::nullopt;
	}
	if (obj.containsKey("valueRangeMax")) {
		dst.valueRangeMax = obj["valueRangeMax"].as<decltype(dst.valueRangeMax)::value_type>();
	} else {
		dst.valueRangeMax = std::nullopt;
	}
	if (obj.containsKey("valueStepSize")) {
		dst.valueStepSize = obj["valueStepSize"].as<decltype(dst.valueStepSize)::value_type>();
	} else {
		dst.valueStepSize = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceConfigurationKeyValueConstraintsData) {
		obj["deviceConfigurationKeyValueConstraintsData"] = *src.deviceConfigurationKeyValueConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceConfigurationKeyValueConstraintsData")) {
		dst.deviceConfigurationKeyValueConstraintsData = obj["deviceConfigurationKeyValueConstraintsData"].as<decltype(dst.deviceConfigurationKeyValueConstraintsData)::value_type>();
	} else {
		dst.deviceConfigurationKeyValueConstraintsData = std::nullopt;
	}

}
bool convertToJson(const DeviceConfigurationKeyValueConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.keyId) {
		obj["keyId"] = *src.keyId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("keyId")) {
		dst.keyId = obj["keyId"].as<decltype(dst.keyId)::value_type>();
	} else {
		dst.keyId = std::nullopt;
	}

}
bool convertToJson(const DeviceDiagnosisStateDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.operatingState) {
		obj["operatingState"] = *src.operatingState;
	}
	if (src.vendorStateCode) {
		obj["vendorStateCode"] = *src.vendorStateCode;
	}
	if (src.lastErrorCode) {
		obj["lastErrorCode"] = *src.lastErrorCode;
	}
	if (src.upTime) {
		obj["upTime"] = *src.upTime;
	}
	if (src.totalUpTime) {
		obj["totalUpTime"] = *src.totalUpTime;
	}
	if (src.powerSupplyCondition) {
		obj["powerSupplyCondition"] = *src.powerSupplyCondition;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisStateDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("operatingState")) {
		dst.operatingState = obj["operatingState"].as<decltype(dst.operatingState)::value_type>();
	} else {
		dst.operatingState = std::nullopt;
	}
	if (obj.containsKey("vendorStateCode")) {
		dst.vendorStateCode = obj["vendorStateCode"].as<decltype(dst.vendorStateCode)::value_type>();
	} else {
		dst.vendorStateCode = std::nullopt;
	}
	if (obj.containsKey("lastErrorCode")) {
		dst.lastErrorCode = obj["lastErrorCode"].as<decltype(dst.lastErrorCode)::value_type>();
	} else {
		dst.lastErrorCode = std::nullopt;
	}
	if (obj.containsKey("upTime")) {
		dst.upTime = obj["upTime"].as<decltype(dst.upTime)::value_type>();
	} else {
		dst.upTime = std::nullopt;
	}
	if (obj.containsKey("totalUpTime")) {
		dst.totalUpTime = obj["totalUpTime"].as<decltype(dst.totalUpTime)::value_type>();
	} else {
		dst.totalUpTime = std::nullopt;
	}
	if (obj.containsKey("powerSupplyCondition")) {
		dst.powerSupplyCondition = obj["powerSupplyCondition"].as<decltype(dst.powerSupplyCondition)::value_type>();
	} else {
		dst.powerSupplyCondition = std::nullopt;
	}

}
bool convertToJson(const DeviceDiagnosisStateDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.operatingState) {
		obj["operatingState"] = *src.operatingState;
	}
	if (src.vendorStateCode) {
		obj["vendorStateCode"] = *src.vendorStateCode;
	}
	if (src.lastErrorCode) {
		obj["lastErrorCode"] = *src.lastErrorCode;
	}
	if (src.upTime) {
		obj["upTime"] = *src.upTime;
	}
	if (src.totalUpTime) {
		obj["totalUpTime"] = *src.totalUpTime;
	}
	if (src.powerSupplyCondition) {
		obj["powerSupplyCondition"] = *src.powerSupplyCondition;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisStateDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("operatingState")) {
		dst.operatingState = obj["operatingState"].as<decltype(dst.operatingState)::value_type>();
	} else {
		dst.operatingState = std::nullopt;
	}
	if (obj.containsKey("vendorStateCode")) {
		dst.vendorStateCode = obj["vendorStateCode"].as<decltype(dst.vendorStateCode)::value_type>();
	} else {
		dst.vendorStateCode = std::nullopt;
	}
	if (obj.containsKey("lastErrorCode")) {
		dst.lastErrorCode = obj["lastErrorCode"].as<decltype(dst.lastErrorCode)::value_type>();
	} else {
		dst.lastErrorCode = std::nullopt;
	}
	if (obj.containsKey("upTime")) {
		dst.upTime = obj["upTime"].as<decltype(dst.upTime)::value_type>();
	} else {
		dst.upTime = std::nullopt;
	}
	if (obj.containsKey("totalUpTime")) {
		dst.totalUpTime = obj["totalUpTime"].as<decltype(dst.totalUpTime)::value_type>();
	} else {
		dst.totalUpTime = std::nullopt;
	}
	if (obj.containsKey("powerSupplyCondition")) {
		dst.powerSupplyCondition = obj["powerSupplyCondition"].as<decltype(dst.powerSupplyCondition)::value_type>();
	} else {
		dst.powerSupplyCondition = std::nullopt;
	}

}
bool convertToJson(const DeviceDiagnosisHeartbeatDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.heartbeatCounter) {
		obj["heartbeatCounter"] = *src.heartbeatCounter;
	}
	if (src.heartbeatTimeout) {
		obj["heartbeatTimeout"] = *src.heartbeatTimeout;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisHeartbeatDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("heartbeatCounter")) {
		dst.heartbeatCounter = obj["heartbeatCounter"].as<decltype(dst.heartbeatCounter)::value_type>();
	} else {
		dst.heartbeatCounter = std::nullopt;
	}
	if (obj.containsKey("heartbeatTimeout")) {
		dst.heartbeatTimeout = obj["heartbeatTimeout"].as<decltype(dst.heartbeatTimeout)::value_type>();
	} else {
		dst.heartbeatTimeout = std::nullopt;
	}

}
bool convertToJson(const DeviceDiagnosisHeartbeatDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.heartbeatCounter) {
		obj["heartbeatCounter"] = *src.heartbeatCounter;
	}
	if (src.heartbeatTimeout) {
		obj["heartbeatTimeout"] = *src.heartbeatTimeout;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisHeartbeatDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("heartbeatCounter")) {
		dst.heartbeatCounter = obj["heartbeatCounter"].as<decltype(dst.heartbeatCounter)::value_type>();
	} else {
		dst.heartbeatCounter = std::nullopt;
	}
	if (obj.containsKey("heartbeatTimeout")) {
		dst.heartbeatTimeout = obj["heartbeatTimeout"].as<decltype(dst.heartbeatTimeout)::value_type>();
	} else {
		dst.heartbeatTimeout = std::nullopt;
	}

}
bool convertToJson(const DeviceDiagnosisServiceDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.installationTime) {
		obj["installationTime"] = *src.installationTime;
	}
	if (src.bootCounter) {
		obj["bootCounter"] = *src.bootCounter;
	}
	if (src.nextService) {
		obj["nextService"] = *src.nextService;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisServiceDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("installationTime")) {
		dst.installationTime = obj["installationTime"].as<decltype(dst.installationTime)::value_type>();
	} else {
		dst.installationTime = std::nullopt;
	}
	if (obj.containsKey("bootCounter")) {
		dst.bootCounter = obj["bootCounter"].as<decltype(dst.bootCounter)::value_type>();
	} else {
		dst.bootCounter = std::nullopt;
	}
	if (obj.containsKey("nextService")) {
		dst.nextService = obj["nextService"].as<decltype(dst.nextService)::value_type>();
	} else {
		dst.nextService = std::nullopt;
	}

}
bool convertToJson(const DeviceDiagnosisServiceDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.installationTime) {
		obj["installationTime"] = *src.installationTime;
	}
	if (src.bootCounter) {
		obj["bootCounter"] = *src.bootCounter;
	}
	if (src.nextService) {
		obj["nextService"] = *src.nextService;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisServiceDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("installationTime")) {
		dst.installationTime = obj["installationTime"].as<decltype(dst.installationTime)::value_type>();
	} else {
		dst.installationTime = std::nullopt;
	}
	if (obj.containsKey("bootCounter")) {
		dst.bootCounter = obj["bootCounter"].as<decltype(dst.bootCounter)::value_type>();
	} else {
		dst.bootCounter = std::nullopt;
	}
	if (obj.containsKey("nextService")) {
		dst.nextService = obj["nextService"].as<decltype(dst.nextService)::value_type>();
	} else {
		dst.nextService = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionParameterDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.voltageType) {
		obj["voltageType"] = *src.voltageType;
	}
	if (src.acMeasuredPhases) {
		obj["acMeasuredPhases"] = *src.acMeasuredPhases;
	}
	if (src.acMeasuredInReferenceTo) {
		obj["acMeasuredInReferenceTo"] = *src.acMeasuredInReferenceTo;
	}
	if (src.acMeasurementType) {
		obj["acMeasurementType"] = *src.acMeasurementType;
	}
	if (src.acMeasurementVariant) {
		obj["acMeasurementVariant"] = *src.acMeasurementVariant;
	}
	if (src.acMeasuredHarmonic) {
		obj["acMeasuredHarmonic"] = *src.acMeasuredHarmonic;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionParameterDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("voltageType")) {
		dst.voltageType = obj["voltageType"].as<decltype(dst.voltageType)::value_type>();
	} else {
		dst.voltageType = std::nullopt;
	}
	if (obj.containsKey("acMeasuredPhases")) {
		dst.acMeasuredPhases = obj["acMeasuredPhases"].as<decltype(dst.acMeasuredPhases)::value_type>();
	} else {
		dst.acMeasuredPhases = std::nullopt;
	}
	if (obj.containsKey("acMeasuredInReferenceTo")) {
		dst.acMeasuredInReferenceTo = obj["acMeasuredInReferenceTo"].as<decltype(dst.acMeasuredInReferenceTo)::value_type>();
	} else {
		dst.acMeasuredInReferenceTo = std::nullopt;
	}
	if (obj.containsKey("acMeasurementType")) {
		dst.acMeasurementType = obj["acMeasurementType"].as<decltype(dst.acMeasurementType)::value_type>();
	} else {
		dst.acMeasurementType = std::nullopt;
	}
	if (obj.containsKey("acMeasurementVariant")) {
		dst.acMeasurementVariant = obj["acMeasurementVariant"].as<decltype(dst.acMeasurementVariant)::value_type>();
	} else {
		dst.acMeasurementVariant = std::nullopt;
	}
	if (obj.containsKey("acMeasuredHarmonic")) {
		dst.acMeasuredHarmonic = obj["acMeasuredHarmonic"].as<decltype(dst.acMeasuredHarmonic)::value_type>();
	} else {
		dst.acMeasuredHarmonic = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionParameterDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.voltageType) {
		obj["voltageType"] = *src.voltageType;
	}
	if (src.acMeasuredPhases) {
		obj["acMeasuredPhases"] = *src.acMeasuredPhases;
	}
	if (src.acMeasuredInReferenceTo) {
		obj["acMeasuredInReferenceTo"] = *src.acMeasuredInReferenceTo;
	}
	if (src.acMeasurementType) {
		obj["acMeasurementType"] = *src.acMeasurementType;
	}
	if (src.acMeasurementVariant) {
		obj["acMeasurementVariant"] = *src.acMeasurementVariant;
	}
	if (src.acMeasuredHarmonic) {
		obj["acMeasuredHarmonic"] = *src.acMeasuredHarmonic;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionParameterDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("voltageType")) {
		dst.voltageType = obj["voltageType"].as<decltype(dst.voltageType)::value_type>();
	} else {
		dst.voltageType = std::nullopt;
	}
	if (obj.containsKey("acMeasuredPhases")) {
		dst.acMeasuredPhases = obj["acMeasuredPhases"].as<decltype(dst.acMeasuredPhases)::value_type>();
	} else {
		dst.acMeasuredPhases = std::nullopt;
	}
	if (obj.containsKey("acMeasuredInReferenceTo")) {
		dst.acMeasuredInReferenceTo = obj["acMeasuredInReferenceTo"].as<decltype(dst.acMeasuredInReferenceTo)::value_type>();
	} else {
		dst.acMeasuredInReferenceTo = std::nullopt;
	}
	if (obj.containsKey("acMeasurementType")) {
		dst.acMeasurementType = obj["acMeasurementType"].as<decltype(dst.acMeasurementType)::value_type>();
	} else {
		dst.acMeasurementType = std::nullopt;
	}
	if (obj.containsKey("acMeasurementVariant")) {
		dst.acMeasurementVariant = obj["acMeasurementVariant"].as<decltype(dst.acMeasurementVariant)::value_type>();
	} else {
		dst.acMeasurementVariant = std::nullopt;
	}
	if (obj.containsKey("acMeasuredHarmonic")) {
		dst.acMeasuredHarmonic = obj["acMeasuredHarmonic"].as<decltype(dst.acMeasuredHarmonic)::value_type>();
	} else {
		dst.acMeasuredHarmonic = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionParameterDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionParameterDescriptionData) {
		obj["electricalConnectionParameterDescriptionData"] = *src.electricalConnectionParameterDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionParameterDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionParameterDescriptionData")) {
		dst.electricalConnectionParameterDescriptionData = obj["electricalConnectionParameterDescriptionData"].as<decltype(dst.electricalConnectionParameterDescriptionData)::value_type>();
	} else {
		dst.electricalConnectionParameterDescriptionData = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionParameterDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionParameterDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionPermittedValueSetDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}
	if (src.permittedValueSet) {
		obj["permittedValueSet"] = *src.permittedValueSet;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionPermittedValueSetDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}
	if (obj.containsKey("permittedValueSet")) {
		dst.permittedValueSet = obj["permittedValueSet"].as<decltype(dst.permittedValueSet)::value_type>();
	} else {
		dst.permittedValueSet = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionPermittedValueSetDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}
	if (src.permittedValueSet) {
		obj["permittedValueSet"] = *src.permittedValueSet;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionPermittedValueSetDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}
	if (obj.containsKey("permittedValueSet")) {
		dst.permittedValueSet = obj["permittedValueSet"].as<decltype(dst.permittedValueSet)::value_type>();
	} else {
		dst.permittedValueSet = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionPermittedValueSetListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionPermittedValueSetData) {
		obj["electricalConnectionPermittedValueSetData"] = *src.electricalConnectionPermittedValueSetData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionPermittedValueSetListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionPermittedValueSetData")) {
		dst.electricalConnectionPermittedValueSetData = obj["electricalConnectionPermittedValueSetData"].as<decltype(dst.electricalConnectionPermittedValueSetData)::value_type>();
	} else {
		dst.electricalConnectionPermittedValueSetData = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionPermittedValueSetListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionPermittedValueSetListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionCharacteristicDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}
	if (src.characteristicId) {
		obj["characteristicId"] = *src.characteristicId;
	}
	if (src.characteristicContext) {
		obj["characteristicContext"] = *src.characteristicContext;
	}
	if (src.characteristicType) {
		obj["characteristicType"] = *src.characteristicType;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}
	if (obj.containsKey("characteristicId")) {
		dst.characteristicId = obj["characteristicId"].as<decltype(dst.characteristicId)::value_type>();
	} else {
		dst.characteristicId = std::nullopt;
	}
	if (obj.containsKey("characteristicContext")) {
		dst.characteristicContext = obj["characteristicContext"].as<decltype(dst.characteristicContext)::value_type>();
	} else {
		dst.characteristicContext = std::nullopt;
	}
	if (obj.containsKey("characteristicType")) {
		dst.characteristicType = obj["characteristicType"].as<decltype(dst.characteristicType)::value_type>();
	} else {
		dst.characteristicType = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionCharacteristicDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}
	if (src.characteristicId) {
		obj["characteristicId"] = *src.characteristicId;
	}
	if (src.characteristicContext) {
		obj["characteristicContext"] = *src.characteristicContext;
	}
	if (src.characteristicType) {
		obj["characteristicType"] = *src.characteristicType;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}
	if (obj.containsKey("characteristicId")) {
		dst.characteristicId = obj["characteristicId"].as<decltype(dst.characteristicId)::value_type>();
	} else {
		dst.characteristicId = std::nullopt;
	}
	if (obj.containsKey("characteristicContext")) {
		dst.characteristicContext = obj["characteristicContext"].as<decltype(dst.characteristicContext)::value_type>();
	} else {
		dst.characteristicContext = std::nullopt;
	}
	if (obj.containsKey("characteristicType")) {
		dst.characteristicType = obj["characteristicType"].as<decltype(dst.characteristicType)::value_type>();
	} else {
		dst.characteristicType = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionCharacteristicListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionCharacteristicData) {
		obj["electricalConnectionCharacteristicData"] = *src.electricalConnectionCharacteristicData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionCharacteristicData")) {
		dst.electricalConnectionCharacteristicData = obj["electricalConnectionCharacteristicData"].as<decltype(dst.electricalConnectionCharacteristicData)::value_type>();
	} else {
		dst.electricalConnectionCharacteristicData = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionCharacteristicListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.parameterId) {
		obj["parameterId"] = *src.parameterId;
	}
	if (src.characteristicId) {
		obj["characteristicId"] = *src.characteristicId;
	}
	if (src.characteristicContext) {
		obj["characteristicContext"] = *src.characteristicContext;
	}
	if (src.characteristicType) {
		obj["characteristicType"] = *src.characteristicType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("parameterId")) {
		dst.parameterId = obj["parameterId"].as<decltype(dst.parameterId)::value_type>();
	} else {
		dst.parameterId = std::nullopt;
	}
	if (obj.containsKey("characteristicId")) {
		dst.characteristicId = obj["characteristicId"].as<decltype(dst.characteristicId)::value_type>();
	} else {
		dst.characteristicId = std::nullopt;
	}
	if (obj.containsKey("characteristicContext")) {
		dst.characteristicContext = obj["characteristicContext"].as<decltype(dst.characteristicContext)::value_type>();
	} else {
		dst.characteristicContext = std::nullopt;
	}
	if (obj.containsKey("characteristicType")) {
		dst.characteristicType = obj["characteristicType"].as<decltype(dst.characteristicType)::value_type>();
	} else {
		dst.characteristicType = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionStateDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.currentEnergyMode) {
		obj["currentEnergyMode"] = *src.currentEnergyMode;
	}
	if (src.consumptionTime) {
		obj["consumptionTime"] = *src.consumptionTime;
	}
	if (src.productionTime) {
		obj["productionTime"] = *src.productionTime;
	}
	if (src.totalConsumptionTime) {
		obj["totalConsumptionTime"] = *src.totalConsumptionTime;
	}
	if (src.totalProductionTime) {
		obj["totalProductionTime"] = *src.totalProductionTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionStateDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("currentEnergyMode")) {
		dst.currentEnergyMode = obj["currentEnergyMode"].as<decltype(dst.currentEnergyMode)::value_type>();
	} else {
		dst.currentEnergyMode = std::nullopt;
	}
	if (obj.containsKey("consumptionTime")) {
		dst.consumptionTime = obj["consumptionTime"].as<decltype(dst.consumptionTime)::value_type>();
	} else {
		dst.consumptionTime = std::nullopt;
	}
	if (obj.containsKey("productionTime")) {
		dst.productionTime = obj["productionTime"].as<decltype(dst.productionTime)::value_type>();
	} else {
		dst.productionTime = std::nullopt;
	}
	if (obj.containsKey("totalConsumptionTime")) {
		dst.totalConsumptionTime = obj["totalConsumptionTime"].as<decltype(dst.totalConsumptionTime)::value_type>();
	} else {
		dst.totalConsumptionTime = std::nullopt;
	}
	if (obj.containsKey("totalProductionTime")) {
		dst.totalProductionTime = obj["totalProductionTime"].as<decltype(dst.totalProductionTime)::value_type>();
	} else {
		dst.totalProductionTime = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionStateDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.currentEnergyMode) {
		obj["currentEnergyMode"] = *src.currentEnergyMode;
	}
	if (src.consumptionTime) {
		obj["consumptionTime"] = *src.consumptionTime;
	}
	if (src.productionTime) {
		obj["productionTime"] = *src.productionTime;
	}
	if (src.totalConsumptionTime) {
		obj["totalConsumptionTime"] = *src.totalConsumptionTime;
	}
	if (src.totalProductionTime) {
		obj["totalProductionTime"] = *src.totalProductionTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionStateDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("currentEnergyMode")) {
		dst.currentEnergyMode = obj["currentEnergyMode"].as<decltype(dst.currentEnergyMode)::value_type>();
	} else {
		dst.currentEnergyMode = std::nullopt;
	}
	if (obj.containsKey("consumptionTime")) {
		dst.consumptionTime = obj["consumptionTime"].as<decltype(dst.consumptionTime)::value_type>();
	} else {
		dst.consumptionTime = std::nullopt;
	}
	if (obj.containsKey("productionTime")) {
		dst.productionTime = obj["productionTime"].as<decltype(dst.productionTime)::value_type>();
	} else {
		dst.productionTime = std::nullopt;
	}
	if (obj.containsKey("totalConsumptionTime")) {
		dst.totalConsumptionTime = obj["totalConsumptionTime"].as<decltype(dst.totalConsumptionTime)::value_type>();
	} else {
		dst.totalConsumptionTime = std::nullopt;
	}
	if (obj.containsKey("totalProductionTime")) {
		dst.totalProductionTime = obj["totalProductionTime"].as<decltype(dst.totalProductionTime)::value_type>();
	} else {
		dst.totalProductionTime = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionStateListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionStateData) {
		obj["electricalConnectionStateData"] = *src.electricalConnectionStateData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionStateListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionStateData")) {
		dst.electricalConnectionStateData = obj["electricalConnectionStateData"].as<decltype(dst.electricalConnectionStateData)::value_type>();
	} else {
		dst.electricalConnectionStateData = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionStateListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionStateListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.powerSupplyType) {
		obj["powerSupplyType"] = *src.powerSupplyType;
	}
	if (src.acConnectedPhases) {
		obj["acConnectedPhases"] = *src.acConnectedPhases;
	}
	if (src.acRmsPeriodDuration) {
		obj["acRmsPeriodDuration"] = *src.acRmsPeriodDuration;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("powerSupplyType")) {
		dst.powerSupplyType = obj["powerSupplyType"].as<decltype(dst.powerSupplyType)::value_type>();
	} else {
		dst.powerSupplyType = std::nullopt;
	}
	if (obj.containsKey("acConnectedPhases")) {
		dst.acConnectedPhases = obj["acConnectedPhases"].as<decltype(dst.acConnectedPhases)::value_type>();
	} else {
		dst.acConnectedPhases = std::nullopt;
	}
	if (obj.containsKey("acRmsPeriodDuration")) {
		dst.acRmsPeriodDuration = obj["acRmsPeriodDuration"].as<decltype(dst.acRmsPeriodDuration)::value_type>();
	} else {
		dst.acRmsPeriodDuration = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.powerSupplyType) {
		obj["powerSupplyType"] = *src.powerSupplyType;
	}
	if (src.acConnectedPhases) {
		obj["acConnectedPhases"] = *src.acConnectedPhases;
	}
	if (src.acRmsPeriodDuration) {
		obj["acRmsPeriodDuration"] = *src.acRmsPeriodDuration;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("powerSupplyType")) {
		dst.powerSupplyType = obj["powerSupplyType"].as<decltype(dst.powerSupplyType)::value_type>();
	} else {
		dst.powerSupplyType = std::nullopt;
	}
	if (obj.containsKey("acConnectedPhases")) {
		dst.acConnectedPhases = obj["acConnectedPhases"].as<decltype(dst.acConnectedPhases)::value_type>();
	} else {
		dst.acConnectedPhases = std::nullopt;
	}
	if (obj.containsKey("acRmsPeriodDuration")) {
		dst.acRmsPeriodDuration = obj["acRmsPeriodDuration"].as<decltype(dst.acRmsPeriodDuration)::value_type>();
	} else {
		dst.acRmsPeriodDuration = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionDescriptionData) {
		obj["electricalConnectionDescriptionData"] = *src.electricalConnectionDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionDescriptionData")) {
		dst.electricalConnectionDescriptionData = obj["electricalConnectionDescriptionData"].as<decltype(dst.electricalConnectionDescriptionData)::value_type>();
	} else {
		dst.electricalConnectionDescriptionData = std::nullopt;
	}

}
bool convertToJson(const ElectricalConnectionDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.electricalConnectionId) {
		obj["electricalConnectionId"] = *src.electricalConnectionId;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("electricalConnectionId")) {
		dst.electricalConnectionId = obj["electricalConnectionId"].as<decltype(dst.electricalConnectionId)::value_type>();
	} else {
		dst.electricalConnectionId = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.currentOperationModeId) {
		obj["currentOperationModeId"] = *src.currentOperationModeId;
	}
	if (src.isOperationModeIdChangeable) {
		obj["isOperationModeIdChangeable"] = *src.isOperationModeIdChangeable;
	}
	if (src.currentSetpointId) {
		obj["currentSetpointId"] = *src.currentSetpointId;
	}
	if (src.isSetpointIdChangeable) {
		obj["isSetpointIdChangeable"] = *src.isSetpointIdChangeable;
	}
	if (src.isOverrunActive) {
		obj["isOverrunActive"] = *src.isOverrunActive;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("currentOperationModeId")) {
		dst.currentOperationModeId = obj["currentOperationModeId"].as<decltype(dst.currentOperationModeId)::value_type>();
	} else {
		dst.currentOperationModeId = std::nullopt;
	}
	if (obj.containsKey("isOperationModeIdChangeable")) {
		dst.isOperationModeIdChangeable = obj["isOperationModeIdChangeable"].as<decltype(dst.isOperationModeIdChangeable)::value_type>();
	} else {
		dst.isOperationModeIdChangeable = std::nullopt;
	}
	if (obj.containsKey("currentSetpointId")) {
		dst.currentSetpointId = obj["currentSetpointId"].as<decltype(dst.currentSetpointId)::value_type>();
	} else {
		dst.currentSetpointId = std::nullopt;
	}
	if (obj.containsKey("isSetpointIdChangeable")) {
		dst.isSetpointIdChangeable = obj["isSetpointIdChangeable"].as<decltype(dst.isSetpointIdChangeable)::value_type>();
	} else {
		dst.isSetpointIdChangeable = std::nullopt;
	}
	if (obj.containsKey("isOverrunActive")) {
		dst.isOverrunActive = obj["isOverrunActive"].as<decltype(dst.isOverrunActive)::value_type>();
	} else {
		dst.isOverrunActive = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.currentOperationModeId) {
		obj["currentOperationModeId"] = *src.currentOperationModeId;
	}
	if (src.isOperationModeIdChangeable) {
		obj["isOperationModeIdChangeable"] = *src.isOperationModeIdChangeable;
	}
	if (src.currentSetpointId) {
		obj["currentSetpointId"] = *src.currentSetpointId;
	}
	if (src.isSetpointIdChangeable) {
		obj["isSetpointIdChangeable"] = *src.isSetpointIdChangeable;
	}
	if (src.isOverrunActive) {
		obj["isOverrunActive"] = *src.isOverrunActive;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("currentOperationModeId")) {
		dst.currentOperationModeId = obj["currentOperationModeId"].as<decltype(dst.currentOperationModeId)::value_type>();
	} else {
		dst.currentOperationModeId = std::nullopt;
	}
	if (obj.containsKey("isOperationModeIdChangeable")) {
		dst.isOperationModeIdChangeable = obj["isOperationModeIdChangeable"].as<decltype(dst.isOperationModeIdChangeable)::value_type>();
	} else {
		dst.isOperationModeIdChangeable = std::nullopt;
	}
	if (obj.containsKey("currentSetpointId")) {
		dst.currentSetpointId = obj["currentSetpointId"].as<decltype(dst.currentSetpointId)::value_type>();
	} else {
		dst.currentSetpointId = std::nullopt;
	}
	if (obj.containsKey("isSetpointIdChangeable")) {
		dst.isSetpointIdChangeable = obj["isSetpointIdChangeable"].as<decltype(dst.isSetpointIdChangeable)::value_type>();
	} else {
		dst.isSetpointIdChangeable = std::nullopt;
	}
	if (obj.containsKey("isOverrunActive")) {
		dst.isOverrunActive = obj["isOverrunActive"].as<decltype(dst.isOverrunActive)::value_type>();
	} else {
		dst.isOverrunActive = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacSystemFunctionData) {
		obj["hvacSystemFunctionData"] = *src.hvacSystemFunctionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("hvacSystemFunctionData")) {
		dst.hvacSystemFunctionData = obj["hvacSystemFunctionData"].as<decltype(dst.hvacSystemFunctionData)::value_type>();
	} else {
		dst.hvacSystemFunctionData = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionOperationModeRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.operationModeId) {
		obj["operationModeId"] = *src.operationModeId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionOperationModeRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("operationModeId")) {
		dst.operationModeId = obj["operationModeId"].as<decltype(dst.operationModeId)::value_type>();
	} else {
		dst.operationModeId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionOperationModeRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.operationModeId) {
		obj["operationModeId"] = *src.operationModeId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionOperationModeRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("operationModeId")) {
		dst.operationModeId = obj["operationModeId"].as<decltype(dst.operationModeId)::value_type>();
	} else {
		dst.operationModeId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionOperationModeRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacSystemFunctionOperationModeRelationData) {
		obj["hvacSystemFunctionOperationModeRelationData"] = *src.hvacSystemFunctionOperationModeRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionOperationModeRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("hvacSystemFunctionOperationModeRelationData")) {
		dst.hvacSystemFunctionOperationModeRelationData = obj["hvacSystemFunctionOperationModeRelationData"].as<decltype(dst.hvacSystemFunctionOperationModeRelationData)::value_type>();
	} else {
		dst.hvacSystemFunctionOperationModeRelationData = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionOperationModeRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionOperationModeRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionSetpointRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.operationModeId) {
		obj["operationModeId"] = *src.operationModeId;
	}
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionSetpointRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("operationModeId")) {
		dst.operationModeId = obj["operationModeId"].as<decltype(dst.operationModeId)::value_type>();
	} else {
		dst.operationModeId = std::nullopt;
	}
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionSetpointRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.operationModeId) {
		obj["operationModeId"] = *src.operationModeId;
	}
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionSetpointRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("operationModeId")) {
		dst.operationModeId = obj["operationModeId"].as<decltype(dst.operationModeId)::value_type>();
	} else {
		dst.operationModeId = std::nullopt;
	}
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionSetpointRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacSystemFunctionSetpointRelationData) {
		obj["hvacSystemFunctionSetpointRelationData"] = *src.hvacSystemFunctionSetpointRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionSetpointRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("hvacSystemFunctionSetpointRelationData")) {
		dst.hvacSystemFunctionSetpointRelationData = obj["hvacSystemFunctionSetpointRelationData"].as<decltype(dst.hvacSystemFunctionSetpointRelationData)::value_type>();
	} else {
		dst.hvacSystemFunctionSetpointRelationData = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionSetpointRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.operationModeId) {
		obj["operationModeId"] = *src.operationModeId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionSetpointRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("operationModeId")) {
		dst.operationModeId = obj["operationModeId"].as<decltype(dst.operationModeId)::value_type>();
	} else {
		dst.operationModeId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionPowerSequenceRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionPowerSequenceRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionPowerSequenceRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionPowerSequenceRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionPowerSequenceRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacSystemFunctionPowerSequenceRelationData) {
		obj["hvacSystemFunctionPowerSequenceRelationData"] = *src.hvacSystemFunctionPowerSequenceRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionPowerSequenceRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("hvacSystemFunctionPowerSequenceRelationData")) {
		dst.hvacSystemFunctionPowerSequenceRelationData = obj["hvacSystemFunctionPowerSequenceRelationData"].as<decltype(dst.hvacSystemFunctionPowerSequenceRelationData)::value_type>();
	} else {
		dst.hvacSystemFunctionPowerSequenceRelationData = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionPowerSequenceRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionPowerSequenceRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.systemFunctionType) {
		obj["systemFunctionType"] = *src.systemFunctionType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("systemFunctionType")) {
		dst.systemFunctionType = obj["systemFunctionType"].as<decltype(dst.systemFunctionType)::value_type>();
	} else {
		dst.systemFunctionType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}
	if (src.systemFunctionType) {
		obj["systemFunctionType"] = *src.systemFunctionType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}
	if (obj.containsKey("systemFunctionType")) {
		dst.systemFunctionType = obj["systemFunctionType"].as<decltype(dst.systemFunctionType)::value_type>();
	} else {
		dst.systemFunctionType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacSystemFunctionDescriptionData) {
		obj["hvacSystemFunctionDescriptionData"] = *src.hvacSystemFunctionDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("hvacSystemFunctionDescriptionData")) {
		dst.hvacSystemFunctionDescriptionData = obj["hvacSystemFunctionDescriptionData"].as<decltype(dst.hvacSystemFunctionDescriptionData)::value_type>();
	} else {
		dst.hvacSystemFunctionDescriptionData = std::nullopt;
	}

}
bool convertToJson(const HvacSystemFunctionDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.systemFunctionId) {
		obj["systemFunctionId"] = *src.systemFunctionId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("systemFunctionId")) {
		dst.systemFunctionId = obj["systemFunctionId"].as<decltype(dst.systemFunctionId)::value_type>();
	} else {
		dst.systemFunctionId = std::nullopt;
	}

}
bool convertToJson(const HvacOperationModeDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operationModeId) {
		obj["operationModeId"] = *src.operationModeId;
	}
	if (src.operationModeType) {
		obj["operationModeType"] = *src.operationModeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOperationModeDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operationModeId")) {
		dst.operationModeId = obj["operationModeId"].as<decltype(dst.operationModeId)::value_type>();
	} else {
		dst.operationModeId = std::nullopt;
	}
	if (obj.containsKey("operationModeType")) {
		dst.operationModeType = obj["operationModeType"].as<decltype(dst.operationModeType)::value_type>();
	} else {
		dst.operationModeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const HvacOperationModeDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operationModeId) {
		obj["operationModeId"] = *src.operationModeId;
	}
	if (src.operationModeType) {
		obj["operationModeType"] = *src.operationModeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOperationModeDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operationModeId")) {
		dst.operationModeId = obj["operationModeId"].as<decltype(dst.operationModeId)::value_type>();
	} else {
		dst.operationModeId = std::nullopt;
	}
	if (obj.containsKey("operationModeType")) {
		dst.operationModeType = obj["operationModeType"].as<decltype(dst.operationModeType)::value_type>();
	} else {
		dst.operationModeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const HvacOperationModeDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacOperationModeDescriptionData) {
		obj["hvacOperationModeDescriptionData"] = *src.hvacOperationModeDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOperationModeDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("hvacOperationModeDescriptionData")) {
		dst.hvacOperationModeDescriptionData = obj["hvacOperationModeDescriptionData"].as<decltype(dst.hvacOperationModeDescriptionData)::value_type>();
	} else {
		dst.hvacOperationModeDescriptionData = std::nullopt;
	}

}
bool convertToJson(const HvacOperationModeDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operationModeId) {
		obj["operationModeId"] = *src.operationModeId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOperationModeDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operationModeId")) {
		dst.operationModeId = obj["operationModeId"].as<decltype(dst.operationModeId)::value_type>();
	} else {
		dst.operationModeId = std::nullopt;
	}

}
bool convertToJson(const HvacOverrunDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.overrunId) {
		obj["overrunId"] = *src.overrunId;
	}
	if (src.overrunStatus) {
		obj["overrunStatus"] = *src.overrunStatus;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.isOverrunStatusChangeable) {
		obj["isOverrunStatusChangeable"] = *src.isOverrunStatusChangeable;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("overrunId")) {
		dst.overrunId = obj["overrunId"].as<decltype(dst.overrunId)::value_type>();
	} else {
		dst.overrunId = std::nullopt;
	}
	if (obj.containsKey("overrunStatus")) {
		dst.overrunStatus = obj["overrunStatus"].as<decltype(dst.overrunStatus)::value_type>();
	} else {
		dst.overrunStatus = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("isOverrunStatusChangeable")) {
		dst.isOverrunStatusChangeable = obj["isOverrunStatusChangeable"].as<decltype(dst.isOverrunStatusChangeable)::value_type>();
	} else {
		dst.isOverrunStatusChangeable = std::nullopt;
	}

}
bool convertToJson(const HvacOverrunDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.overrunId) {
		obj["overrunId"] = *src.overrunId;
	}
	if (src.overrunStatus) {
		obj["overrunStatus"] = *src.overrunStatus;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.isOverrunStatusChangeable) {
		obj["isOverrunStatusChangeable"] = *src.isOverrunStatusChangeable;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("overrunId")) {
		dst.overrunId = obj["overrunId"].as<decltype(dst.overrunId)::value_type>();
	} else {
		dst.overrunId = std::nullopt;
	}
	if (obj.containsKey("overrunStatus")) {
		dst.overrunStatus = obj["overrunStatus"].as<decltype(dst.overrunStatus)::value_type>();
	} else {
		dst.overrunStatus = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("isOverrunStatusChangeable")) {
		dst.isOverrunStatusChangeable = obj["isOverrunStatusChangeable"].as<decltype(dst.isOverrunStatusChangeable)::value_type>();
	} else {
		dst.isOverrunStatusChangeable = std::nullopt;
	}

}
bool convertToJson(const HvacOverrunListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacOverrunData) {
		obj["hvacOverrunData"] = *src.hvacOverrunData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("hvacOverrunData")) {
		dst.hvacOverrunData = obj["hvacOverrunData"].as<decltype(dst.hvacOverrunData)::value_type>();
	} else {
		dst.hvacOverrunData = std::nullopt;
	}

}
bool convertToJson(const HvacOverrunListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.overrunId) {
		obj["overrunId"] = *src.overrunId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("overrunId")) {
		dst.overrunId = obj["overrunId"].as<decltype(dst.overrunId)::value_type>();
	} else {
		dst.overrunId = std::nullopt;
	}

}
bool convertToJson(const HvacOverrunDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.overrunId) {
		obj["overrunId"] = *src.overrunId;
	}
	if (src.overrunType) {
		obj["overrunType"] = *src.overrunType;
	}
	if (src.affectedSystemFunctionId) {
		obj["affectedSystemFunctionId"] = *src.affectedSystemFunctionId;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("overrunId")) {
		dst.overrunId = obj["overrunId"].as<decltype(dst.overrunId)::value_type>();
	} else {
		dst.overrunId = std::nullopt;
	}
	if (obj.containsKey("overrunType")) {
		dst.overrunType = obj["overrunType"].as<decltype(dst.overrunType)::value_type>();
	} else {
		dst.overrunType = std::nullopt;
	}
	if (obj.containsKey("affectedSystemFunctionId")) {
		dst.affectedSystemFunctionId = obj["affectedSystemFunctionId"].as<decltype(dst.affectedSystemFunctionId)::value_type>();
	} else {
		dst.affectedSystemFunctionId = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const HvacOverrunDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.overrunId) {
		obj["overrunId"] = *src.overrunId;
	}
	if (src.overrunType) {
		obj["overrunType"] = *src.overrunType;
	}
	if (src.affectedSystemFunctionId) {
		obj["affectedSystemFunctionId"] = *src.affectedSystemFunctionId;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("overrunId")) {
		dst.overrunId = obj["overrunId"].as<decltype(dst.overrunId)::value_type>();
	} else {
		dst.overrunId = std::nullopt;
	}
	if (obj.containsKey("overrunType")) {
		dst.overrunType = obj["overrunType"].as<decltype(dst.overrunType)::value_type>();
	} else {
		dst.overrunType = std::nullopt;
	}
	if (obj.containsKey("affectedSystemFunctionId")) {
		dst.affectedSystemFunctionId = obj["affectedSystemFunctionId"].as<decltype(dst.affectedSystemFunctionId)::value_type>();
	} else {
		dst.affectedSystemFunctionId = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const HvacOverrunDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.hvacOverrunDescriptionData) {
		obj["hvacOverrunDescriptionData"] = *src.hvacOverrunDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("hvacOverrunDescriptionData")) {
		dst.hvacOverrunDescriptionData = obj["hvacOverrunDescriptionData"].as<decltype(dst.hvacOverrunDescriptionData)::value_type>();
	} else {
		dst.hvacOverrunDescriptionData = std::nullopt;
	}

}
bool convertToJson(const HvacOverrunDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.overrunId) {
		obj["overrunId"] = *src.overrunId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HvacOverrunDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("overrunId")) {
		dst.overrunId = obj["overrunId"].as<decltype(dst.overrunId)::value_type>();
	} else {
		dst.overrunId = std::nullopt;
	}

}
bool convertToJson(const SetpointDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.valueMin) {
		obj["valueMin"] = *src.valueMin;
	}
	if (src.valueMax) {
		obj["valueMax"] = *src.valueMax;
	}
	if (src.valueToleranceAbsolute) {
		obj["valueToleranceAbsolute"] = *src.valueToleranceAbsolute;
	}
	if (src.valueTolerancePercentage) {
		obj["valueTolerancePercentage"] = *src.valueTolerancePercentage;
	}
	if (src.isSetpointChangeable) {
		obj["isSetpointChangeable"] = *src.isSetpointChangeable;
	}
	if (src.isSetpointActive) {
		obj["isSetpointActive"] = *src.isSetpointActive;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("valueMin")) {
		dst.valueMin = obj["valueMin"].as<decltype(dst.valueMin)::value_type>();
	} else {
		dst.valueMin = std::nullopt;
	}
	if (obj.containsKey("valueMax")) {
		dst.valueMax = obj["valueMax"].as<decltype(dst.valueMax)::value_type>();
	} else {
		dst.valueMax = std::nullopt;
	}
	if (obj.containsKey("valueToleranceAbsolute")) {
		dst.valueToleranceAbsolute = obj["valueToleranceAbsolute"].as<decltype(dst.valueToleranceAbsolute)::value_type>();
	} else {
		dst.valueToleranceAbsolute = std::nullopt;
	}
	if (obj.containsKey("valueTolerancePercentage")) {
		dst.valueTolerancePercentage = obj["valueTolerancePercentage"].as<decltype(dst.valueTolerancePercentage)::value_type>();
	} else {
		dst.valueTolerancePercentage = std::nullopt;
	}
	if (obj.containsKey("isSetpointChangeable")) {
		dst.isSetpointChangeable = obj["isSetpointChangeable"].as<decltype(dst.isSetpointChangeable)::value_type>();
	} else {
		dst.isSetpointChangeable = std::nullopt;
	}
	if (obj.containsKey("isSetpointActive")) {
		dst.isSetpointActive = obj["isSetpointActive"].as<decltype(dst.isSetpointActive)::value_type>();
	} else {
		dst.isSetpointActive = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}

}
bool convertToJson(const SetpointDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}
	if (src.valueMin) {
		obj["valueMin"] = *src.valueMin;
	}
	if (src.valueMax) {
		obj["valueMax"] = *src.valueMax;
	}
	if (src.valueToleranceAbsolute) {
		obj["valueToleranceAbsolute"] = *src.valueToleranceAbsolute;
	}
	if (src.valueTolerancePercentage) {
		obj["valueTolerancePercentage"] = *src.valueTolerancePercentage;
	}
	if (src.isSetpointChangeable) {
		obj["isSetpointChangeable"] = *src.isSetpointChangeable;
	}
	if (src.isSetpointActive) {
		obj["isSetpointActive"] = *src.isSetpointActive;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}
	if (obj.containsKey("valueMin")) {
		dst.valueMin = obj["valueMin"].as<decltype(dst.valueMin)::value_type>();
	} else {
		dst.valueMin = std::nullopt;
	}
	if (obj.containsKey("valueMax")) {
		dst.valueMax = obj["valueMax"].as<decltype(dst.valueMax)::value_type>();
	} else {
		dst.valueMax = std::nullopt;
	}
	if (obj.containsKey("valueToleranceAbsolute")) {
		dst.valueToleranceAbsolute = obj["valueToleranceAbsolute"].as<decltype(dst.valueToleranceAbsolute)::value_type>();
	} else {
		dst.valueToleranceAbsolute = std::nullopt;
	}
	if (obj.containsKey("valueTolerancePercentage")) {
		dst.valueTolerancePercentage = obj["valueTolerancePercentage"].as<decltype(dst.valueTolerancePercentage)::value_type>();
	} else {
		dst.valueTolerancePercentage = std::nullopt;
	}
	if (obj.containsKey("isSetpointChangeable")) {
		dst.isSetpointChangeable = obj["isSetpointChangeable"].as<decltype(dst.isSetpointChangeable)::value_type>();
	} else {
		dst.isSetpointChangeable = std::nullopt;
	}
	if (obj.containsKey("isSetpointActive")) {
		dst.isSetpointActive = obj["isSetpointActive"].as<decltype(dst.isSetpointActive)::value_type>();
	} else {
		dst.isSetpointActive = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}

}
bool convertToJson(const SetpointListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointData) {
		obj["setpointData"] = *src.setpointData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointData")) {
		dst.setpointData = obj["setpointData"].as<decltype(dst.setpointData)::value_type>();
	} else {
		dst.setpointData = std::nullopt;
	}

}
bool convertToJson(const SetpointListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}

}
bool convertToJson(const SetpointConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}
	if (src.setpointRangeMin) {
		obj["setpointRangeMin"] = *src.setpointRangeMin;
	}
	if (src.setpointRangeMax) {
		obj["setpointRangeMax"] = *src.setpointRangeMax;
	}
	if (src.setpointStepSize) {
		obj["setpointStepSize"] = *src.setpointStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}
	if (obj.containsKey("setpointRangeMin")) {
		dst.setpointRangeMin = obj["setpointRangeMin"].as<decltype(dst.setpointRangeMin)::value_type>();
	} else {
		dst.setpointRangeMin = std::nullopt;
	}
	if (obj.containsKey("setpointRangeMax")) {
		dst.setpointRangeMax = obj["setpointRangeMax"].as<decltype(dst.setpointRangeMax)::value_type>();
	} else {
		dst.setpointRangeMax = std::nullopt;
	}
	if (obj.containsKey("setpointStepSize")) {
		dst.setpointStepSize = obj["setpointStepSize"].as<decltype(dst.setpointStepSize)::value_type>();
	} else {
		dst.setpointStepSize = std::nullopt;
	}

}
bool convertToJson(const SetpointConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}
	if (src.setpointRangeMin) {
		obj["setpointRangeMin"] = *src.setpointRangeMin;
	}
	if (src.setpointRangeMax) {
		obj["setpointRangeMax"] = *src.setpointRangeMax;
	}
	if (src.setpointStepSize) {
		obj["setpointStepSize"] = *src.setpointStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}
	if (obj.containsKey("setpointRangeMin")) {
		dst.setpointRangeMin = obj["setpointRangeMin"].as<decltype(dst.setpointRangeMin)::value_type>();
	} else {
		dst.setpointRangeMin = std::nullopt;
	}
	if (obj.containsKey("setpointRangeMax")) {
		dst.setpointRangeMax = obj["setpointRangeMax"].as<decltype(dst.setpointRangeMax)::value_type>();
	} else {
		dst.setpointRangeMax = std::nullopt;
	}
	if (obj.containsKey("setpointStepSize")) {
		dst.setpointStepSize = obj["setpointStepSize"].as<decltype(dst.setpointStepSize)::value_type>();
	} else {
		dst.setpointStepSize = std::nullopt;
	}

}
bool convertToJson(const SetpointConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointConstraintsData) {
		obj["setpointConstraintsData"] = *src.setpointConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointConstraintsData")) {
		dst.setpointConstraintsData = obj["setpointConstraintsData"].as<decltype(dst.setpointConstraintsData)::value_type>();
	} else {
		dst.setpointConstraintsData = std::nullopt;
	}

}
bool convertToJson(const SetpointConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}

}
bool convertToJson(const SetpointDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.setpointType) {
		obj["setpointType"] = *src.setpointType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("setpointType")) {
		dst.setpointType = obj["setpointType"].as<decltype(dst.setpointType)::value_type>();
	} else {
		dst.setpointType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const SetpointDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.setpointType) {
		obj["setpointType"] = *src.setpointType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("setpointType")) {
		dst.setpointType = obj["setpointType"].as<decltype(dst.setpointType)::value_type>();
	} else {
		dst.setpointType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const SetpointDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointDescriptionData) {
		obj["setpointDescriptionData"] = *src.setpointDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointDescriptionData")) {
		dst.setpointDescriptionData = obj["setpointDescriptionData"].as<decltype(dst.setpointDescriptionData)::value_type>();
	} else {
		dst.setpointDescriptionData = std::nullopt;
	}

}
bool convertToJson(const SetpointDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setpointId) {
		obj["setpointId"] = *src.setpointId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.setpointType) {
		obj["setpointType"] = *src.setpointType;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SetpointDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setpointId")) {
		dst.setpointId = obj["setpointId"].as<decltype(dst.setpointId)::value_type>();
	} else {
		dst.setpointId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("setpointType")) {
		dst.setpointType = obj["setpointType"].as<decltype(dst.setpointType)::value_type>();
	} else {
		dst.setpointType = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const TimeTableDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.timeSlotId) {
		obj["timeSlotId"] = *src.timeSlotId;
	}
	if (src.recurrenceInformation) {
		obj["recurrenceInformation"] = *src.recurrenceInformation;
	}
	if (src.startTime) {
		obj["startTime"] = *src.startTime;
	}
	if (src.endTime) {
		obj["endTime"] = *src.endTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("timeSlotId")) {
		dst.timeSlotId = obj["timeSlotId"].as<decltype(dst.timeSlotId)::value_type>();
	} else {
		dst.timeSlotId = std::nullopt;
	}
	if (obj.containsKey("recurrenceInformation")) {
		dst.recurrenceInformation = obj["recurrenceInformation"].as<decltype(dst.recurrenceInformation)::value_type>();
	} else {
		dst.recurrenceInformation = std::nullopt;
	}
	if (obj.containsKey("startTime")) {
		dst.startTime = obj["startTime"].as<decltype(dst.startTime)::value_type>();
	} else {
		dst.startTime = std::nullopt;
	}
	if (obj.containsKey("endTime")) {
		dst.endTime = obj["endTime"].as<decltype(dst.endTime)::value_type>();
	} else {
		dst.endTime = std::nullopt;
	}

}
bool convertToJson(const TimeTableDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.timeSlotId) {
		obj["timeSlotId"] = *src.timeSlotId;
	}
	if (src.recurrenceInformation) {
		obj["recurrenceInformation"] = *src.recurrenceInformation;
	}
	if (src.startTime) {
		obj["startTime"] = *src.startTime;
	}
	if (src.endTime) {
		obj["endTime"] = *src.endTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("timeSlotId")) {
		dst.timeSlotId = obj["timeSlotId"].as<decltype(dst.timeSlotId)::value_type>();
	} else {
		dst.timeSlotId = std::nullopt;
	}
	if (obj.containsKey("recurrenceInformation")) {
		dst.recurrenceInformation = obj["recurrenceInformation"].as<decltype(dst.recurrenceInformation)::value_type>();
	} else {
		dst.recurrenceInformation = std::nullopt;
	}
	if (obj.containsKey("startTime")) {
		dst.startTime = obj["startTime"].as<decltype(dst.startTime)::value_type>();
	} else {
		dst.startTime = std::nullopt;
	}
	if (obj.containsKey("endTime")) {
		dst.endTime = obj["endTime"].as<decltype(dst.endTime)::value_type>();
	} else {
		dst.endTime = std::nullopt;
	}

}
bool convertToJson(const TimeTableListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableData) {
		obj["timeTableData"] = *src.timeTableData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableData")) {
		dst.timeTableData = obj["timeTableData"].as<decltype(dst.timeTableData)::value_type>();
	} else {
		dst.timeTableData = std::nullopt;
	}

}
bool convertToJson(const TimeTableListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.timeSlotId) {
		obj["timeSlotId"] = *src.timeSlotId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("timeSlotId")) {
		dst.timeSlotId = obj["timeSlotId"].as<decltype(dst.timeSlotId)::value_type>();
	} else {
		dst.timeSlotId = std::nullopt;
	}

}
bool convertToJson(const TimeTableConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.slotCountMin) {
		obj["slotCountMin"] = *src.slotCountMin;
	}
	if (src.slotCountMax) {
		obj["slotCountMax"] = *src.slotCountMax;
	}
	if (src.slotDurationMin) {
		obj["slotDurationMin"] = *src.slotDurationMin;
	}
	if (src.slotDurationMax) {
		obj["slotDurationMax"] = *src.slotDurationMax;
	}
	if (src.slotDurationStepSize) {
		obj["slotDurationStepSize"] = *src.slotDurationStepSize;
	}
	if (src.slotShiftStepSize) {
		obj["slotShiftStepSize"] = *src.slotShiftStepSize;
	}
	if (src.firstSlotBeginsAt) {
		obj["firstSlotBeginsAt"] = *src.firstSlotBeginsAt;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("slotCountMin")) {
		dst.slotCountMin = obj["slotCountMin"].as<decltype(dst.slotCountMin)::value_type>();
	} else {
		dst.slotCountMin = std::nullopt;
	}
	if (obj.containsKey("slotCountMax")) {
		dst.slotCountMax = obj["slotCountMax"].as<decltype(dst.slotCountMax)::value_type>();
	} else {
		dst.slotCountMax = std::nullopt;
	}
	if (obj.containsKey("slotDurationMin")) {
		dst.slotDurationMin = obj["slotDurationMin"].as<decltype(dst.slotDurationMin)::value_type>();
	} else {
		dst.slotDurationMin = std::nullopt;
	}
	if (obj.containsKey("slotDurationMax")) {
		dst.slotDurationMax = obj["slotDurationMax"].as<decltype(dst.slotDurationMax)::value_type>();
	} else {
		dst.slotDurationMax = std::nullopt;
	}
	if (obj.containsKey("slotDurationStepSize")) {
		dst.slotDurationStepSize = obj["slotDurationStepSize"].as<decltype(dst.slotDurationStepSize)::value_type>();
	} else {
		dst.slotDurationStepSize = std::nullopt;
	}
	if (obj.containsKey("slotShiftStepSize")) {
		dst.slotShiftStepSize = obj["slotShiftStepSize"].as<decltype(dst.slotShiftStepSize)::value_type>();
	} else {
		dst.slotShiftStepSize = std::nullopt;
	}
	if (obj.containsKey("firstSlotBeginsAt")) {
		dst.firstSlotBeginsAt = obj["firstSlotBeginsAt"].as<decltype(dst.firstSlotBeginsAt)::value_type>();
	} else {
		dst.firstSlotBeginsAt = std::nullopt;
	}

}
bool convertToJson(const TimeTableConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.slotCountMin) {
		obj["slotCountMin"] = *src.slotCountMin;
	}
	if (src.slotCountMax) {
		obj["slotCountMax"] = *src.slotCountMax;
	}
	if (src.slotDurationMin) {
		obj["slotDurationMin"] = *src.slotDurationMin;
	}
	if (src.slotDurationMax) {
		obj["slotDurationMax"] = *src.slotDurationMax;
	}
	if (src.slotDurationStepSize) {
		obj["slotDurationStepSize"] = *src.slotDurationStepSize;
	}
	if (src.slotShiftStepSize) {
		obj["slotShiftStepSize"] = *src.slotShiftStepSize;
	}
	if (src.firstSlotBeginsAt) {
		obj["firstSlotBeginsAt"] = *src.firstSlotBeginsAt;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("slotCountMin")) {
		dst.slotCountMin = obj["slotCountMin"].as<decltype(dst.slotCountMin)::value_type>();
	} else {
		dst.slotCountMin = std::nullopt;
	}
	if (obj.containsKey("slotCountMax")) {
		dst.slotCountMax = obj["slotCountMax"].as<decltype(dst.slotCountMax)::value_type>();
	} else {
		dst.slotCountMax = std::nullopt;
	}
	if (obj.containsKey("slotDurationMin")) {
		dst.slotDurationMin = obj["slotDurationMin"].as<decltype(dst.slotDurationMin)::value_type>();
	} else {
		dst.slotDurationMin = std::nullopt;
	}
	if (obj.containsKey("slotDurationMax")) {
		dst.slotDurationMax = obj["slotDurationMax"].as<decltype(dst.slotDurationMax)::value_type>();
	} else {
		dst.slotDurationMax = std::nullopt;
	}
	if (obj.containsKey("slotDurationStepSize")) {
		dst.slotDurationStepSize = obj["slotDurationStepSize"].as<decltype(dst.slotDurationStepSize)::value_type>();
	} else {
		dst.slotDurationStepSize = std::nullopt;
	}
	if (obj.containsKey("slotShiftStepSize")) {
		dst.slotShiftStepSize = obj["slotShiftStepSize"].as<decltype(dst.slotShiftStepSize)::value_type>();
	} else {
		dst.slotShiftStepSize = std::nullopt;
	}
	if (obj.containsKey("firstSlotBeginsAt")) {
		dst.firstSlotBeginsAt = obj["firstSlotBeginsAt"].as<decltype(dst.firstSlotBeginsAt)::value_type>();
	} else {
		dst.firstSlotBeginsAt = std::nullopt;
	}

}
bool convertToJson(const TimeTableConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableConstraintsData) {
		obj["timeTableConstraintsData"] = *src.timeTableConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableConstraintsData")) {
		dst.timeTableConstraintsData = obj["timeTableConstraintsData"].as<decltype(dst.timeTableConstraintsData)::value_type>();
	} else {
		dst.timeTableConstraintsData = std::nullopt;
	}

}
bool convertToJson(const TimeTableConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}

}
bool convertToJson(const TimeTableDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.timeSlotCountChangeable) {
		obj["timeSlotCountChangeable"] = *src.timeSlotCountChangeable;
	}
	if (src.timeSlotTimesChangeable) {
		obj["timeSlotTimesChangeable"] = *src.timeSlotTimesChangeable;
	}
	if (src.timeSlotTimeMode) {
		obj["timeSlotTimeMode"] = *src.timeSlotTimeMode;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("timeSlotCountChangeable")) {
		dst.timeSlotCountChangeable = obj["timeSlotCountChangeable"].as<decltype(dst.timeSlotCountChangeable)::value_type>();
	} else {
		dst.timeSlotCountChangeable = std::nullopt;
	}
	if (obj.containsKey("timeSlotTimesChangeable")) {
		dst.timeSlotTimesChangeable = obj["timeSlotTimesChangeable"].as<decltype(dst.timeSlotTimesChangeable)::value_type>();
	} else {
		dst.timeSlotTimesChangeable = std::nullopt;
	}
	if (obj.containsKey("timeSlotTimeMode")) {
		dst.timeSlotTimeMode = obj["timeSlotTimeMode"].as<decltype(dst.timeSlotTimeMode)::value_type>();
	} else {
		dst.timeSlotTimeMode = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const TimeTableDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.timeSlotCountChangeable) {
		obj["timeSlotCountChangeable"] = *src.timeSlotCountChangeable;
	}
	if (src.timeSlotTimesChangeable) {
		obj["timeSlotTimesChangeable"] = *src.timeSlotTimesChangeable;
	}
	if (src.timeSlotTimeMode) {
		obj["timeSlotTimeMode"] = *src.timeSlotTimeMode;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("timeSlotCountChangeable")) {
		dst.timeSlotCountChangeable = obj["timeSlotCountChangeable"].as<decltype(dst.timeSlotCountChangeable)::value_type>();
	} else {
		dst.timeSlotCountChangeable = std::nullopt;
	}
	if (obj.containsKey("timeSlotTimesChangeable")) {
		dst.timeSlotTimesChangeable = obj["timeSlotTimesChangeable"].as<decltype(dst.timeSlotTimesChangeable)::value_type>();
	} else {
		dst.timeSlotTimesChangeable = std::nullopt;
	}
	if (obj.containsKey("timeSlotTimeMode")) {
		dst.timeSlotTimeMode = obj["timeSlotTimeMode"].as<decltype(dst.timeSlotTimeMode)::value_type>();
	} else {
		dst.timeSlotTimeMode = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const TimeTableDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableDescriptionData) {
		obj["timeTableDescriptionData"] = *src.timeTableDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableDescriptionData")) {
		dst.timeTableDescriptionData = obj["timeTableDescriptionData"].as<decltype(dst.timeTableDescriptionData)::value_type>();
	} else {
		dst.timeTableDescriptionData = std::nullopt;
	}

}
bool convertToJson(const TimeTableDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeTableDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariff) {
		obj["tariff"] = *src.tariff;
	}
	if (src.incentiveSlot) {
		obj["incentiveSlot"] = *src.incentiveSlot;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariff")) {
		dst.tariff = obj["tariff"].as<decltype(dst.tariff)::value_type>();
	} else {
		dst.tariff = std::nullopt;
	}
	if (obj.containsKey("incentiveSlot")) {
		dst.incentiveSlot = obj["incentiveSlot"].as<decltype(dst.incentiveSlot)::value_type>();
	} else {
		dst.incentiveSlot = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableIncentiveSlotType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeInterval) {
		obj["timeInterval"] = *src.timeInterval;
	}
	if (src.tier) {
		obj["tier"] = *src.tier;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableIncentiveSlotType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeInterval")) {
		dst.timeInterval = obj["timeInterval"].as<decltype(dst.timeInterval)::value_type>();
	} else {
		dst.timeInterval = std::nullopt;
	}
	if (obj.containsKey("tier")) {
		dst.tier = obj["tier"].as<decltype(dst.tier)::value_type>();
	} else {
		dst.tier = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableTierType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tier) {
		obj["tier"] = *src.tier;
	}
	if (src.boundary) {
		obj["boundary"] = *src.boundary;
	}
	if (src.incentive) {
		obj["incentive"] = *src.incentive;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableTierType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tier")) {
		dst.tier = obj["tier"].as<decltype(dst.tier)::value_type>();
	} else {
		dst.tier = std::nullopt;
	}
	if (obj.containsKey("boundary")) {
		dst.boundary = obj["boundary"].as<decltype(dst.boundary)::value_type>();
	} else {
		dst.boundary = std::nullopt;
	}
	if (obj.containsKey("incentive")) {
		dst.incentive = obj["incentive"].as<decltype(dst.incentive)::value_type>();
	} else {
		dst.incentive = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveTable) {
		obj["incentiveTable"] = *src.incentiveTable;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveTable")) {
		dst.incentiveTable = obj["incentiveTable"].as<decltype(dst.incentiveTable)::value_type>();
	} else {
		dst.incentiveTable = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariff) {
		obj["tariff"] = *src.tariff;
	}
	if (src.incentiveSlot) {
		obj["incentiveSlot"] = *src.incentiveSlot;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariff")) {
		dst.tariff = obj["tariff"].as<decltype(dst.tariff)::value_type>();
	} else {
		dst.tariff = std::nullopt;
	}
	if (obj.containsKey("incentiveSlot")) {
		dst.incentiveSlot = obj["incentiveSlot"].as<decltype(dst.incentiveSlot)::value_type>();
	} else {
		dst.incentiveSlot = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableIncentiveSlotElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timeInterval) {
		obj["timeInterval"] = *src.timeInterval;
	}
	if (src.tier) {
		obj["tier"] = *src.tier;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableIncentiveSlotElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timeInterval")) {
		dst.timeInterval = obj["timeInterval"].as<decltype(dst.timeInterval)::value_type>();
	} else {
		dst.timeInterval = std::nullopt;
	}
	if (obj.containsKey("tier")) {
		dst.tier = obj["tier"].as<decltype(dst.tier)::value_type>();
	} else {
		dst.tier = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableTierElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tier) {
		obj["tier"] = *src.tier;
	}
	if (src.boundary) {
		obj["boundary"] = *src.boundary;
	}
	if (src.incentive) {
		obj["incentive"] = *src.incentive;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableTierElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tier")) {
		dst.tier = obj["tier"].as<decltype(dst.tier)::value_type>();
	} else {
		dst.tier = std::nullopt;
	}
	if (obj.containsKey("boundary")) {
		dst.boundary = obj["boundary"].as<decltype(dst.boundary)::value_type>();
	} else {
		dst.boundary = std::nullopt;
	}
	if (obj.containsKey("incentive")) {
		dst.incentive = obj["incentive"].as<decltype(dst.incentive)::value_type>();
	} else {
		dst.incentive = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveTable) {
		obj["incentiveTable"] = *src.incentiveTable;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveTable")) {
		dst.incentiveTable = obj["incentiveTable"].as<decltype(dst.incentiveTable)::value_type>();
	} else {
		dst.incentiveTable = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariff) {
		obj["tariff"] = *src.tariff;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariff")) {
		dst.tariff = obj["tariff"].as<decltype(dst.tariff)::value_type>();
	} else {
		dst.tariff = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDescriptionType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffDescription) {
		obj["tariffDescription"] = *src.tariffDescription;
	}
	if (src.tier) {
		obj["tier"] = *src.tier;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDescriptionType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffDescription")) {
		dst.tariffDescription = obj["tariffDescription"].as<decltype(dst.tariffDescription)::value_type>();
	} else {
		dst.tariffDescription = std::nullopt;
	}
	if (obj.containsKey("tier")) {
		dst.tier = obj["tier"].as<decltype(dst.tier)::value_type>();
	} else {
		dst.tier = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDescriptionTierType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierDescription) {
		obj["tierDescription"] = *src.tierDescription;
	}
	if (src.boundaryDescription) {
		obj["boundaryDescription"] = *src.boundaryDescription;
	}
	if (src.incentiveDescription) {
		obj["incentiveDescription"] = *src.incentiveDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDescriptionTierType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierDescription")) {
		dst.tierDescription = obj["tierDescription"].as<decltype(dst.tierDescription)::value_type>();
	} else {
		dst.tierDescription = std::nullopt;
	}
	if (obj.containsKey("boundaryDescription")) {
		dst.boundaryDescription = obj["boundaryDescription"].as<decltype(dst.boundaryDescription)::value_type>();
	} else {
		dst.boundaryDescription = std::nullopt;
	}
	if (obj.containsKey("incentiveDescription")) {
		dst.incentiveDescription = obj["incentiveDescription"].as<decltype(dst.incentiveDescription)::value_type>();
	} else {
		dst.incentiveDescription = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveTableDescription) {
		obj["incentiveTableDescription"] = *src.incentiveTableDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveTableDescription")) {
		dst.incentiveTableDescription = obj["incentiveTableDescription"].as<decltype(dst.incentiveTableDescription)::value_type>();
	} else {
		dst.incentiveTableDescription = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDescriptionElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffDescription) {
		obj["tariffDescription"] = *src.tariffDescription;
	}
	if (src.tier) {
		obj["tier"] = *src.tier;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDescriptionElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffDescription")) {
		dst.tariffDescription = obj["tariffDescription"].as<decltype(dst.tariffDescription)::value_type>();
	} else {
		dst.tariffDescription = std::nullopt;
	}
	if (obj.containsKey("tier")) {
		dst.tier = obj["tier"].as<decltype(dst.tier)::value_type>();
	} else {
		dst.tier = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDescriptionTierElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierDescription) {
		obj["tierDescription"] = *src.tierDescription;
	}
	if (src.boundaryDescription) {
		obj["boundaryDescription"] = *src.boundaryDescription;
	}
	if (src.incentiveDescription) {
		obj["incentiveDescription"] = *src.incentiveDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDescriptionTierElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierDescription")) {
		dst.tierDescription = obj["tierDescription"].as<decltype(dst.tierDescription)::value_type>();
	} else {
		dst.tierDescription = std::nullopt;
	}
	if (obj.containsKey("boundaryDescription")) {
		dst.boundaryDescription = obj["boundaryDescription"].as<decltype(dst.boundaryDescription)::value_type>();
	} else {
		dst.boundaryDescription = std::nullopt;
	}
	if (obj.containsKey("incentiveDescription")) {
		dst.incentiveDescription = obj["incentiveDescription"].as<decltype(dst.incentiveDescription)::value_type>();
	} else {
		dst.incentiveDescription = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveTableDescription) {
		obj["incentiveTableDescription"] = *src.incentiveTableDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveTableDescription")) {
		dst.incentiveTableDescription = obj["incentiveTableDescription"].as<decltype(dst.incentiveTableDescription)::value_type>();
	} else {
		dst.incentiveTableDescription = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableDescriptionDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffDescription) {
		obj["tariffDescription"] = *src.tariffDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableDescriptionDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffDescription")) {
		dst.tariffDescription = obj["tariffDescription"].as<decltype(dst.tariffDescription)::value_type>();
	} else {
		dst.tariffDescription = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableConstraintsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariff) {
		obj["tariff"] = *src.tariff;
	}
	if (src.tariffConstraints) {
		obj["tariffConstraints"] = *src.tariffConstraints;
	}
	if (src.incentiveSlotConstraints) {
		obj["incentiveSlotConstraints"] = *src.incentiveSlotConstraints;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableConstraintsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariff")) {
		dst.tariff = obj["tariff"].as<decltype(dst.tariff)::value_type>();
	} else {
		dst.tariff = std::nullopt;
	}
	if (obj.containsKey("tariffConstraints")) {
		dst.tariffConstraints = obj["tariffConstraints"].as<decltype(dst.tariffConstraints)::value_type>();
	} else {
		dst.tariffConstraints = std::nullopt;
	}
	if (obj.containsKey("incentiveSlotConstraints")) {
		dst.incentiveSlotConstraints = obj["incentiveSlotConstraints"].as<decltype(dst.incentiveSlotConstraints)::value_type>();
	} else {
		dst.incentiveSlotConstraints = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveTableConstraints) {
		obj["incentiveTableConstraints"] = *src.incentiveTableConstraints;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveTableConstraints")) {
		dst.incentiveTableConstraints = obj["incentiveTableConstraints"].as<decltype(dst.incentiveTableConstraints)::value_type>();
	} else {
		dst.incentiveTableConstraints = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableConstraintsElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariff) {
		obj["tariff"] = *src.tariff;
	}
	if (src.tariffConstraints) {
		obj["tariffConstraints"] = *src.tariffConstraints;
	}
	if (src.incentiveSlotConstraints) {
		obj["incentiveSlotConstraints"] = *src.incentiveSlotConstraints;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableConstraintsElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariff")) {
		dst.tariff = obj["tariff"].as<decltype(dst.tariff)::value_type>();
	} else {
		dst.tariff = std::nullopt;
	}
	if (obj.containsKey("tariffConstraints")) {
		dst.tariffConstraints = obj["tariffConstraints"].as<decltype(dst.tariffConstraints)::value_type>();
	} else {
		dst.tariffConstraints = std::nullopt;
	}
	if (obj.containsKey("incentiveSlotConstraints")) {
		dst.incentiveSlotConstraints = obj["incentiveSlotConstraints"].as<decltype(dst.incentiveSlotConstraints)::value_type>();
	} else {
		dst.incentiveSlotConstraints = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveTableConstraints) {
		obj["incentiveTableConstraints"] = *src.incentiveTableConstraints;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveTableConstraints")) {
		dst.incentiveTableConstraints = obj["incentiveTableConstraints"].as<decltype(dst.incentiveTableConstraints)::value_type>();
	} else {
		dst.incentiveTableConstraints = std::nullopt;
	}

}
bool convertToJson(const IncentiveTableConstraintsDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariff) {
		obj["tariff"] = *src.tariff;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveTableConstraintsDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariff")) {
		dst.tariff = obj["tariff"].as<decltype(dst.tariff)::value_type>();
	} else {
		dst.tariff = std::nullopt;
	}

}
bool convertToJson(const TariffOverallConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.maxTariffCount) {
		obj["maxTariffCount"] = *src.maxTariffCount;
	}
	if (src.maxBoundaryCount) {
		obj["maxBoundaryCount"] = *src.maxBoundaryCount;
	}
	if (src.maxTierCount) {
		obj["maxTierCount"] = *src.maxTierCount;
	}
	if (src.maxIncentiveCount) {
		obj["maxIncentiveCount"] = *src.maxIncentiveCount;
	}
	if (src.maxBoundariesPerTariff) {
		obj["maxBoundariesPerTariff"] = *src.maxBoundariesPerTariff;
	}
	if (src.maxTiersPerTariff) {
		obj["maxTiersPerTariff"] = *src.maxTiersPerTariff;
	}
	if (src.maxBoundariesPerTier) {
		obj["maxBoundariesPerTier"] = *src.maxBoundariesPerTier;
	}
	if (src.maxIncentivesPerTier) {
		obj["maxIncentivesPerTier"] = *src.maxIncentivesPerTier;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffOverallConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("maxTariffCount")) {
		dst.maxTariffCount = obj["maxTariffCount"].as<decltype(dst.maxTariffCount)::value_type>();
	} else {
		dst.maxTariffCount = std::nullopt;
	}
	if (obj.containsKey("maxBoundaryCount")) {
		dst.maxBoundaryCount = obj["maxBoundaryCount"].as<decltype(dst.maxBoundaryCount)::value_type>();
	} else {
		dst.maxBoundaryCount = std::nullopt;
	}
	if (obj.containsKey("maxTierCount")) {
		dst.maxTierCount = obj["maxTierCount"].as<decltype(dst.maxTierCount)::value_type>();
	} else {
		dst.maxTierCount = std::nullopt;
	}
	if (obj.containsKey("maxIncentiveCount")) {
		dst.maxIncentiveCount = obj["maxIncentiveCount"].as<decltype(dst.maxIncentiveCount)::value_type>();
	} else {
		dst.maxIncentiveCount = std::nullopt;
	}
	if (obj.containsKey("maxBoundariesPerTariff")) {
		dst.maxBoundariesPerTariff = obj["maxBoundariesPerTariff"].as<decltype(dst.maxBoundariesPerTariff)::value_type>();
	} else {
		dst.maxBoundariesPerTariff = std::nullopt;
	}
	if (obj.containsKey("maxTiersPerTariff")) {
		dst.maxTiersPerTariff = obj["maxTiersPerTariff"].as<decltype(dst.maxTiersPerTariff)::value_type>();
	} else {
		dst.maxTiersPerTariff = std::nullopt;
	}
	if (obj.containsKey("maxBoundariesPerTier")) {
		dst.maxBoundariesPerTier = obj["maxBoundariesPerTier"].as<decltype(dst.maxBoundariesPerTier)::value_type>();
	} else {
		dst.maxBoundariesPerTier = std::nullopt;
	}
	if (obj.containsKey("maxIncentivesPerTier")) {
		dst.maxIncentivesPerTier = obj["maxIncentivesPerTier"].as<decltype(dst.maxIncentivesPerTier)::value_type>();
	} else {
		dst.maxIncentivesPerTier = std::nullopt;
	}

}
bool convertToJson(const TariffOverallConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.maxTariffCount) {
		obj["maxTariffCount"] = *src.maxTariffCount;
	}
	if (src.maxBoundaryCount) {
		obj["maxBoundaryCount"] = *src.maxBoundaryCount;
	}
	if (src.maxTierCount) {
		obj["maxTierCount"] = *src.maxTierCount;
	}
	if (src.maxIncentiveCount) {
		obj["maxIncentiveCount"] = *src.maxIncentiveCount;
	}
	if (src.maxBoundariesPerTariff) {
		obj["maxBoundariesPerTariff"] = *src.maxBoundariesPerTariff;
	}
	if (src.maxTiersPerTariff) {
		obj["maxTiersPerTariff"] = *src.maxTiersPerTariff;
	}
	if (src.maxBoundariesPerTier) {
		obj["maxBoundariesPerTier"] = *src.maxBoundariesPerTier;
	}
	if (src.maxIncentivesPerTier) {
		obj["maxIncentivesPerTier"] = *src.maxIncentivesPerTier;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffOverallConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("maxTariffCount")) {
		dst.maxTariffCount = obj["maxTariffCount"].as<decltype(dst.maxTariffCount)::value_type>();
	} else {
		dst.maxTariffCount = std::nullopt;
	}
	if (obj.containsKey("maxBoundaryCount")) {
		dst.maxBoundaryCount = obj["maxBoundaryCount"].as<decltype(dst.maxBoundaryCount)::value_type>();
	} else {
		dst.maxBoundaryCount = std::nullopt;
	}
	if (obj.containsKey("maxTierCount")) {
		dst.maxTierCount = obj["maxTierCount"].as<decltype(dst.maxTierCount)::value_type>();
	} else {
		dst.maxTierCount = std::nullopt;
	}
	if (obj.containsKey("maxIncentiveCount")) {
		dst.maxIncentiveCount = obj["maxIncentiveCount"].as<decltype(dst.maxIncentiveCount)::value_type>();
	} else {
		dst.maxIncentiveCount = std::nullopt;
	}
	if (obj.containsKey("maxBoundariesPerTariff")) {
		dst.maxBoundariesPerTariff = obj["maxBoundariesPerTariff"].as<decltype(dst.maxBoundariesPerTariff)::value_type>();
	} else {
		dst.maxBoundariesPerTariff = std::nullopt;
	}
	if (obj.containsKey("maxTiersPerTariff")) {
		dst.maxTiersPerTariff = obj["maxTiersPerTariff"].as<decltype(dst.maxTiersPerTariff)::value_type>();
	} else {
		dst.maxTiersPerTariff = std::nullopt;
	}
	if (obj.containsKey("maxBoundariesPerTier")) {
		dst.maxBoundariesPerTier = obj["maxBoundariesPerTier"].as<decltype(dst.maxBoundariesPerTier)::value_type>();
	} else {
		dst.maxBoundariesPerTier = std::nullopt;
	}
	if (obj.containsKey("maxIncentivesPerTier")) {
		dst.maxIncentivesPerTier = obj["maxIncentivesPerTier"].as<decltype(dst.maxIncentivesPerTier)::value_type>();
	} else {
		dst.maxIncentivesPerTier = std::nullopt;
	}

}
bool convertToJson(const TariffDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.activeTierId) {
		obj["activeTierId"] = *src.activeTierId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("activeTierId")) {
		dst.activeTierId = obj["activeTierId"].as<decltype(dst.activeTierId)::value_type>();
	} else {
		dst.activeTierId = std::nullopt;
	}

}
bool convertToJson(const TariffDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.activeTierId) {
		obj["activeTierId"] = *src.activeTierId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("activeTierId")) {
		dst.activeTierId = obj["activeTierId"].as<decltype(dst.activeTierId)::value_type>();
	} else {
		dst.activeTierId = std::nullopt;
	}

}
bool convertToJson(const TariffListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffData) {
		obj["tariffData"] = *src.tariffData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffData")) {
		dst.tariffData = obj["tariffData"].as<decltype(dst.tariffData)::value_type>();
	} else {
		dst.tariffData = std::nullopt;
	}

}
bool convertToJson(const TariffListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.activeTierId) {
		obj["activeTierId"] = *src.activeTierId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("activeTierId")) {
		dst.activeTierId = obj["activeTierId"].as<decltype(dst.activeTierId)::value_type>();
	} else {
		dst.activeTierId = std::nullopt;
	}

}
bool convertToJson(const TariffTierRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffTierRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}

}
bool convertToJson(const TariffTierRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffTierRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}

}
bool convertToJson(const TariffTierRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffTierRelationData) {
		obj["tariffTierRelationData"] = *src.tariffTierRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffTierRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffTierRelationData")) {
		dst.tariffTierRelationData = obj["tariffTierRelationData"].as<decltype(dst.tariffTierRelationData)::value_type>();
	} else {
		dst.tariffTierRelationData = std::nullopt;
	}

}
bool convertToJson(const TariffTierRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffTierRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}

}
bool convertToJson(const TariffBoundaryRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffBoundaryRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}

}
bool convertToJson(const TariffBoundaryRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffBoundaryRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}

}
bool convertToJson(const TariffBoundaryRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffBoundaryRelationData) {
		obj["tariffBoundaryRelationData"] = *src.tariffBoundaryRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffBoundaryRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffBoundaryRelationData")) {
		dst.tariffBoundaryRelationData = obj["tariffBoundaryRelationData"].as<decltype(dst.tariffBoundaryRelationData)::value_type>();
	} else {
		dst.tariffBoundaryRelationData = std::nullopt;
	}

}
bool convertToJson(const TariffBoundaryRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffBoundaryRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}

}
bool convertToJson(const TariffDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.commodityId) {
		obj["commodityId"] = *src.commodityId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.tariffWriteable) {
		obj["tariffWriteable"] = *src.tariffWriteable;
	}
	if (src.updateRequired) {
		obj["updateRequired"] = *src.updateRequired;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.slotIdSupport) {
		obj["slotIdSupport"] = *src.slotIdSupport;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("commodityId")) {
		dst.commodityId = obj["commodityId"].as<decltype(dst.commodityId)::value_type>();
	} else {
		dst.commodityId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("tariffWriteable")) {
		dst.tariffWriteable = obj["tariffWriteable"].as<decltype(dst.tariffWriteable)::value_type>();
	} else {
		dst.tariffWriteable = std::nullopt;
	}
	if (obj.containsKey("updateRequired")) {
		dst.updateRequired = obj["updateRequired"].as<decltype(dst.updateRequired)::value_type>();
	} else {
		dst.updateRequired = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("slotIdSupport")) {
		dst.slotIdSupport = obj["slotIdSupport"].as<decltype(dst.slotIdSupport)::value_type>();
	} else {
		dst.slotIdSupport = std::nullopt;
	}

}
bool convertToJson(const TariffDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.commodityId) {
		obj["commodityId"] = *src.commodityId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.tariffWriteable) {
		obj["tariffWriteable"] = *src.tariffWriteable;
	}
	if (src.updateRequired) {
		obj["updateRequired"] = *src.updateRequired;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.slotIdSupport) {
		obj["slotIdSupport"] = *src.slotIdSupport;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("commodityId")) {
		dst.commodityId = obj["commodityId"].as<decltype(dst.commodityId)::value_type>();
	} else {
		dst.commodityId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("tariffWriteable")) {
		dst.tariffWriteable = obj["tariffWriteable"].as<decltype(dst.tariffWriteable)::value_type>();
	} else {
		dst.tariffWriteable = std::nullopt;
	}
	if (obj.containsKey("updateRequired")) {
		dst.updateRequired = obj["updateRequired"].as<decltype(dst.updateRequired)::value_type>();
	} else {
		dst.updateRequired = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("slotIdSupport")) {
		dst.slotIdSupport = obj["slotIdSupport"].as<decltype(dst.slotIdSupport)::value_type>();
	} else {
		dst.slotIdSupport = std::nullopt;
	}

}
bool convertToJson(const TariffDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffDescriptionData) {
		obj["tariffDescriptionData"] = *src.tariffDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffDescriptionData")) {
		dst.tariffDescriptionData = obj["tariffDescriptionData"].as<decltype(dst.tariffDescriptionData)::value_type>();
	} else {
		dst.tariffDescriptionData = std::nullopt;
	}

}
bool convertToJson(const TariffDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tariffId) {
		obj["tariffId"] = *src.tariffId;
	}
	if (src.commodityId) {
		obj["commodityId"] = *src.commodityId;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TariffDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tariffId")) {
		dst.tariffId = obj["tariffId"].as<decltype(dst.tariffId)::value_type>();
	} else {
		dst.tariffId = std::nullopt;
	}
	if (obj.containsKey("commodityId")) {
		dst.commodityId = obj["commodityId"].as<decltype(dst.commodityId)::value_type>();
	} else {
		dst.commodityId = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const TierBoundaryDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.lowerBoundaryValue) {
		obj["lowerBoundaryValue"] = *src.lowerBoundaryValue;
	}
	if (src.upperBoundaryValue) {
		obj["upperBoundaryValue"] = *src.upperBoundaryValue;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("lowerBoundaryValue")) {
		dst.lowerBoundaryValue = obj["lowerBoundaryValue"].as<decltype(dst.lowerBoundaryValue)::value_type>();
	} else {
		dst.lowerBoundaryValue = std::nullopt;
	}
	if (obj.containsKey("upperBoundaryValue")) {
		dst.upperBoundaryValue = obj["upperBoundaryValue"].as<decltype(dst.upperBoundaryValue)::value_type>();
	} else {
		dst.upperBoundaryValue = std::nullopt;
	}

}
bool convertToJson(const TierBoundaryDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.lowerBoundaryValue) {
		obj["lowerBoundaryValue"] = *src.lowerBoundaryValue;
	}
	if (src.upperBoundaryValue) {
		obj["upperBoundaryValue"] = *src.upperBoundaryValue;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("lowerBoundaryValue")) {
		dst.lowerBoundaryValue = obj["lowerBoundaryValue"].as<decltype(dst.lowerBoundaryValue)::value_type>();
	} else {
		dst.lowerBoundaryValue = std::nullopt;
	}
	if (obj.containsKey("upperBoundaryValue")) {
		dst.upperBoundaryValue = obj["upperBoundaryValue"].as<decltype(dst.upperBoundaryValue)::value_type>();
	} else {
		dst.upperBoundaryValue = std::nullopt;
	}

}
bool convertToJson(const TierBoundaryListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierBoundaryData) {
		obj["tierBoundaryData"] = *src.tierBoundaryData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierBoundaryData")) {
		dst.tierBoundaryData = obj["tierBoundaryData"].as<decltype(dst.tierBoundaryData)::value_type>();
	} else {
		dst.tierBoundaryData = std::nullopt;
	}

}
bool convertToJson(const TierBoundaryListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}

}
bool convertToJson(const TierBoundaryDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}
	if (src.boundaryType) {
		obj["boundaryType"] = *src.boundaryType;
	}
	if (src.validForTierId) {
		obj["validForTierId"] = *src.validForTierId;
	}
	if (src.switchToTierIdWhenLower) {
		obj["switchToTierIdWhenLower"] = *src.switchToTierIdWhenLower;
	}
	if (src.switchToTierIdWhenHigher) {
		obj["switchToTierIdWhenHigher"] = *src.switchToTierIdWhenHigher;
	}
	if (src.boundaryUnit) {
		obj["boundaryUnit"] = *src.boundaryUnit;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}
	if (obj.containsKey("boundaryType")) {
		dst.boundaryType = obj["boundaryType"].as<decltype(dst.boundaryType)::value_type>();
	} else {
		dst.boundaryType = std::nullopt;
	}
	if (obj.containsKey("validForTierId")) {
		dst.validForTierId = obj["validForTierId"].as<decltype(dst.validForTierId)::value_type>();
	} else {
		dst.validForTierId = std::nullopt;
	}
	if (obj.containsKey("switchToTierIdWhenLower")) {
		dst.switchToTierIdWhenLower = obj["switchToTierIdWhenLower"].as<decltype(dst.switchToTierIdWhenLower)::value_type>();
	} else {
		dst.switchToTierIdWhenLower = std::nullopt;
	}
	if (obj.containsKey("switchToTierIdWhenHigher")) {
		dst.switchToTierIdWhenHigher = obj["switchToTierIdWhenHigher"].as<decltype(dst.switchToTierIdWhenHigher)::value_type>();
	} else {
		dst.switchToTierIdWhenHigher = std::nullopt;
	}
	if (obj.containsKey("boundaryUnit")) {
		dst.boundaryUnit = obj["boundaryUnit"].as<decltype(dst.boundaryUnit)::value_type>();
	} else {
		dst.boundaryUnit = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const TierBoundaryDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}
	if (src.boundaryType) {
		obj["boundaryType"] = *src.boundaryType;
	}
	if (src.validForTierId) {
		obj["validForTierId"] = *src.validForTierId;
	}
	if (src.switchToTierIdWhenLower) {
		obj["switchToTierIdWhenLower"] = *src.switchToTierIdWhenLower;
	}
	if (src.switchToTierIdWhenHigher) {
		obj["switchToTierIdWhenHigher"] = *src.switchToTierIdWhenHigher;
	}
	if (src.boundaryUnit) {
		obj["boundaryUnit"] = *src.boundaryUnit;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}
	if (obj.containsKey("boundaryType")) {
		dst.boundaryType = obj["boundaryType"].as<decltype(dst.boundaryType)::value_type>();
	} else {
		dst.boundaryType = std::nullopt;
	}
	if (obj.containsKey("validForTierId")) {
		dst.validForTierId = obj["validForTierId"].as<decltype(dst.validForTierId)::value_type>();
	} else {
		dst.validForTierId = std::nullopt;
	}
	if (obj.containsKey("switchToTierIdWhenLower")) {
		dst.switchToTierIdWhenLower = obj["switchToTierIdWhenLower"].as<decltype(dst.switchToTierIdWhenLower)::value_type>();
	} else {
		dst.switchToTierIdWhenLower = std::nullopt;
	}
	if (obj.containsKey("switchToTierIdWhenHigher")) {
		dst.switchToTierIdWhenHigher = obj["switchToTierIdWhenHigher"].as<decltype(dst.switchToTierIdWhenHigher)::value_type>();
	} else {
		dst.switchToTierIdWhenHigher = std::nullopt;
	}
	if (obj.containsKey("boundaryUnit")) {
		dst.boundaryUnit = obj["boundaryUnit"].as<decltype(dst.boundaryUnit)::value_type>();
	} else {
		dst.boundaryUnit = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const TierBoundaryDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierBoundaryDescriptionData) {
		obj["tierBoundaryDescriptionData"] = *src.tierBoundaryDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierBoundaryDescriptionData")) {
		dst.tierBoundaryDescriptionData = obj["tierBoundaryDescriptionData"].as<decltype(dst.tierBoundaryDescriptionData)::value_type>();
	} else {
		dst.tierBoundaryDescriptionData = std::nullopt;
	}

}
bool convertToJson(const TierBoundaryDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.boundaryId) {
		obj["boundaryId"] = *src.boundaryId;
	}
	if (src.boundaryType) {
		obj["boundaryType"] = *src.boundaryType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierBoundaryDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("boundaryId")) {
		dst.boundaryId = obj["boundaryId"].as<decltype(dst.boundaryId)::value_type>();
	} else {
		dst.boundaryId = std::nullopt;
	}
	if (obj.containsKey("boundaryType")) {
		dst.boundaryType = obj["boundaryType"].as<decltype(dst.boundaryType)::value_type>();
	} else {
		dst.boundaryType = std::nullopt;
	}

}
bool convertToJson(const CommodityDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.commodityId) {
		obj["commodityId"] = *src.commodityId;
	}
	if (src.commodityType) {
		obj["commodityType"] = *src.commodityType;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, CommodityDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("commodityId")) {
		dst.commodityId = obj["commodityId"].as<decltype(dst.commodityId)::value_type>();
	} else {
		dst.commodityId = std::nullopt;
	}
	if (obj.containsKey("commodityType")) {
		dst.commodityType = obj["commodityType"].as<decltype(dst.commodityType)::value_type>();
	} else {
		dst.commodityType = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const CommodityDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.commodityId) {
		obj["commodityId"] = *src.commodityId;
	}
	if (src.commodityType) {
		obj["commodityType"] = *src.commodityType;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, CommodityDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("commodityId")) {
		dst.commodityId = obj["commodityId"].as<decltype(dst.commodityId)::value_type>();
	} else {
		dst.commodityId = std::nullopt;
	}
	if (obj.containsKey("commodityType")) {
		dst.commodityType = obj["commodityType"].as<decltype(dst.commodityType)::value_type>();
	} else {
		dst.commodityType = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const CommodityListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.commodityData) {
		obj["commodityData"] = *src.commodityData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, CommodityListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("commodityData")) {
		dst.commodityData = obj["commodityData"].as<decltype(dst.commodityData)::value_type>();
	} else {
		dst.commodityData = std::nullopt;
	}

}
bool convertToJson(const CommodityListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.commodityId) {
		obj["commodityId"] = *src.commodityId;
	}
	if (src.commodityType) {
		obj["commodityType"] = *src.commodityType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, CommodityListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("commodityId")) {
		dst.commodityId = obj["commodityId"].as<decltype(dst.commodityId)::value_type>();
	} else {
		dst.commodityId = std::nullopt;
	}
	if (obj.containsKey("commodityType")) {
		dst.commodityType = obj["commodityType"].as<decltype(dst.commodityType)::value_type>();
	} else {
		dst.commodityType = std::nullopt;
	}

}
bool convertToJson(const TierDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.activeIncentiveId) {
		obj["activeIncentiveId"] = *src.activeIncentiveId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("activeIncentiveId")) {
		dst.activeIncentiveId = obj["activeIncentiveId"].as<decltype(dst.activeIncentiveId)::value_type>();
	} else {
		dst.activeIncentiveId = std::nullopt;
	}

}
bool convertToJson(const TierDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.activeIncentiveId) {
		obj["activeIncentiveId"] = *src.activeIncentiveId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("activeIncentiveId")) {
		dst.activeIncentiveId = obj["activeIncentiveId"].as<decltype(dst.activeIncentiveId)::value_type>();
	} else {
		dst.activeIncentiveId = std::nullopt;
	}

}
bool convertToJson(const TierListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierData) {
		obj["tierData"] = *src.tierData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierData")) {
		dst.tierData = obj["tierData"].as<decltype(dst.tierData)::value_type>();
	} else {
		dst.tierData = std::nullopt;
	}

}
bool convertToJson(const TierListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.activeIncentiveId) {
		obj["activeIncentiveId"] = *src.activeIncentiveId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("activeIncentiveId")) {
		dst.activeIncentiveId = obj["activeIncentiveId"].as<decltype(dst.activeIncentiveId)::value_type>();
	} else {
		dst.activeIncentiveId = std::nullopt;
	}

}
bool convertToJson(const TierIncentiveRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierIncentiveRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}

}
bool convertToJson(const TierIncentiveRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierIncentiveRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}

}
bool convertToJson(const TierIncentiveRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierIncentiveRelationData) {
		obj["tierIncentiveRelationData"] = *src.tierIncentiveRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierIncentiveRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierIncentiveRelationData")) {
		dst.tierIncentiveRelationData = obj["tierIncentiveRelationData"].as<decltype(dst.tierIncentiveRelationData)::value_type>();
	} else {
		dst.tierIncentiveRelationData = std::nullopt;
	}

}
bool convertToJson(const TierIncentiveRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierIncentiveRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}

}
bool convertToJson(const TierDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.tierType) {
		obj["tierType"] = *src.tierType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("tierType")) {
		dst.tierType = obj["tierType"].as<decltype(dst.tierType)::value_type>();
	} else {
		dst.tierType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const TierDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.tierType) {
		obj["tierType"] = *src.tierType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("tierType")) {
		dst.tierType = obj["tierType"].as<decltype(dst.tierType)::value_type>();
	} else {
		dst.tierType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const TierDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierDescriptionData) {
		obj["tierDescriptionData"] = *src.tierDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierDescriptionData")) {
		dst.tierDescriptionData = obj["tierDescriptionData"].as<decltype(dst.tierDescriptionData)::value_type>();
	} else {
		dst.tierDescriptionData = std::nullopt;
	}

}
bool convertToJson(const TierDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.tierId) {
		obj["tierId"] = *src.tierId;
	}
	if (src.tierType) {
		obj["tierType"] = *src.tierType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TierDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("tierId")) {
		dst.tierId = obj["tierId"].as<decltype(dst.tierId)::value_type>();
	} else {
		dst.tierId = std::nullopt;
	}
	if (obj.containsKey("tierType")) {
		dst.tierType = obj["tierType"].as<decltype(dst.tierType)::value_type>();
	} else {
		dst.tierType = std::nullopt;
	}

}
bool convertToJson(const IncentiveDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const IncentiveDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.timeTableId) {
		obj["timeTableId"] = *src.timeTableId;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("timeTableId")) {
		dst.timeTableId = obj["timeTableId"].as<decltype(dst.timeTableId)::value_type>();
	} else {
		dst.timeTableId = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const IncentiveListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveData) {
		obj["incentiveData"] = *src.incentiveData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveData")) {
		dst.incentiveData = obj["incentiveData"].as<decltype(dst.incentiveData)::value_type>();
	} else {
		dst.incentiveData = std::nullopt;
	}

}
bool convertToJson(const IncentiveListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}
	if (src.valueType) {
		obj["valueType"] = *src.valueType;
	}
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}
	if (obj.containsKey("valueType")) {
		dst.valueType = obj["valueType"].as<decltype(dst.valueType)::value_type>();
	} else {
		dst.valueType = std::nullopt;
	}
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}

}
bool convertToJson(const IncentiveDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}
	if (src.incentiveType) {
		obj["incentiveType"] = *src.incentiveType;
	}
	if (src.incentivePriority) {
		obj["incentivePriority"] = *src.incentivePriority;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}
	if (obj.containsKey("incentiveType")) {
		dst.incentiveType = obj["incentiveType"].as<decltype(dst.incentiveType)::value_type>();
	} else {
		dst.incentiveType = std::nullopt;
	}
	if (obj.containsKey("incentivePriority")) {
		dst.incentivePriority = obj["incentivePriority"].as<decltype(dst.incentivePriority)::value_type>();
	} else {
		dst.incentivePriority = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const IncentiveDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}
	if (src.incentiveType) {
		obj["incentiveType"] = *src.incentiveType;
	}
	if (src.incentivePriority) {
		obj["incentivePriority"] = *src.incentivePriority;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}
	if (obj.containsKey("incentiveType")) {
		dst.incentiveType = obj["incentiveType"].as<decltype(dst.incentiveType)::value_type>();
	} else {
		dst.incentiveType = std::nullopt;
	}
	if (obj.containsKey("incentivePriority")) {
		dst.incentivePriority = obj["incentivePriority"].as<decltype(dst.incentivePriority)::value_type>();
	} else {
		dst.incentivePriority = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const IncentiveDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveDescriptionData) {
		obj["incentiveDescriptionData"] = *src.incentiveDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveDescriptionData")) {
		dst.incentiveDescriptionData = obj["incentiveDescriptionData"].as<decltype(dst.incentiveDescriptionData)::value_type>();
	} else {
		dst.incentiveDescriptionData = std::nullopt;
	}

}
bool convertToJson(const IncentiveDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.incentiveId) {
		obj["incentiveId"] = *src.incentiveId;
	}
	if (src.incentiveType) {
		obj["incentiveType"] = *src.incentiveType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, IncentiveDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("incentiveId")) {
		dst.incentiveId = obj["incentiveId"].as<decltype(dst.incentiveId)::value_type>();
	} else {
		dst.incentiveId = std::nullopt;
	}
	if (obj.containsKey("incentiveType")) {
		dst.incentiveType = obj["incentiveType"].as<decltype(dst.incentiveType)::value_type>();
	} else {
		dst.incentiveType = std::nullopt;
	}

}
bool convertToJson(const LoadControlNodeDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.isNodeRemoteControllable) {
		obj["isNodeRemoteControllable"] = *src.isNodeRemoteControllable;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlNodeDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("isNodeRemoteControllable")) {
		dst.isNodeRemoteControllable = obj["isNodeRemoteControllable"].as<decltype(dst.isNodeRemoteControllable)::value_type>();
	} else {
		dst.isNodeRemoteControllable = std::nullopt;
	}

}
bool convertToJson(const LoadControlNodeDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.isNodeRemoteControllable) {
		obj["isNodeRemoteControllable"] = *src.isNodeRemoteControllable;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlNodeDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("isNodeRemoteControllable")) {
		dst.isNodeRemoteControllable = obj["isNodeRemoteControllable"].as<decltype(dst.isNodeRemoteControllable)::value_type>();
	} else {
		dst.isNodeRemoteControllable = std::nullopt;
	}

}
bool convertToJson(const LoadControlEventDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.eventId) {
		obj["eventId"] = *src.eventId;
	}
	if (src.eventActionConsume) {
		obj["eventActionConsume"] = *src.eventActionConsume;
	}
	if (src.eventActionProduce) {
		obj["eventActionProduce"] = *src.eventActionProduce;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlEventDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("eventId")) {
		dst.eventId = obj["eventId"].as<decltype(dst.eventId)::value_type>();
	} else {
		dst.eventId = std::nullopt;
	}
	if (obj.containsKey("eventActionConsume")) {
		dst.eventActionConsume = obj["eventActionConsume"].as<decltype(dst.eventActionConsume)::value_type>();
	} else {
		dst.eventActionConsume = std::nullopt;
	}
	if (obj.containsKey("eventActionProduce")) {
		dst.eventActionProduce = obj["eventActionProduce"].as<decltype(dst.eventActionProduce)::value_type>();
	} else {
		dst.eventActionProduce = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}

}
bool convertToJson(const LoadControlEventDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.eventId) {
		obj["eventId"] = *src.eventId;
	}
	if (src.eventActionConsume) {
		obj["eventActionConsume"] = *src.eventActionConsume;
	}
	if (src.eventActionProduce) {
		obj["eventActionProduce"] = *src.eventActionProduce;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlEventDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("eventId")) {
		dst.eventId = obj["eventId"].as<decltype(dst.eventId)::value_type>();
	} else {
		dst.eventId = std::nullopt;
	}
	if (obj.containsKey("eventActionConsume")) {
		dst.eventActionConsume = obj["eventActionConsume"].as<decltype(dst.eventActionConsume)::value_type>();
	} else {
		dst.eventActionConsume = std::nullopt;
	}
	if (obj.containsKey("eventActionProduce")) {
		dst.eventActionProduce = obj["eventActionProduce"].as<decltype(dst.eventActionProduce)::value_type>();
	} else {
		dst.eventActionProduce = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}

}
bool convertToJson(const LoadControlEventListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadControlEventData) {
		obj["loadControlEventData"] = *src.loadControlEventData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlEventListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("loadControlEventData")) {
		dst.loadControlEventData = obj["loadControlEventData"].as<decltype(dst.loadControlEventData)::value_type>();
	} else {
		dst.loadControlEventData = std::nullopt;
	}

}
bool convertToJson(const LoadControlEventListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}
	if (src.eventId) {
		obj["eventId"] = *src.eventId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlEventListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}
	if (obj.containsKey("eventId")) {
		dst.eventId = obj["eventId"].as<decltype(dst.eventId)::value_type>();
	} else {
		dst.eventId = std::nullopt;
	}

}
bool convertToJson(const LoadControlStateDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.eventId) {
		obj["eventId"] = *src.eventId;
	}
	if (src.eventStateConsume) {
		obj["eventStateConsume"] = *src.eventStateConsume;
	}
	if (src.appliedEventActionConsume) {
		obj["appliedEventActionConsume"] = *src.appliedEventActionConsume;
	}
	if (src.eventStateProduce) {
		obj["eventStateProduce"] = *src.eventStateProduce;
	}
	if (src.appliedEventActionProduce) {
		obj["appliedEventActionProduce"] = *src.appliedEventActionProduce;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlStateDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("eventId")) {
		dst.eventId = obj["eventId"].as<decltype(dst.eventId)::value_type>();
	} else {
		dst.eventId = std::nullopt;
	}
	if (obj.containsKey("eventStateConsume")) {
		dst.eventStateConsume = obj["eventStateConsume"].as<decltype(dst.eventStateConsume)::value_type>();
	} else {
		dst.eventStateConsume = std::nullopt;
	}
	if (obj.containsKey("appliedEventActionConsume")) {
		dst.appliedEventActionConsume = obj["appliedEventActionConsume"].as<decltype(dst.appliedEventActionConsume)::value_type>();
	} else {
		dst.appliedEventActionConsume = std::nullopt;
	}
	if (obj.containsKey("eventStateProduce")) {
		dst.eventStateProduce = obj["eventStateProduce"].as<decltype(dst.eventStateProduce)::value_type>();
	} else {
		dst.eventStateProduce = std::nullopt;
	}
	if (obj.containsKey("appliedEventActionProduce")) {
		dst.appliedEventActionProduce = obj["appliedEventActionProduce"].as<decltype(dst.appliedEventActionProduce)::value_type>();
	} else {
		dst.appliedEventActionProduce = std::nullopt;
	}

}
bool convertToJson(const LoadControlStateDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.eventId) {
		obj["eventId"] = *src.eventId;
	}
	if (src.eventStateConsume) {
		obj["eventStateConsume"] = *src.eventStateConsume;
	}
	if (src.appliedEventActionConsume) {
		obj["appliedEventActionConsume"] = *src.appliedEventActionConsume;
	}
	if (src.eventStateProduce) {
		obj["eventStateProduce"] = *src.eventStateProduce;
	}
	if (src.appliedEventActionProduce) {
		obj["appliedEventActionProduce"] = *src.appliedEventActionProduce;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlStateDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("eventId")) {
		dst.eventId = obj["eventId"].as<decltype(dst.eventId)::value_type>();
	} else {
		dst.eventId = std::nullopt;
	}
	if (obj.containsKey("eventStateConsume")) {
		dst.eventStateConsume = obj["eventStateConsume"].as<decltype(dst.eventStateConsume)::value_type>();
	} else {
		dst.eventStateConsume = std::nullopt;
	}
	if (obj.containsKey("appliedEventActionConsume")) {
		dst.appliedEventActionConsume = obj["appliedEventActionConsume"].as<decltype(dst.appliedEventActionConsume)::value_type>();
	} else {
		dst.appliedEventActionConsume = std::nullopt;
	}
	if (obj.containsKey("eventStateProduce")) {
		dst.eventStateProduce = obj["eventStateProduce"].as<decltype(dst.eventStateProduce)::value_type>();
	} else {
		dst.eventStateProduce = std::nullopt;
	}
	if (obj.containsKey("appliedEventActionProduce")) {
		dst.appliedEventActionProduce = obj["appliedEventActionProduce"].as<decltype(dst.appliedEventActionProduce)::value_type>();
	} else {
		dst.appliedEventActionProduce = std::nullopt;
	}

}
bool convertToJson(const LoadControlStateListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadControlStateData) {
		obj["loadControlStateData"] = *src.loadControlStateData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlStateListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("loadControlStateData")) {
		dst.loadControlStateData = obj["loadControlStateData"].as<decltype(dst.loadControlStateData)::value_type>();
	} else {
		dst.loadControlStateData = std::nullopt;
	}

}
bool convertToJson(const LoadControlStateListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}
	if (src.eventId) {
		obj["eventId"] = *src.eventId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlStateListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}
	if (obj.containsKey("eventId")) {
		dst.eventId = obj["eventId"].as<decltype(dst.eventId)::value_type>();
	} else {
		dst.eventId = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}
	if (src.isLimitChangeable) {
		obj["isLimitChangeable"] = *src.isLimitChangeable;
	}
	if (src.isLimitActive) {
		obj["isLimitActive"] = *src.isLimitActive;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}
	if (obj.containsKey("isLimitChangeable")) {
		dst.isLimitChangeable = obj["isLimitChangeable"].as<decltype(dst.isLimitChangeable)::value_type>();
	} else {
		dst.isLimitChangeable = std::nullopt;
	}
	if (obj.containsKey("isLimitActive")) {
		dst.isLimitActive = obj["isLimitActive"].as<decltype(dst.isLimitActive)::value_type>();
	} else {
		dst.isLimitActive = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}
	if (src.isLimitChangeable) {
		obj["isLimitChangeable"] = *src.isLimitChangeable;
	}
	if (src.isLimitActive) {
		obj["isLimitActive"] = *src.isLimitActive;
	}
	if (src.timePeriod) {
		obj["timePeriod"] = *src.timePeriod;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}
	if (obj.containsKey("isLimitChangeable")) {
		dst.isLimitChangeable = obj["isLimitChangeable"].as<decltype(dst.isLimitChangeable)::value_type>();
	} else {
		dst.isLimitChangeable = std::nullopt;
	}
	if (obj.containsKey("isLimitActive")) {
		dst.isLimitActive = obj["isLimitActive"].as<decltype(dst.isLimitActive)::value_type>();
	} else {
		dst.isLimitActive = std::nullopt;
	}
	if (obj.containsKey("timePeriod")) {
		dst.timePeriod = obj["timePeriod"].as<decltype(dst.timePeriod)::value_type>();
	} else {
		dst.timePeriod = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadControlLimitData) {
		obj["loadControlLimitData"] = *src.loadControlLimitData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("loadControlLimitData")) {
		dst.loadControlLimitData = obj["loadControlLimitData"].as<decltype(dst.loadControlLimitData)::value_type>();
	} else {
		dst.loadControlLimitData = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitConstraintsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}
	if (src.valueRangeMin) {
		obj["valueRangeMin"] = *src.valueRangeMin;
	}
	if (src.valueRangeMax) {
		obj["valueRangeMax"] = *src.valueRangeMax;
	}
	if (src.valueStepSize) {
		obj["valueStepSize"] = *src.valueStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitConstraintsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}
	if (obj.containsKey("valueRangeMin")) {
		dst.valueRangeMin = obj["valueRangeMin"].as<decltype(dst.valueRangeMin)::value_type>();
	} else {
		dst.valueRangeMin = std::nullopt;
	}
	if (obj.containsKey("valueRangeMax")) {
		dst.valueRangeMax = obj["valueRangeMax"].as<decltype(dst.valueRangeMax)::value_type>();
	} else {
		dst.valueRangeMax = std::nullopt;
	}
	if (obj.containsKey("valueStepSize")) {
		dst.valueStepSize = obj["valueStepSize"].as<decltype(dst.valueStepSize)::value_type>();
	} else {
		dst.valueStepSize = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitConstraintsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}
	if (src.valueRangeMin) {
		obj["valueRangeMin"] = *src.valueRangeMin;
	}
	if (src.valueRangeMax) {
		obj["valueRangeMax"] = *src.valueRangeMax;
	}
	if (src.valueStepSize) {
		obj["valueStepSize"] = *src.valueStepSize;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitConstraintsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}
	if (obj.containsKey("valueRangeMin")) {
		dst.valueRangeMin = obj["valueRangeMin"].as<decltype(dst.valueRangeMin)::value_type>();
	} else {
		dst.valueRangeMin = std::nullopt;
	}
	if (obj.containsKey("valueRangeMax")) {
		dst.valueRangeMax = obj["valueRangeMax"].as<decltype(dst.valueRangeMax)::value_type>();
	} else {
		dst.valueRangeMax = std::nullopt;
	}
	if (obj.containsKey("valueStepSize")) {
		dst.valueStepSize = obj["valueStepSize"].as<decltype(dst.valueStepSize)::value_type>();
	} else {
		dst.valueStepSize = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitConstraintsListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadControlLimitConstraintsData) {
		obj["loadControlLimitConstraintsData"] = *src.loadControlLimitConstraintsData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitConstraintsListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("loadControlLimitConstraintsData")) {
		dst.loadControlLimitConstraintsData = obj["loadControlLimitConstraintsData"].as<decltype(dst.loadControlLimitConstraintsData)::value_type>();
	} else {
		dst.loadControlLimitConstraintsData = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitConstraintsListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitConstraintsListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}
	if (src.limitType) {
		obj["limitType"] = *src.limitType;
	}
	if (src.limitCategory) {
		obj["limitCategory"] = *src.limitCategory;
	}
	if (src.limitDirection) {
		obj["limitDirection"] = *src.limitDirection;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}
	if (obj.containsKey("limitType")) {
		dst.limitType = obj["limitType"].as<decltype(dst.limitType)::value_type>();
	} else {
		dst.limitType = std::nullopt;
	}
	if (obj.containsKey("limitCategory")) {
		dst.limitCategory = obj["limitCategory"].as<decltype(dst.limitCategory)::value_type>();
	} else {
		dst.limitCategory = std::nullopt;
	}
	if (obj.containsKey("limitDirection")) {
		dst.limitDirection = obj["limitDirection"].as<decltype(dst.limitDirection)::value_type>();
	} else {
		dst.limitDirection = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}
	if (src.limitType) {
		obj["limitType"] = *src.limitType;
	}
	if (src.limitCategory) {
		obj["limitCategory"] = *src.limitCategory;
	}
	if (src.limitDirection) {
		obj["limitDirection"] = *src.limitDirection;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}
	if (obj.containsKey("limitType")) {
		dst.limitType = obj["limitType"].as<decltype(dst.limitType)::value_type>();
	} else {
		dst.limitType = std::nullopt;
	}
	if (obj.containsKey("limitCategory")) {
		dst.limitCategory = obj["limitCategory"].as<decltype(dst.limitCategory)::value_type>();
	} else {
		dst.limitCategory = std::nullopt;
	}
	if (obj.containsKey("limitDirection")) {
		dst.limitDirection = obj["limitDirection"].as<decltype(dst.limitDirection)::value_type>();
	} else {
		dst.limitDirection = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.loadControlLimitDescriptionData) {
		obj["loadControlLimitDescriptionData"] = *src.loadControlLimitDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("loadControlLimitDescriptionData")) {
		dst.loadControlLimitDescriptionData = obj["loadControlLimitDescriptionData"].as<decltype(dst.loadControlLimitDescriptionData)::value_type>();
	} else {
		dst.loadControlLimitDescriptionData = std::nullopt;
	}

}
bool convertToJson(const LoadControlLimitDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.limitId) {
		obj["limitId"] = *src.limitId;
	}
	if (src.limitType) {
		obj["limitType"] = *src.limitType;
	}
	if (src.limitDirection) {
		obj["limitDirection"] = *src.limitDirection;
	}
	if (src.measurementId) {
		obj["measurementId"] = *src.measurementId;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, LoadControlLimitDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("limitId")) {
		dst.limitId = obj["limitId"].as<decltype(dst.limitId)::value_type>();
	} else {
		dst.limitId = std::nullopt;
	}
	if (obj.containsKey("limitType")) {
		dst.limitType = obj["limitType"].as<decltype(dst.limitType)::value_type>();
	} else {
		dst.limitType = std::nullopt;
	}
	if (obj.containsKey("limitDirection")) {
		dst.limitDirection = obj["limitDirection"].as<decltype(dst.limitDirection)::value_type>();
	} else {
		dst.limitDirection = std::nullopt;
	}
	if (obj.containsKey("measurementId")) {
		dst.measurementId = obj["measurementId"].as<decltype(dst.measurementId)::value_type>();
	} else {
		dst.measurementId = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementAddNodeCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeAddress) {
		obj["nodeAddress"] = *src.nodeAddress;
	}
	if (src.nativeSetup) {
		obj["nativeSetup"] = *src.nativeSetup;
	}
	if (src.timeout) {
		obj["timeout"] = *src.timeout;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementAddNodeCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeAddress")) {
		dst.nodeAddress = obj["nodeAddress"].as<decltype(dst.nodeAddress)::value_type>();
	} else {
		dst.nodeAddress = std::nullopt;
	}
	if (obj.containsKey("nativeSetup")) {
		dst.nativeSetup = obj["nativeSetup"].as<decltype(dst.nativeSetup)::value_type>();
	} else {
		dst.nativeSetup = std::nullopt;
	}
	if (obj.containsKey("timeout")) {
		dst.timeout = obj["timeout"].as<decltype(dst.timeout)::value_type>();
	} else {
		dst.timeout = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementAddNodeCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeAddress) {
		obj["nodeAddress"] = *src.nodeAddress;
	}
	if (src.nativeSetup) {
		obj["nativeSetup"] = *src.nativeSetup;
	}
	if (src.timeout) {
		obj["timeout"] = *src.timeout;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementAddNodeCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeAddress")) {
		dst.nodeAddress = obj["nodeAddress"].as<decltype(dst.nodeAddress)::value_type>();
	} else {
		dst.nodeAddress = std::nullopt;
	}
	if (obj.containsKey("nativeSetup")) {
		dst.nativeSetup = obj["nativeSetup"].as<decltype(dst.nativeSetup)::value_type>();
	} else {
		dst.nativeSetup = std::nullopt;
	}
	if (obj.containsKey("timeout")) {
		dst.timeout = obj["timeout"].as<decltype(dst.timeout)::value_type>();
	} else {
		dst.timeout = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementRemoveNodeCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeAddress) {
		obj["nodeAddress"] = *src.nodeAddress;
	}
	if (src.timeout) {
		obj["timeout"] = *src.timeout;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementRemoveNodeCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeAddress")) {
		dst.nodeAddress = obj["nodeAddress"].as<decltype(dst.nodeAddress)::value_type>();
	} else {
		dst.nodeAddress = std::nullopt;
	}
	if (obj.containsKey("timeout")) {
		dst.timeout = obj["timeout"].as<decltype(dst.timeout)::value_type>();
	} else {
		dst.timeout = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementRemoveNodeCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeAddress) {
		obj["nodeAddress"] = *src.nodeAddress;
	}
	if (src.timeout) {
		obj["timeout"] = *src.timeout;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementRemoveNodeCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeAddress")) {
		dst.nodeAddress = obj["nodeAddress"].as<decltype(dst.nodeAddress)::value_type>();
	} else {
		dst.nodeAddress = std::nullopt;
	}
	if (obj.containsKey("timeout")) {
		dst.timeout = obj["timeout"].as<decltype(dst.timeout)::value_type>();
	} else {
		dst.timeout = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementModifyNodeCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeAddress) {
		obj["nodeAddress"] = *src.nodeAddress;
	}
	if (src.nativeSetup) {
		obj["nativeSetup"] = *src.nativeSetup;
	}
	if (src.timeout) {
		obj["timeout"] = *src.timeout;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementModifyNodeCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeAddress")) {
		dst.nodeAddress = obj["nodeAddress"].as<decltype(dst.nodeAddress)::value_type>();
	} else {
		dst.nodeAddress = std::nullopt;
	}
	if (obj.containsKey("nativeSetup")) {
		dst.nativeSetup = obj["nativeSetup"].as<decltype(dst.nativeSetup)::value_type>();
	} else {
		dst.nativeSetup = std::nullopt;
	}
	if (obj.containsKey("timeout")) {
		dst.timeout = obj["timeout"].as<decltype(dst.timeout)::value_type>();
	} else {
		dst.timeout = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementModifyNodeCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeAddress) {
		obj["nodeAddress"] = *src.nodeAddress;
	}
	if (src.nativeSetup) {
		obj["nativeSetup"] = *src.nativeSetup;
	}
	if (src.timeout) {
		obj["timeout"] = *src.timeout;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementModifyNodeCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeAddress")) {
		dst.nodeAddress = obj["nodeAddress"].as<decltype(dst.nodeAddress)::value_type>();
	} else {
		dst.nodeAddress = std::nullopt;
	}
	if (obj.containsKey("nativeSetup")) {
		dst.nativeSetup = obj["nativeSetup"].as<decltype(dst.nativeSetup)::value_type>();
	} else {
		dst.nativeSetup = std::nullopt;
	}
	if (obj.containsKey("timeout")) {
		dst.timeout = obj["timeout"].as<decltype(dst.timeout)::value_type>();
	} else {
		dst.timeout = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementScanNetworkCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.scanSetup) {
		obj["scanSetup"] = *src.scanSetup;
	}
	if (src.timeout) {
		obj["timeout"] = *src.timeout;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementScanNetworkCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("scanSetup")) {
		dst.scanSetup = obj["scanSetup"].as<decltype(dst.scanSetup)::value_type>();
	} else {
		dst.scanSetup = std::nullopt;
	}
	if (obj.containsKey("timeout")) {
		dst.timeout = obj["timeout"].as<decltype(dst.timeout)::value_type>();
	} else {
		dst.timeout = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementScanNetworkCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.scanSetup) {
		obj["scanSetup"] = *src.scanSetup;
	}
	if (src.timeout) {
		obj["timeout"] = *src.timeout;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementScanNetworkCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("scanSetup")) {
		dst.scanSetup = obj["scanSetup"].as<decltype(dst.scanSetup)::value_type>();
	} else {
		dst.scanSetup = std::nullopt;
	}
	if (obj.containsKey("timeout")) {
		dst.timeout = obj["timeout"].as<decltype(dst.timeout)::value_type>();
	} else {
		dst.timeout = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementDiscoverCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.discoverAddress) {
		obj["discoverAddress"] = *src.discoverAddress;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementDiscoverCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("discoverAddress")) {
		dst.discoverAddress = obj["discoverAddress"].as<decltype(dst.discoverAddress)::value_type>();
	} else {
		dst.discoverAddress = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementDiscoverCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.discoverAddress) {
		obj["discoverAddress"] = *src.discoverAddress;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementDiscoverCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("discoverAddress")) {
		dst.discoverAddress = obj["discoverAddress"].as<decltype(dst.discoverAddress)::value_type>();
	} else {
		dst.discoverAddress = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementAbortCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementAbortCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const NetworkManagementAbortCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementAbortCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const NetworkManagementProcessStateDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.state) {
		obj["state"] = *src.state;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementProcessStateDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("state")) {
		dst.state = obj["state"].as<decltype(dst.state)::value_type>();
	} else {
		dst.state = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementProcessStateDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.state) {
		obj["state"] = *src.state;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementProcessStateDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("state")) {
		dst.state = obj["state"].as<decltype(dst.state)::value_type>();
	} else {
		dst.state = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementJoiningModeDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setup) {
		obj["setup"] = *src.setup;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementJoiningModeDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setup")) {
		dst.setup = obj["setup"].as<decltype(dst.setup)::value_type>();
	} else {
		dst.setup = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementJoiningModeDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.setup) {
		obj["setup"] = *src.setup;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementJoiningModeDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("setup")) {
		dst.setup = obj["setup"].as<decltype(dst.setup)::value_type>();
	} else {
		dst.setup = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementReportCandidateDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.candidateSetup) {
		obj["candidateSetup"] = *src.candidateSetup;
	}
	if (src.setupUsableForAdd) {
		obj["setupUsableForAdd"] = *src.setupUsableForAdd;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementReportCandidateDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("candidateSetup")) {
		dst.candidateSetup = obj["candidateSetup"].as<decltype(dst.candidateSetup)::value_type>();
	} else {
		dst.candidateSetup = std::nullopt;
	}
	if (obj.containsKey("setupUsableForAdd")) {
		dst.setupUsableForAdd = obj["setupUsableForAdd"].as<decltype(dst.setupUsableForAdd)::value_type>();
	} else {
		dst.setupUsableForAdd = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementReportCandidateDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.candidateSetup) {
		obj["candidateSetup"] = *src.candidateSetup;
	}
	if (src.setupUsableForAdd) {
		obj["setupUsableForAdd"] = *src.setupUsableForAdd;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementReportCandidateDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("candidateSetup")) {
		dst.candidateSetup = obj["candidateSetup"].as<decltype(dst.candidateSetup)::value_type>();
	} else {
		dst.candidateSetup = std::nullopt;
	}
	if (obj.containsKey("setupUsableForAdd")) {
		dst.setupUsableForAdd = obj["setupUsableForAdd"].as<decltype(dst.setupUsableForAdd)::value_type>();
	} else {
		dst.setupUsableForAdd = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementDeviceDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceAddress) {
		obj["deviceAddress"] = *src.deviceAddress;
	}
	if (src.deviceType) {
		obj["deviceType"] = *src.deviceType;
	}
	if (src.networkManagementResponsibleAddress) {
		obj["networkManagementResponsibleAddress"] = *src.networkManagementResponsibleAddress;
	}
	if (src.nativeSetup) {
		obj["nativeSetup"] = *src.nativeSetup;
	}
	if (src.technologyAddress) {
		obj["technologyAddress"] = *src.technologyAddress;
	}
	if (src.communicationsTechnologyInformation) {
		obj["communicationsTechnologyInformation"] = *src.communicationsTechnologyInformation;
	}
	if (src.networkFeatureSet) {
		obj["networkFeatureSet"] = *src.networkFeatureSet;
	}
	if (src.lastStateChange) {
		obj["lastStateChange"] = *src.lastStateChange;
	}
	if (src.minimumTrustLevel) {
		obj["minimumTrustLevel"] = *src.minimumTrustLevel;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementDeviceDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceAddress")) {
		dst.deviceAddress = obj["deviceAddress"].as<decltype(dst.deviceAddress)::value_type>();
	} else {
		dst.deviceAddress = std::nullopt;
	}
	if (obj.containsKey("deviceType")) {
		dst.deviceType = obj["deviceType"].as<decltype(dst.deviceType)::value_type>();
	} else {
		dst.deviceType = std::nullopt;
	}
	if (obj.containsKey("networkManagementResponsibleAddress")) {
		dst.networkManagementResponsibleAddress = obj["networkManagementResponsibleAddress"].as<decltype(dst.networkManagementResponsibleAddress)::value_type>();
	} else {
		dst.networkManagementResponsibleAddress = std::nullopt;
	}
	if (obj.containsKey("nativeSetup")) {
		dst.nativeSetup = obj["nativeSetup"].as<decltype(dst.nativeSetup)::value_type>();
	} else {
		dst.nativeSetup = std::nullopt;
	}
	if (obj.containsKey("technologyAddress")) {
		dst.technologyAddress = obj["technologyAddress"].as<decltype(dst.technologyAddress)::value_type>();
	} else {
		dst.technologyAddress = std::nullopt;
	}
	if (obj.containsKey("communicationsTechnologyInformation")) {
		dst.communicationsTechnologyInformation = obj["communicationsTechnologyInformation"].as<decltype(dst.communicationsTechnologyInformation)::value_type>();
	} else {
		dst.communicationsTechnologyInformation = std::nullopt;
	}
	if (obj.containsKey("networkFeatureSet")) {
		dst.networkFeatureSet = obj["networkFeatureSet"].as<decltype(dst.networkFeatureSet)::value_type>();
	} else {
		dst.networkFeatureSet = std::nullopt;
	}
	if (obj.containsKey("lastStateChange")) {
		dst.lastStateChange = obj["lastStateChange"].as<decltype(dst.lastStateChange)::value_type>();
	} else {
		dst.lastStateChange = std::nullopt;
	}
	if (obj.containsKey("minimumTrustLevel")) {
		dst.minimumTrustLevel = obj["minimumTrustLevel"].as<decltype(dst.minimumTrustLevel)::value_type>();
	} else {
		dst.minimumTrustLevel = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementDeviceDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceAddress) {
		obj["deviceAddress"] = *src.deviceAddress;
	}
	if (src.deviceType) {
		obj["deviceType"] = *src.deviceType;
	}
	if (src.networkManagementResponsibleAddress) {
		obj["networkManagementResponsibleAddress"] = *src.networkManagementResponsibleAddress;
	}
	if (src.nativeSetup) {
		obj["nativeSetup"] = *src.nativeSetup;
	}
	if (src.technologyAddress) {
		obj["technologyAddress"] = *src.technologyAddress;
	}
	if (src.communicationsTechnologyInformation) {
		obj["communicationsTechnologyInformation"] = *src.communicationsTechnologyInformation;
	}
	if (src.networkFeatureSet) {
		obj["networkFeatureSet"] = *src.networkFeatureSet;
	}
	if (src.lastStateChange) {
		obj["lastStateChange"] = *src.lastStateChange;
	}
	if (src.minimumTrustLevel) {
		obj["minimumTrustLevel"] = *src.minimumTrustLevel;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementDeviceDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceAddress")) {
		dst.deviceAddress = obj["deviceAddress"].as<decltype(dst.deviceAddress)::value_type>();
	} else {
		dst.deviceAddress = std::nullopt;
	}
	if (obj.containsKey("deviceType")) {
		dst.deviceType = obj["deviceType"].as<decltype(dst.deviceType)::value_type>();
	} else {
		dst.deviceType = std::nullopt;
	}
	if (obj.containsKey("networkManagementResponsibleAddress")) {
		dst.networkManagementResponsibleAddress = obj["networkManagementResponsibleAddress"].as<decltype(dst.networkManagementResponsibleAddress)::value_type>();
	} else {
		dst.networkManagementResponsibleAddress = std::nullopt;
	}
	if (obj.containsKey("nativeSetup")) {
		dst.nativeSetup = obj["nativeSetup"].as<decltype(dst.nativeSetup)::value_type>();
	} else {
		dst.nativeSetup = std::nullopt;
	}
	if (obj.containsKey("technologyAddress")) {
		dst.technologyAddress = obj["technologyAddress"].as<decltype(dst.technologyAddress)::value_type>();
	} else {
		dst.technologyAddress = std::nullopt;
	}
	if (obj.containsKey("communicationsTechnologyInformation")) {
		dst.communicationsTechnologyInformation = obj["communicationsTechnologyInformation"].as<decltype(dst.communicationsTechnologyInformation)::value_type>();
	} else {
		dst.communicationsTechnologyInformation = std::nullopt;
	}
	if (obj.containsKey("networkFeatureSet")) {
		dst.networkFeatureSet = obj["networkFeatureSet"].as<decltype(dst.networkFeatureSet)::value_type>();
	} else {
		dst.networkFeatureSet = std::nullopt;
	}
	if (obj.containsKey("lastStateChange")) {
		dst.lastStateChange = obj["lastStateChange"].as<decltype(dst.lastStateChange)::value_type>();
	} else {
		dst.lastStateChange = std::nullopt;
	}
	if (obj.containsKey("minimumTrustLevel")) {
		dst.minimumTrustLevel = obj["minimumTrustLevel"].as<decltype(dst.minimumTrustLevel)::value_type>();
	} else {
		dst.minimumTrustLevel = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementDeviceDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.networkManagementDeviceDescriptionData) {
		obj["networkManagementDeviceDescriptionData"] = *src.networkManagementDeviceDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementDeviceDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("networkManagementDeviceDescriptionData")) {
		dst.networkManagementDeviceDescriptionData = obj["networkManagementDeviceDescriptionData"].as<decltype(dst.networkManagementDeviceDescriptionData)::value_type>();
	} else {
		dst.networkManagementDeviceDescriptionData = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementDeviceDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceAddress) {
		obj["deviceAddress"] = *src.deviceAddress;
	}
	if (src.deviceType) {
		obj["deviceType"] = *src.deviceType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementDeviceDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceAddress")) {
		dst.deviceAddress = obj["deviceAddress"].as<decltype(dst.deviceAddress)::value_type>();
	} else {
		dst.deviceAddress = std::nullopt;
	}
	if (obj.containsKey("deviceType")) {
		dst.deviceType = obj["deviceType"].as<decltype(dst.deviceType)::value_type>();
	} else {
		dst.deviceType = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementEntityDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.entityAddress) {
		obj["entityAddress"] = *src.entityAddress;
	}
	if (src.entityType) {
		obj["entityType"] = *src.entityType;
	}
	if (src.lastStateChange) {
		obj["lastStateChange"] = *src.lastStateChange;
	}
	if (src.minimumTrustLevel) {
		obj["minimumTrustLevel"] = *src.minimumTrustLevel;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementEntityDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("entityAddress")) {
		dst.entityAddress = obj["entityAddress"].as<decltype(dst.entityAddress)::value_type>();
	} else {
		dst.entityAddress = std::nullopt;
	}
	if (obj.containsKey("entityType")) {
		dst.entityType = obj["entityType"].as<decltype(dst.entityType)::value_type>();
	} else {
		dst.entityType = std::nullopt;
	}
	if (obj.containsKey("lastStateChange")) {
		dst.lastStateChange = obj["lastStateChange"].as<decltype(dst.lastStateChange)::value_type>();
	} else {
		dst.lastStateChange = std::nullopt;
	}
	if (obj.containsKey("minimumTrustLevel")) {
		dst.minimumTrustLevel = obj["minimumTrustLevel"].as<decltype(dst.minimumTrustLevel)::value_type>();
	} else {
		dst.minimumTrustLevel = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementEntityDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.entityAddress) {
		obj["entityAddress"] = *src.entityAddress;
	}
	if (src.entityType) {
		obj["entityType"] = *src.entityType;
	}
	if (src.lastStateChange) {
		obj["lastStateChange"] = *src.lastStateChange;
	}
	if (src.minimumTrustLevel) {
		obj["minimumTrustLevel"] = *src.minimumTrustLevel;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementEntityDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("entityAddress")) {
		dst.entityAddress = obj["entityAddress"].as<decltype(dst.entityAddress)::value_type>();
	} else {
		dst.entityAddress = std::nullopt;
	}
	if (obj.containsKey("entityType")) {
		dst.entityType = obj["entityType"].as<decltype(dst.entityType)::value_type>();
	} else {
		dst.entityType = std::nullopt;
	}
	if (obj.containsKey("lastStateChange")) {
		dst.lastStateChange = obj["lastStateChange"].as<decltype(dst.lastStateChange)::value_type>();
	} else {
		dst.lastStateChange = std::nullopt;
	}
	if (obj.containsKey("minimumTrustLevel")) {
		dst.minimumTrustLevel = obj["minimumTrustLevel"].as<decltype(dst.minimumTrustLevel)::value_type>();
	} else {
		dst.minimumTrustLevel = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementEntityDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.networkManagementEntityDescriptionData) {
		obj["networkManagementEntityDescriptionData"] = *src.networkManagementEntityDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementEntityDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("networkManagementEntityDescriptionData")) {
		dst.networkManagementEntityDescriptionData = obj["networkManagementEntityDescriptionData"].as<decltype(dst.networkManagementEntityDescriptionData)::value_type>();
	} else {
		dst.networkManagementEntityDescriptionData = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementEntityDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.entityAddress) {
		obj["entityAddress"] = *src.entityAddress;
	}
	if (src.entityType) {
		obj["entityType"] = *src.entityType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementEntityDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("entityAddress")) {
		dst.entityAddress = obj["entityAddress"].as<decltype(dst.entityAddress)::value_type>();
	} else {
		dst.entityAddress = std::nullopt;
	}
	if (obj.containsKey("entityType")) {
		dst.entityType = obj["entityType"].as<decltype(dst.entityType)::value_type>();
	} else {
		dst.entityType = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementFeatureDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.featureAddress) {
		obj["featureAddress"] = *src.featureAddress;
	}
	if (src.featureType) {
		obj["featureType"] = *src.featureType;
	}
	if (src.specificUsage) {
		obj["specificUsage"] = *src.specificUsage;
	}
	if (src.featureGroup) {
		obj["featureGroup"] = *src.featureGroup;
	}
	if (src.role) {
		obj["role"] = *src.role;
	}
	if (src.supportedFunction) {
		obj["supportedFunction"] = *src.supportedFunction;
	}
	if (src.lastStateChange) {
		obj["lastStateChange"] = *src.lastStateChange;
	}
	if (src.minimumTrustLevel) {
		obj["minimumTrustLevel"] = *src.minimumTrustLevel;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.maxResponseDelay) {
		obj["maxResponseDelay"] = *src.maxResponseDelay;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementFeatureDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("featureAddress")) {
		dst.featureAddress = obj["featureAddress"].as<decltype(dst.featureAddress)::value_type>();
	} else {
		dst.featureAddress = std::nullopt;
	}
	if (obj.containsKey("featureType")) {
		dst.featureType = obj["featureType"].as<decltype(dst.featureType)::value_type>();
	} else {
		dst.featureType = std::nullopt;
	}
	if (obj.containsKey("specificUsage")) {
		dst.specificUsage = obj["specificUsage"].as<decltype(dst.specificUsage)::value_type>();
	} else {
		dst.specificUsage = std::nullopt;
	}
	if (obj.containsKey("featureGroup")) {
		dst.featureGroup = obj["featureGroup"].as<decltype(dst.featureGroup)::value_type>();
	} else {
		dst.featureGroup = std::nullopt;
	}
	if (obj.containsKey("role")) {
		dst.role = obj["role"].as<decltype(dst.role)::value_type>();
	} else {
		dst.role = std::nullopt;
	}
	if (obj.containsKey("supportedFunction")) {
		dst.supportedFunction = obj["supportedFunction"].as<decltype(dst.supportedFunction)::value_type>();
	} else {
		dst.supportedFunction = std::nullopt;
	}
	if (obj.containsKey("lastStateChange")) {
		dst.lastStateChange = obj["lastStateChange"].as<decltype(dst.lastStateChange)::value_type>();
	} else {
		dst.lastStateChange = std::nullopt;
	}
	if (obj.containsKey("minimumTrustLevel")) {
		dst.minimumTrustLevel = obj["minimumTrustLevel"].as<decltype(dst.minimumTrustLevel)::value_type>();
	} else {
		dst.minimumTrustLevel = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("maxResponseDelay")) {
		dst.maxResponseDelay = obj["maxResponseDelay"].as<decltype(dst.maxResponseDelay)::value_type>();
	} else {
		dst.maxResponseDelay = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementFeatureDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.featureAddress) {
		obj["featureAddress"] = *src.featureAddress;
	}
	if (src.featureType) {
		obj["featureType"] = *src.featureType;
	}
	if (src.specificUsage) {
		obj["specificUsage"] = *src.specificUsage;
	}
	if (src.featureGroup) {
		obj["featureGroup"] = *src.featureGroup;
	}
	if (src.role) {
		obj["role"] = *src.role;
	}
	if (src.supportedFunction) {
		obj["supportedFunction"] = *src.supportedFunction;
	}
	if (src.lastStateChange) {
		obj["lastStateChange"] = *src.lastStateChange;
	}
	if (src.minimumTrustLevel) {
		obj["minimumTrustLevel"] = *src.minimumTrustLevel;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.maxResponseDelay) {
		obj["maxResponseDelay"] = *src.maxResponseDelay;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementFeatureDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("featureAddress")) {
		dst.featureAddress = obj["featureAddress"].as<decltype(dst.featureAddress)::value_type>();
	} else {
		dst.featureAddress = std::nullopt;
	}
	if (obj.containsKey("featureType")) {
		dst.featureType = obj["featureType"].as<decltype(dst.featureType)::value_type>();
	} else {
		dst.featureType = std::nullopt;
	}
	if (obj.containsKey("specificUsage")) {
		dst.specificUsage = obj["specificUsage"].as<decltype(dst.specificUsage)::value_type>();
	} else {
		dst.specificUsage = std::nullopt;
	}
	if (obj.containsKey("featureGroup")) {
		dst.featureGroup = obj["featureGroup"].as<decltype(dst.featureGroup)::value_type>();
	} else {
		dst.featureGroup = std::nullopt;
	}
	if (obj.containsKey("role")) {
		dst.role = obj["role"].as<decltype(dst.role)::value_type>();
	} else {
		dst.role = std::nullopt;
	}
	if (obj.containsKey("supportedFunction")) {
		dst.supportedFunction = obj["supportedFunction"].as<decltype(dst.supportedFunction)::value_type>();
	} else {
		dst.supportedFunction = std::nullopt;
	}
	if (obj.containsKey("lastStateChange")) {
		dst.lastStateChange = obj["lastStateChange"].as<decltype(dst.lastStateChange)::value_type>();
	} else {
		dst.lastStateChange = std::nullopt;
	}
	if (obj.containsKey("minimumTrustLevel")) {
		dst.minimumTrustLevel = obj["minimumTrustLevel"].as<decltype(dst.minimumTrustLevel)::value_type>();
	} else {
		dst.minimumTrustLevel = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("maxResponseDelay")) {
		dst.maxResponseDelay = obj["maxResponseDelay"].as<decltype(dst.maxResponseDelay)::value_type>();
	} else {
		dst.maxResponseDelay = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementFeatureDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.networkManagementFeatureDescriptionData) {
		obj["networkManagementFeatureDescriptionData"] = *src.networkManagementFeatureDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementFeatureDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("networkManagementFeatureDescriptionData")) {
		dst.networkManagementFeatureDescriptionData = obj["networkManagementFeatureDescriptionData"].as<decltype(dst.networkManagementFeatureDescriptionData)::value_type>();
	} else {
		dst.networkManagementFeatureDescriptionData = std::nullopt;
	}

}
bool convertToJson(const NetworkManagementFeatureDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.featureAddress) {
		obj["featureAddress"] = *src.featureAddress;
	}
	if (src.featureType) {
		obj["featureType"] = *src.featureType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NetworkManagementFeatureDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("featureAddress")) {
		dst.featureAddress = obj["featureAddress"].as<decltype(dst.featureAddress)::value_type>();
	} else {
		dst.featureAddress = std::nullopt;
	}
	if (obj.containsKey("featureType")) {
		dst.featureType = obj["featureType"].as<decltype(dst.featureType)::value_type>();
	} else {
		dst.featureType = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSpecificationVersionListType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.specificationVersion) {
		obj["specificationVersion"] = *src.specificationVersion;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSpecificationVersionListType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("specificationVersion")) {
		dst.specificationVersion = obj["specificationVersion"].as<decltype(dst.specificationVersion)::value_type>();
	} else {
		dst.specificationVersion = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryDeviceInformationType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryDeviceInformationType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryEntityInformationType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryEntityInformationType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryFeatureInformationType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryFeatureInformationType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.specificationVersionList) {
		obj["specificationVersionList"] = *src.specificationVersionList;
	}
	if (src.deviceInformation) {
		obj["deviceInformation"] = *src.deviceInformation;
	}
	if (src.entityInformation) {
		obj["entityInformation"] = *src.entityInformation;
	}
	if (src.featureInformation) {
		obj["featureInformation"] = *src.featureInformation;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("specificationVersionList")) {
		dst.specificationVersionList = obj["specificationVersionList"].as<decltype(dst.specificationVersionList)::value_type>();
	} else {
		dst.specificationVersionList = std::nullopt;
	}
	if (obj.containsKey("deviceInformation")) {
		dst.deviceInformation = obj["deviceInformation"].as<decltype(dst.deviceInformation)::value_type>();
	} else {
		dst.deviceInformation = std::nullopt;
	}
	if (obj.containsKey("entityInformation")) {
		dst.entityInformation = obj["entityInformation"].as<decltype(dst.entityInformation)::value_type>();
	} else {
		dst.entityInformation = std::nullopt;
	}
	if (obj.containsKey("featureInformation")) {
		dst.featureInformation = obj["featureInformation"].as<decltype(dst.featureInformation)::value_type>();
	} else {
		dst.featureInformation = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSpecificationVersionListElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.specificationVersion) {
		obj["specificationVersion"] = *src.specificationVersion;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSpecificationVersionListElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("specificationVersion")) {
		dst.specificationVersion = obj["specificationVersion"].as<decltype(dst.specificationVersion)::value_type>();
	} else {
		dst.specificationVersion = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryDeviceInformationElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryDeviceInformationElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryEntityInformationElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryEntityInformationElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryFeatureInformationElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryFeatureInformationElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.specificationVersionList) {
		obj["specificationVersionList"] = *src.specificationVersionList;
	}
	if (src.deviceInformation) {
		obj["deviceInformation"] = *src.deviceInformation;
	}
	if (src.entityInformation) {
		obj["entityInformation"] = *src.entityInformation;
	}
	if (src.featureInformation) {
		obj["featureInformation"] = *src.featureInformation;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("specificationVersionList")) {
		dst.specificationVersionList = obj["specificationVersionList"].as<decltype(dst.specificationVersionList)::value_type>();
	} else {
		dst.specificationVersionList = std::nullopt;
	}
	if (obj.containsKey("deviceInformation")) {
		dst.deviceInformation = obj["deviceInformation"].as<decltype(dst.deviceInformation)::value_type>();
	} else {
		dst.deviceInformation = std::nullopt;
	}
	if (obj.containsKey("entityInformation")) {
		dst.entityInformation = obj["entityInformation"].as<decltype(dst.entityInformation)::value_type>();
	} else {
		dst.entityInformation = std::nullopt;
	}
	if (obj.containsKey("featureInformation")) {
		dst.featureInformation = obj["featureInformation"].as<decltype(dst.featureInformation)::value_type>();
	} else {
		dst.featureInformation = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDetailedDiscoveryDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceInformation) {
		obj["deviceInformation"] = *src.deviceInformation;
	}
	if (src.entityInformation) {
		obj["entityInformation"] = *src.entityInformation;
	}
	if (src.featureInformation) {
		obj["featureInformation"] = *src.featureInformation;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDetailedDiscoveryDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceInformation")) {
		dst.deviceInformation = obj["deviceInformation"].as<decltype(dst.deviceInformation)::value_type>();
	} else {
		dst.deviceInformation = std::nullopt;
	}
	if (obj.containsKey("entityInformation")) {
		dst.entityInformation = obj["entityInformation"].as<decltype(dst.entityInformation)::value_type>();
	} else {
		dst.entityInformation = std::nullopt;
	}
	if (obj.containsKey("featureInformation")) {
		dst.featureInformation = obj["featureInformation"].as<decltype(dst.featureInformation)::value_type>();
	} else {
		dst.featureInformation = std::nullopt;
	}

}
bool convertToJson(const NodeManagementBindingDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingEntry) {
		obj["bindingEntry"] = *src.bindingEntry;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementBindingDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingEntry")) {
		dst.bindingEntry = obj["bindingEntry"].as<decltype(dst.bindingEntry)::value_type>();
	} else {
		dst.bindingEntry = std::nullopt;
	}

}
bool convertToJson(const NodeManagementBindingDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingEntry) {
		obj["bindingEntry"] = *src.bindingEntry;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementBindingDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingEntry")) {
		dst.bindingEntry = obj["bindingEntry"].as<decltype(dst.bindingEntry)::value_type>();
	} else {
		dst.bindingEntry = std::nullopt;
	}

}
bool convertToJson(const NodeManagementBindingDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingEntry) {
		obj["bindingEntry"] = *src.bindingEntry;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementBindingDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingEntry")) {
		dst.bindingEntry = obj["bindingEntry"].as<decltype(dst.bindingEntry)::value_type>();
	} else {
		dst.bindingEntry = std::nullopt;
	}

}
bool convertToJson(const NodeManagementBindingRequestCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingRequest) {
		obj["bindingRequest"] = *src.bindingRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementBindingRequestCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingRequest")) {
		dst.bindingRequest = obj["bindingRequest"].as<decltype(dst.bindingRequest)::value_type>();
	} else {
		dst.bindingRequest = std::nullopt;
	}

}
bool convertToJson(const NodeManagementBindingRequestCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingRequest) {
		obj["bindingRequest"] = *src.bindingRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementBindingRequestCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingRequest")) {
		dst.bindingRequest = obj["bindingRequest"].as<decltype(dst.bindingRequest)::value_type>();
	} else {
		dst.bindingRequest = std::nullopt;
	}

}
bool convertToJson(const NodeManagementBindingDeleteCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingDelete) {
		obj["bindingDelete"] = *src.bindingDelete;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementBindingDeleteCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingDelete")) {
		dst.bindingDelete = obj["bindingDelete"].as<decltype(dst.bindingDelete)::value_type>();
	} else {
		dst.bindingDelete = std::nullopt;
	}

}
bool convertToJson(const NodeManagementBindingDeleteCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.bindingDelete) {
		obj["bindingDelete"] = *src.bindingDelete;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementBindingDeleteCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("bindingDelete")) {
		dst.bindingDelete = obj["bindingDelete"].as<decltype(dst.bindingDelete)::value_type>();
	} else {
		dst.bindingDelete = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSubscriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionEntry) {
		obj["subscriptionEntry"] = *src.subscriptionEntry;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSubscriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionEntry")) {
		dst.subscriptionEntry = obj["subscriptionEntry"].as<decltype(dst.subscriptionEntry)::value_type>();
	} else {
		dst.subscriptionEntry = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSubscriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionEntry) {
		obj["subscriptionEntry"] = *src.subscriptionEntry;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSubscriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionEntry")) {
		dst.subscriptionEntry = obj["subscriptionEntry"].as<decltype(dst.subscriptionEntry)::value_type>();
	} else {
		dst.subscriptionEntry = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSubscriptionDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionEntry) {
		obj["subscriptionEntry"] = *src.subscriptionEntry;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSubscriptionDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionEntry")) {
		dst.subscriptionEntry = obj["subscriptionEntry"].as<decltype(dst.subscriptionEntry)::value_type>();
	} else {
		dst.subscriptionEntry = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSubscriptionRequestCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionRequest) {
		obj["subscriptionRequest"] = *src.subscriptionRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSubscriptionRequestCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionRequest")) {
		dst.subscriptionRequest = obj["subscriptionRequest"].as<decltype(dst.subscriptionRequest)::value_type>();
	} else {
		dst.subscriptionRequest = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSubscriptionRequestCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionRequest) {
		obj["subscriptionRequest"] = *src.subscriptionRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSubscriptionRequestCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionRequest")) {
		dst.subscriptionRequest = obj["subscriptionRequest"].as<decltype(dst.subscriptionRequest)::value_type>();
	} else {
		dst.subscriptionRequest = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSubscriptionDeleteCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionDelete) {
		obj["subscriptionDelete"] = *src.subscriptionDelete;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSubscriptionDeleteCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionDelete")) {
		dst.subscriptionDelete = obj["subscriptionDelete"].as<decltype(dst.subscriptionDelete)::value_type>();
	} else {
		dst.subscriptionDelete = std::nullopt;
	}

}
bool convertToJson(const NodeManagementSubscriptionDeleteCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionDelete) {
		obj["subscriptionDelete"] = *src.subscriptionDelete;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementSubscriptionDeleteCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionDelete")) {
		dst.subscriptionDelete = obj["subscriptionDelete"].as<decltype(dst.subscriptionDelete)::value_type>();
	} else {
		dst.subscriptionDelete = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDestinationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceDescription) {
		obj["deviceDescription"] = *src.deviceDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDestinationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceDescription")) {
		dst.deviceDescription = obj["deviceDescription"].as<decltype(dst.deviceDescription)::value_type>();
	} else {
		dst.deviceDescription = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDestinationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceDescription) {
		obj["deviceDescription"] = *src.deviceDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDestinationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceDescription")) {
		dst.deviceDescription = obj["deviceDescription"].as<decltype(dst.deviceDescription)::value_type>();
	} else {
		dst.deviceDescription = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDestinationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeManagementDestinationData) {
		obj["nodeManagementDestinationData"] = *src.nodeManagementDestinationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDestinationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeManagementDestinationData")) {
		dst.nodeManagementDestinationData = obj["nodeManagementDestinationData"].as<decltype(dst.nodeManagementDestinationData)::value_type>();
	} else {
		dst.nodeManagementDestinationData = std::nullopt;
	}

}
bool convertToJson(const NodeManagementDestinationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.deviceDescription) {
		obj["deviceDescription"] = *src.deviceDescription;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementDestinationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("deviceDescription")) {
		dst.deviceDescription = obj["deviceDescription"].as<decltype(dst.deviceDescription)::value_type>();
	} else {
		dst.deviceDescription = std::nullopt;
	}

}
bool convertToJson(const NodeManagementUseCaseDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.useCaseInformation) {
		obj["useCaseInformation"] = *src.useCaseInformation;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementUseCaseDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("useCaseInformation")) {
		dst.useCaseInformation = obj["useCaseInformation"].as<decltype(dst.useCaseInformation)::value_type>();
	} else {
		dst.useCaseInformation = std::nullopt;
	}

}
bool convertToJson(const NodeManagementUseCaseDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.useCaseInformation) {
		obj["useCaseInformation"] = *src.useCaseInformation;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementUseCaseDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("useCaseInformation")) {
		dst.useCaseInformation = obj["useCaseInformation"].as<decltype(dst.useCaseInformation)::value_type>();
	} else {
		dst.useCaseInformation = std::nullopt;
	}

}
bool convertToJson(const NodeManagementUseCaseDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.useCaseInformation) {
		obj["useCaseInformation"] = *src.useCaseInformation;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, NodeManagementUseCaseDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("useCaseInformation")) {
		dst.useCaseInformation = obj["useCaseInformation"].as<decltype(dst.useCaseInformation)::value_type>();
	} else {
		dst.useCaseInformation = std::nullopt;
	}

}
bool convertToJson(const SubscriptionManagementEntryDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionId) {
		obj["subscriptionId"] = *src.subscriptionId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SubscriptionManagementEntryDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionId")) {
		dst.subscriptionId = obj["subscriptionId"].as<decltype(dst.subscriptionId)::value_type>();
	} else {
		dst.subscriptionId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const SubscriptionManagementEntryDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionId) {
		obj["subscriptionId"] = *src.subscriptionId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SubscriptionManagementEntryDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionId")) {
		dst.subscriptionId = obj["subscriptionId"].as<decltype(dst.subscriptionId)::value_type>();
	} else {
		dst.subscriptionId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const SubscriptionManagementEntryListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionManagementEntryData) {
		obj["subscriptionManagementEntryData"] = *src.subscriptionManagementEntryData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SubscriptionManagementEntryListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionManagementEntryData")) {
		dst.subscriptionManagementEntryData = obj["subscriptionManagementEntryData"].as<decltype(dst.subscriptionManagementEntryData)::value_type>();
	} else {
		dst.subscriptionManagementEntryData = std::nullopt;
	}

}
bool convertToJson(const SubscriptionManagementEntryListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionId) {
		obj["subscriptionId"] = *src.subscriptionId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SubscriptionManagementEntryListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionId")) {
		dst.subscriptionId = obj["subscriptionId"].as<decltype(dst.subscriptionId)::value_type>();
	} else {
		dst.subscriptionId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}

}
bool convertToJson(const SubscriptionManagementRequestCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}
	if (src.serverFeatureType) {
		obj["serverFeatureType"] = *src.serverFeatureType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SubscriptionManagementRequestCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}
	if (obj.containsKey("serverFeatureType")) {
		dst.serverFeatureType = obj["serverFeatureType"].as<decltype(dst.serverFeatureType)::value_type>();
	} else {
		dst.serverFeatureType = std::nullopt;
	}

}
bool convertToJson(const SubscriptionManagementRequestCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}
	if (src.serverFeatureType) {
		obj["serverFeatureType"] = *src.serverFeatureType;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SubscriptionManagementRequestCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}
	if (obj.containsKey("serverFeatureType")) {
		dst.serverFeatureType = obj["serverFeatureType"].as<decltype(dst.serverFeatureType)::value_type>();
	} else {
		dst.serverFeatureType = std::nullopt;
	}

}
bool convertToJson(const SubscriptionManagementDeleteCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionId) {
		obj["subscriptionId"] = *src.subscriptionId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SubscriptionManagementDeleteCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionId")) {
		dst.subscriptionId = obj["subscriptionId"].as<decltype(dst.subscriptionId)::value_type>();
	} else {
		dst.subscriptionId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}

}
bool convertToJson(const SubscriptionManagementDeleteCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.subscriptionId) {
		obj["subscriptionId"] = *src.subscriptionId;
	}
	if (src.clientAddress) {
		obj["clientAddress"] = *src.clientAddress;
	}
	if (src.serverAddress) {
		obj["serverAddress"] = *src.serverAddress;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SubscriptionManagementDeleteCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("subscriptionId")) {
		dst.subscriptionId = obj["subscriptionId"].as<decltype(dst.subscriptionId)::value_type>();
	} else {
		dst.subscriptionId = std::nullopt;
	}
	if (obj.containsKey("clientAddress")) {
		dst.clientAddress = obj["clientAddress"].as<decltype(dst.clientAddress)::value_type>();
	} else {
		dst.clientAddress = std::nullopt;
	}
	if (obj.containsKey("serverAddress")) {
		dst.serverAddress = obj["serverAddress"].as<decltype(dst.serverAddress)::value_type>();
	} else {
		dst.serverAddress = std::nullopt;
	}

}
bool convertToJson(const UseCaseSupportType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.useCaseName) {
		obj["useCaseName"] = *src.useCaseName;
	}
	if (src.useCaseVersion) {
		obj["useCaseVersion"] = *src.useCaseVersion;
	}
	if (src.useCaseAvailable) {
		obj["useCaseAvailable"] = *src.useCaseAvailable;
	}
	if (src.scenarioSupport) {
		obj["scenarioSupport"] = *src.scenarioSupport;
	}
	if (src.useCaseDocumentSubRevision) {
		obj["useCaseDocumentSubRevision"] = *src.useCaseDocumentSubRevision;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, UseCaseSupportType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("useCaseName")) {
		dst.useCaseName = obj["useCaseName"].as<decltype(dst.useCaseName)::value_type>();
	} else {
		dst.useCaseName = std::nullopt;
	}
	if (obj.containsKey("useCaseVersion")) {
		dst.useCaseVersion = obj["useCaseVersion"].as<decltype(dst.useCaseVersion)::value_type>();
	} else {
		dst.useCaseVersion = std::nullopt;
	}
	if (obj.containsKey("useCaseAvailable")) {
		dst.useCaseAvailable = obj["useCaseAvailable"].as<decltype(dst.useCaseAvailable)::value_type>();
	} else {
		dst.useCaseAvailable = std::nullopt;
	}
	if (obj.containsKey("scenarioSupport")) {
		dst.scenarioSupport = obj["scenarioSupport"].as<decltype(dst.scenarioSupport)::value_type>();
	} else {
		dst.scenarioSupport = std::nullopt;
	}
	if (obj.containsKey("useCaseDocumentSubRevision")) {
		dst.useCaseDocumentSubRevision = obj["useCaseDocumentSubRevision"].as<decltype(dst.useCaseDocumentSubRevision)::value_type>();
	} else {
		dst.useCaseDocumentSubRevision = std::nullopt;
	}

}
bool convertToJson(const UseCaseSupportElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.useCaseName) {
		obj["useCaseName"] = *src.useCaseName;
	}
	if (src.useCaseVersion) {
		obj["useCaseVersion"] = *src.useCaseVersion;
	}
	if (src.useCaseAvailable) {
		obj["useCaseAvailable"] = *src.useCaseAvailable;
	}
	if (src.scenarioSupport) {
		obj["scenarioSupport"] = *src.scenarioSupport;
	}
	if (src.useCaseDocumentSubRevision) {
		obj["useCaseDocumentSubRevision"] = *src.useCaseDocumentSubRevision;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, UseCaseSupportElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("useCaseName")) {
		dst.useCaseName = obj["useCaseName"].as<decltype(dst.useCaseName)::value_type>();
	} else {
		dst.useCaseName = std::nullopt;
	}
	if (obj.containsKey("useCaseVersion")) {
		dst.useCaseVersion = obj["useCaseVersion"].as<decltype(dst.useCaseVersion)::value_type>();
	} else {
		dst.useCaseVersion = std::nullopt;
	}
	if (obj.containsKey("useCaseAvailable")) {
		dst.useCaseAvailable = obj["useCaseAvailable"].as<decltype(dst.useCaseAvailable)::value_type>();
	} else {
		dst.useCaseAvailable = std::nullopt;
	}
	if (obj.containsKey("scenarioSupport")) {
		dst.scenarioSupport = obj["scenarioSupport"].as<decltype(dst.scenarioSupport)::value_type>();
	} else {
		dst.scenarioSupport = std::nullopt;
	}
	if (obj.containsKey("useCaseDocumentSubRevision")) {
		dst.useCaseDocumentSubRevision = obj["useCaseDocumentSubRevision"].as<decltype(dst.useCaseDocumentSubRevision)::value_type>();
	} else {
		dst.useCaseDocumentSubRevision = std::nullopt;
	}

}
bool convertToJson(const UseCaseSupportSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.useCaseName) {
		obj["useCaseName"] = *src.useCaseName;
	}
	if (src.useCaseVersion) {
		obj["useCaseVersion"] = *src.useCaseVersion;
	}
	if (src.scenarioSupport) {
		obj["scenarioSupport"] = *src.scenarioSupport;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, UseCaseSupportSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("useCaseName")) {
		dst.useCaseName = obj["useCaseName"].as<decltype(dst.useCaseName)::value_type>();
	} else {
		dst.useCaseName = std::nullopt;
	}
	if (obj.containsKey("useCaseVersion")) {
		dst.useCaseVersion = obj["useCaseVersion"].as<decltype(dst.useCaseVersion)::value_type>();
	} else {
		dst.useCaseVersion = std::nullopt;
	}
	if (obj.containsKey("scenarioSupport")) {
		dst.scenarioSupport = obj["scenarioSupport"].as<decltype(dst.scenarioSupport)::value_type>();
	} else {
		dst.scenarioSupport = std::nullopt;
	}

}
bool convertToJson(const UseCaseInformationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.address) {
		obj["address"] = *src.address;
	}
	if (src.actor) {
		obj["actor"] = *src.actor;
	}
	if (src.useCaseSupport) {
		obj["useCaseSupport"] = *src.useCaseSupport;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, UseCaseInformationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("address")) {
		dst.address = obj["address"].as<decltype(dst.address)::value_type>();
	} else {
		dst.address = std::nullopt;
	}
	if (obj.containsKey("actor")) {
		dst.actor = obj["actor"].as<decltype(dst.actor)::value_type>();
	} else {
		dst.actor = std::nullopt;
	}
	if (obj.containsKey("useCaseSupport")) {
		dst.useCaseSupport = obj["useCaseSupport"].as<decltype(dst.useCaseSupport)::value_type>();
	} else {
		dst.useCaseSupport = std::nullopt;
	}

}
bool convertToJson(const UseCaseInformationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.address) {
		obj["address"] = *src.address;
	}
	if (src.actor) {
		obj["actor"] = *src.actor;
	}
	if (src.useCaseSupport) {
		obj["useCaseSupport"] = *src.useCaseSupport;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, UseCaseInformationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("address")) {
		dst.address = obj["address"].as<decltype(dst.address)::value_type>();
	} else {
		dst.address = std::nullopt;
	}
	if (obj.containsKey("actor")) {
		dst.actor = obj["actor"].as<decltype(dst.actor)::value_type>();
	} else {
		dst.actor = std::nullopt;
	}
	if (obj.containsKey("useCaseSupport")) {
		dst.useCaseSupport = obj["useCaseSupport"].as<decltype(dst.useCaseSupport)::value_type>();
	} else {
		dst.useCaseSupport = std::nullopt;
	}

}
bool convertToJson(const UseCaseInformationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.useCaseInformationData) {
		obj["useCaseInformationData"] = *src.useCaseInformationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, UseCaseInformationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("useCaseInformationData")) {
		dst.useCaseInformationData = obj["useCaseInformationData"].as<decltype(dst.useCaseInformationData)::value_type>();
	} else {
		dst.useCaseInformationData = std::nullopt;
	}

}
bool convertToJson(const UseCaseInformationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.address) {
		obj["address"] = *src.address;
	}
	if (src.actor) {
		obj["actor"] = *src.actor;
	}
	if (src.useCaseSupport) {
		obj["useCaseSupport"] = *src.useCaseSupport;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, UseCaseInformationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("address")) {
		dst.address = obj["address"].as<decltype(dst.address)::value_type>();
	} else {
		dst.address = std::nullopt;
	}
	if (obj.containsKey("actor")) {
		dst.actor = obj["actor"].as<decltype(dst.actor)::value_type>();
	} else {
		dst.actor = std::nullopt;
	}
	if (obj.containsKey("useCaseSupport")) {
		dst.useCaseSupport = obj["useCaseSupport"].as<decltype(dst.useCaseSupport)::value_type>();
	} else {
		dst.useCaseSupport = std::nullopt;
	}

}
bool convertToJson(const SpecificationVersionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, SpecificationVersionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const SpecificationVersionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.specificationVersionData) {
		obj["specificationVersionData"] = *src.specificationVersionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SpecificationVersionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("specificationVersionData")) {
		dst.specificationVersionData = obj["specificationVersionData"].as<decltype(dst.specificationVersionData)::value_type>();
	} else {
		dst.specificationVersionData = std::nullopt;
	}

}
bool convertToJson(const SpecificationVersionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, SpecificationVersionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const OperatingConstraintsInterruptDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.isPausable) {
		obj["isPausable"] = *src.isPausable;
	}
	if (src.isStoppable) {
		obj["isStoppable"] = *src.isStoppable;
	}
	if (src.notInterruptibleAtHighPower) {
		obj["notInterruptibleAtHighPower"] = *src.notInterruptibleAtHighPower;
	}
	if (src.maxCyclesPerDay) {
		obj["maxCyclesPerDay"] = *src.maxCyclesPerDay;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsInterruptDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("isPausable")) {
		dst.isPausable = obj["isPausable"].as<decltype(dst.isPausable)::value_type>();
	} else {
		dst.isPausable = std::nullopt;
	}
	if (obj.containsKey("isStoppable")) {
		dst.isStoppable = obj["isStoppable"].as<decltype(dst.isStoppable)::value_type>();
	} else {
		dst.isStoppable = std::nullopt;
	}
	if (obj.containsKey("notInterruptibleAtHighPower")) {
		dst.notInterruptibleAtHighPower = obj["notInterruptibleAtHighPower"].as<decltype(dst.notInterruptibleAtHighPower)::value_type>();
	} else {
		dst.notInterruptibleAtHighPower = std::nullopt;
	}
	if (obj.containsKey("maxCyclesPerDay")) {
		dst.maxCyclesPerDay = obj["maxCyclesPerDay"].as<decltype(dst.maxCyclesPerDay)::value_type>();
	} else {
		dst.maxCyclesPerDay = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsInterruptDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.isPausable) {
		obj["isPausable"] = *src.isPausable;
	}
	if (src.isStoppable) {
		obj["isStoppable"] = *src.isStoppable;
	}
	if (src.notInterruptibleAtHighPower) {
		obj["notInterruptibleAtHighPower"] = *src.notInterruptibleAtHighPower;
	}
	if (src.maxCyclesPerDay) {
		obj["maxCyclesPerDay"] = *src.maxCyclesPerDay;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsInterruptDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("isPausable")) {
		dst.isPausable = obj["isPausable"].as<decltype(dst.isPausable)::value_type>();
	} else {
		dst.isPausable = std::nullopt;
	}
	if (obj.containsKey("isStoppable")) {
		dst.isStoppable = obj["isStoppable"].as<decltype(dst.isStoppable)::value_type>();
	} else {
		dst.isStoppable = std::nullopt;
	}
	if (obj.containsKey("notInterruptibleAtHighPower")) {
		dst.notInterruptibleAtHighPower = obj["notInterruptibleAtHighPower"].as<decltype(dst.notInterruptibleAtHighPower)::value_type>();
	} else {
		dst.notInterruptibleAtHighPower = std::nullopt;
	}
	if (obj.containsKey("maxCyclesPerDay")) {
		dst.maxCyclesPerDay = obj["maxCyclesPerDay"].as<decltype(dst.maxCyclesPerDay)::value_type>();
	} else {
		dst.maxCyclesPerDay = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsInterruptListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operatingConstraintsInterruptData) {
		obj["operatingConstraintsInterruptData"] = *src.operatingConstraintsInterruptData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsInterruptListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operatingConstraintsInterruptData")) {
		dst.operatingConstraintsInterruptData = obj["operatingConstraintsInterruptData"].as<decltype(dst.operatingConstraintsInterruptData)::value_type>();
	} else {
		dst.operatingConstraintsInterruptData = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsInterruptListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsInterruptListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsDurationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.activeDurationMin) {
		obj["activeDurationMin"] = *src.activeDurationMin;
	}
	if (src.activeDurationMax) {
		obj["activeDurationMax"] = *src.activeDurationMax;
	}
	if (src.pauseDurationMin) {
		obj["pauseDurationMin"] = *src.pauseDurationMin;
	}
	if (src.pauseDurationMax) {
		obj["pauseDurationMax"] = *src.pauseDurationMax;
	}
	if (src.activeDurationSumMin) {
		obj["activeDurationSumMin"] = *src.activeDurationSumMin;
	}
	if (src.activeDurationSumMax) {
		obj["activeDurationSumMax"] = *src.activeDurationSumMax;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsDurationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("activeDurationMin")) {
		dst.activeDurationMin = obj["activeDurationMin"].as<decltype(dst.activeDurationMin)::value_type>();
	} else {
		dst.activeDurationMin = std::nullopt;
	}
	if (obj.containsKey("activeDurationMax")) {
		dst.activeDurationMax = obj["activeDurationMax"].as<decltype(dst.activeDurationMax)::value_type>();
	} else {
		dst.activeDurationMax = std::nullopt;
	}
	if (obj.containsKey("pauseDurationMin")) {
		dst.pauseDurationMin = obj["pauseDurationMin"].as<decltype(dst.pauseDurationMin)::value_type>();
	} else {
		dst.pauseDurationMin = std::nullopt;
	}
	if (obj.containsKey("pauseDurationMax")) {
		dst.pauseDurationMax = obj["pauseDurationMax"].as<decltype(dst.pauseDurationMax)::value_type>();
	} else {
		dst.pauseDurationMax = std::nullopt;
	}
	if (obj.containsKey("activeDurationSumMin")) {
		dst.activeDurationSumMin = obj["activeDurationSumMin"].as<decltype(dst.activeDurationSumMin)::value_type>();
	} else {
		dst.activeDurationSumMin = std::nullopt;
	}
	if (obj.containsKey("activeDurationSumMax")) {
		dst.activeDurationSumMax = obj["activeDurationSumMax"].as<decltype(dst.activeDurationSumMax)::value_type>();
	} else {
		dst.activeDurationSumMax = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsDurationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.activeDurationMin) {
		obj["activeDurationMin"] = *src.activeDurationMin;
	}
	if (src.activeDurationMax) {
		obj["activeDurationMax"] = *src.activeDurationMax;
	}
	if (src.pauseDurationMin) {
		obj["pauseDurationMin"] = *src.pauseDurationMin;
	}
	if (src.pauseDurationMax) {
		obj["pauseDurationMax"] = *src.pauseDurationMax;
	}
	if (src.activeDurationSumMin) {
		obj["activeDurationSumMin"] = *src.activeDurationSumMin;
	}
	if (src.activeDurationSumMax) {
		obj["activeDurationSumMax"] = *src.activeDurationSumMax;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsDurationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("activeDurationMin")) {
		dst.activeDurationMin = obj["activeDurationMin"].as<decltype(dst.activeDurationMin)::value_type>();
	} else {
		dst.activeDurationMin = std::nullopt;
	}
	if (obj.containsKey("activeDurationMax")) {
		dst.activeDurationMax = obj["activeDurationMax"].as<decltype(dst.activeDurationMax)::value_type>();
	} else {
		dst.activeDurationMax = std::nullopt;
	}
	if (obj.containsKey("pauseDurationMin")) {
		dst.pauseDurationMin = obj["pauseDurationMin"].as<decltype(dst.pauseDurationMin)::value_type>();
	} else {
		dst.pauseDurationMin = std::nullopt;
	}
	if (obj.containsKey("pauseDurationMax")) {
		dst.pauseDurationMax = obj["pauseDurationMax"].as<decltype(dst.pauseDurationMax)::value_type>();
	} else {
		dst.pauseDurationMax = std::nullopt;
	}
	if (obj.containsKey("activeDurationSumMin")) {
		dst.activeDurationSumMin = obj["activeDurationSumMin"].as<decltype(dst.activeDurationSumMin)::value_type>();
	} else {
		dst.activeDurationSumMin = std::nullopt;
	}
	if (obj.containsKey("activeDurationSumMax")) {
		dst.activeDurationSumMax = obj["activeDurationSumMax"].as<decltype(dst.activeDurationSumMax)::value_type>();
	} else {
		dst.activeDurationSumMax = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsDurationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operatingConstraintsDurationData) {
		obj["operatingConstraintsDurationData"] = *src.operatingConstraintsDurationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsDurationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operatingConstraintsDurationData")) {
		dst.operatingConstraintsDurationData = obj["operatingConstraintsDurationData"].as<decltype(dst.operatingConstraintsDurationData)::value_type>();
	} else {
		dst.operatingConstraintsDurationData = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsDurationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsDurationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.powerUnit) {
		obj["powerUnit"] = *src.powerUnit;
	}
	if (src.energyUnit) {
		obj["energyUnit"] = *src.energyUnit;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("powerUnit")) {
		dst.powerUnit = obj["powerUnit"].as<decltype(dst.powerUnit)::value_type>();
	} else {
		dst.powerUnit = std::nullopt;
	}
	if (obj.containsKey("energyUnit")) {
		dst.energyUnit = obj["energyUnit"].as<decltype(dst.energyUnit)::value_type>();
	} else {
		dst.energyUnit = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.powerUnit) {
		obj["powerUnit"] = *src.powerUnit;
	}
	if (src.energyUnit) {
		obj["energyUnit"] = *src.energyUnit;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("powerUnit")) {
		dst.powerUnit = obj["powerUnit"].as<decltype(dst.powerUnit)::value_type>();
	} else {
		dst.powerUnit = std::nullopt;
	}
	if (obj.containsKey("energyUnit")) {
		dst.energyUnit = obj["energyUnit"].as<decltype(dst.energyUnit)::value_type>();
	} else {
		dst.energyUnit = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operatingConstraintsPowerDescriptionData) {
		obj["operatingConstraintsPowerDescriptionData"] = *src.operatingConstraintsPowerDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operatingConstraintsPowerDescriptionData")) {
		dst.operatingConstraintsPowerDescriptionData = obj["operatingConstraintsPowerDescriptionData"].as<decltype(dst.operatingConstraintsPowerDescriptionData)::value_type>();
	} else {
		dst.operatingConstraintsPowerDescriptionData = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerRangeDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.powerMin) {
		obj["powerMin"] = *src.powerMin;
	}
	if (src.powerMax) {
		obj["powerMax"] = *src.powerMax;
	}
	if (src.energyMin) {
		obj["energyMin"] = *src.energyMin;
	}
	if (src.energyMax) {
		obj["energyMax"] = *src.energyMax;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerRangeDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("powerMin")) {
		dst.powerMin = obj["powerMin"].as<decltype(dst.powerMin)::value_type>();
	} else {
		dst.powerMin = std::nullopt;
	}
	if (obj.containsKey("powerMax")) {
		dst.powerMax = obj["powerMax"].as<decltype(dst.powerMax)::value_type>();
	} else {
		dst.powerMax = std::nullopt;
	}
	if (obj.containsKey("energyMin")) {
		dst.energyMin = obj["energyMin"].as<decltype(dst.energyMin)::value_type>();
	} else {
		dst.energyMin = std::nullopt;
	}
	if (obj.containsKey("energyMax")) {
		dst.energyMax = obj["energyMax"].as<decltype(dst.energyMax)::value_type>();
	} else {
		dst.energyMax = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerRangeDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.powerMin) {
		obj["powerMin"] = *src.powerMin;
	}
	if (src.powerMax) {
		obj["powerMax"] = *src.powerMax;
	}
	if (src.energyMin) {
		obj["energyMin"] = *src.energyMin;
	}
	if (src.energyMax) {
		obj["energyMax"] = *src.energyMax;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerRangeDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("powerMin")) {
		dst.powerMin = obj["powerMin"].as<decltype(dst.powerMin)::value_type>();
	} else {
		dst.powerMin = std::nullopt;
	}
	if (obj.containsKey("powerMax")) {
		dst.powerMax = obj["powerMax"].as<decltype(dst.powerMax)::value_type>();
	} else {
		dst.powerMax = std::nullopt;
	}
	if (obj.containsKey("energyMin")) {
		dst.energyMin = obj["energyMin"].as<decltype(dst.energyMin)::value_type>();
	} else {
		dst.energyMin = std::nullopt;
	}
	if (obj.containsKey("energyMax")) {
		dst.energyMax = obj["energyMax"].as<decltype(dst.energyMax)::value_type>();
	} else {
		dst.energyMax = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerRangeListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operatingConstraintsPowerRangeData) {
		obj["operatingConstraintsPowerRangeData"] = *src.operatingConstraintsPowerRangeData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerRangeListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operatingConstraintsPowerRangeData")) {
		dst.operatingConstraintsPowerRangeData = obj["operatingConstraintsPowerRangeData"].as<decltype(dst.operatingConstraintsPowerRangeData)::value_type>();
	} else {
		dst.operatingConstraintsPowerRangeData = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerRangeListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerRangeListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerLevelDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.power) {
		obj["power"] = *src.power;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerLevelDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("power")) {
		dst.power = obj["power"].as<decltype(dst.power)::value_type>();
	} else {
		dst.power = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerLevelDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.power) {
		obj["power"] = *src.power;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerLevelDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("power")) {
		dst.power = obj["power"].as<decltype(dst.power)::value_type>();
	} else {
		dst.power = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerLevelListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operatingConstraintsPowerLevelData) {
		obj["operatingConstraintsPowerLevelData"] = *src.operatingConstraintsPowerLevelData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerLevelListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operatingConstraintsPowerLevelData")) {
		dst.operatingConstraintsPowerLevelData = obj["operatingConstraintsPowerLevelData"].as<decltype(dst.operatingConstraintsPowerLevelData)::value_type>();
	} else {
		dst.operatingConstraintsPowerLevelData = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsPowerLevelListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsPowerLevelListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsResumeImplicationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.resumeEnergyEstimated) {
		obj["resumeEnergyEstimated"] = *src.resumeEnergyEstimated;
	}
	if (src.energyUnit) {
		obj["energyUnit"] = *src.energyUnit;
	}
	if (src.resumeCostEstimated) {
		obj["resumeCostEstimated"] = *src.resumeCostEstimated;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsResumeImplicationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("resumeEnergyEstimated")) {
		dst.resumeEnergyEstimated = obj["resumeEnergyEstimated"].as<decltype(dst.resumeEnergyEstimated)::value_type>();
	} else {
		dst.resumeEnergyEstimated = std::nullopt;
	}
	if (obj.containsKey("energyUnit")) {
		dst.energyUnit = obj["energyUnit"].as<decltype(dst.energyUnit)::value_type>();
	} else {
		dst.energyUnit = std::nullopt;
	}
	if (obj.containsKey("resumeCostEstimated")) {
		dst.resumeCostEstimated = obj["resumeCostEstimated"].as<decltype(dst.resumeCostEstimated)::value_type>();
	} else {
		dst.resumeCostEstimated = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsResumeImplicationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}
	if (src.resumeEnergyEstimated) {
		obj["resumeEnergyEstimated"] = *src.resumeEnergyEstimated;
	}
	if (src.energyUnit) {
		obj["energyUnit"] = *src.energyUnit;
	}
	if (src.resumeCostEstimated) {
		obj["resumeCostEstimated"] = *src.resumeCostEstimated;
	}
	if (src.currency) {
		obj["currency"] = *src.currency;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsResumeImplicationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}
	if (obj.containsKey("resumeEnergyEstimated")) {
		dst.resumeEnergyEstimated = obj["resumeEnergyEstimated"].as<decltype(dst.resumeEnergyEstimated)::value_type>();
	} else {
		dst.resumeEnergyEstimated = std::nullopt;
	}
	if (obj.containsKey("energyUnit")) {
		dst.energyUnit = obj["energyUnit"].as<decltype(dst.energyUnit)::value_type>();
	} else {
		dst.energyUnit = std::nullopt;
	}
	if (obj.containsKey("resumeCostEstimated")) {
		dst.resumeCostEstimated = obj["resumeCostEstimated"].as<decltype(dst.resumeCostEstimated)::value_type>();
	} else {
		dst.resumeCostEstimated = std::nullopt;
	}
	if (obj.containsKey("currency")) {
		dst.currency = obj["currency"].as<decltype(dst.currency)::value_type>();
	} else {
		dst.currency = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsResumeImplicationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.operatingConstraintsResumeImplicationData) {
		obj["operatingConstraintsResumeImplicationData"] = *src.operatingConstraintsResumeImplicationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsResumeImplicationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("operatingConstraintsResumeImplicationData")) {
		dst.operatingConstraintsResumeImplicationData = obj["operatingConstraintsResumeImplicationData"].as<decltype(dst.operatingConstraintsResumeImplicationData)::value_type>();
	} else {
		dst.operatingConstraintsResumeImplicationData = std::nullopt;
	}

}
bool convertToJson(const OperatingConstraintsResumeImplicationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, OperatingConstraintsResumeImplicationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const SensingDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.state) {
		obj["state"] = *src.state;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SensingDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("state")) {
		dst.state = obj["state"].as<decltype(dst.state)::value_type>();
	} else {
		dst.state = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const SensingDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.state) {
		obj["state"] = *src.state;
	}
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SensingDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("state")) {
		dst.state = obj["state"].as<decltype(dst.state)::value_type>();
	} else {
		dst.state = std::nullopt;
	}
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const SensingListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sensingData) {
		obj["sensingData"] = *src.sensingData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SensingListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sensingData")) {
		dst.sensingData = obj["sensingData"].as<decltype(dst.sensingData)::value_type>();
	} else {
		dst.sensingData = std::nullopt;
	}

}
bool convertToJson(const SensingListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SensingListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}

}
bool convertToJson(const SensingDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sensingType) {
		obj["sensingType"] = *src.sensingType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SensingDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sensingType")) {
		dst.sensingType = obj["sensingType"].as<decltype(dst.sensingType)::value_type>();
	} else {
		dst.sensingType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const SensingDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sensingType) {
		obj["sensingType"] = *src.sensingType;
	}
	if (src.unit) {
		obj["unit"] = *src.unit;
	}
	if (src.scopeType) {
		obj["scopeType"] = *src.scopeType;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SensingDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sensingType")) {
		dst.sensingType = obj["sensingType"].as<decltype(dst.sensingType)::value_type>();
	} else {
		dst.sensingType = std::nullopt;
	}
	if (obj.containsKey("unit")) {
		dst.unit = obj["unit"].as<decltype(dst.unit)::value_type>();
	} else {
		dst.unit = std::nullopt;
	}
	if (obj.containsKey("scopeType")) {
		dst.scopeType = obj["scopeType"].as<decltype(dst.scopeType)::value_type>();
	} else {
		dst.scopeType = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsAlternativesRelationType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alternativesId) {
		obj["alternativesId"] = *src.alternativesId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsAlternativesRelationType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alternativesId")) {
		dst.alternativesId = obj["alternativesId"].as<decltype(dst.alternativesId)::value_type>();
	} else {
		dst.alternativesId = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsAlternativesType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.relation) {
		obj["relation"] = *src.relation;
	}
	if (src.powerSequence) {
		obj["powerSequence"] = *src.powerSequence;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsAlternativesType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("relation")) {
		dst.relation = obj["relation"].as<decltype(dst.relation)::value_type>();
	} else {
		dst.relation = std::nullopt;
	}
	if (obj.containsKey("powerSequence")) {
		dst.powerSequence = obj["powerSequence"].as<decltype(dst.powerSequence)::value_type>();
	} else {
		dst.powerSequence = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPowerSequenceType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.state) {
		obj["state"] = *src.state;
	}
	if (src.schedule) {
		obj["schedule"] = *src.schedule;
	}
	if (src.scheduleConstraints) {
		obj["scheduleConstraints"] = *src.scheduleConstraints;
	}
	if (src.schedulePreference) {
		obj["schedulePreference"] = *src.schedulePreference;
	}
	if (src.operatingConstraintsInterrupt) {
		obj["operatingConstraintsInterrupt"] = *src.operatingConstraintsInterrupt;
	}
	if (src.operatingConstraintsDuration) {
		obj["operatingConstraintsDuration"] = *src.operatingConstraintsDuration;
	}
	if (src.operatingConstraintsResumeImplication) {
		obj["operatingConstraintsResumeImplication"] = *src.operatingConstraintsResumeImplication;
	}
	if (src.powerTimeSlot) {
		obj["powerTimeSlot"] = *src.powerTimeSlot;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPowerSequenceType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("state")) {
		dst.state = obj["state"].as<decltype(dst.state)::value_type>();
	} else {
		dst.state = std::nullopt;
	}
	if (obj.containsKey("schedule")) {
		dst.schedule = obj["schedule"].as<decltype(dst.schedule)::value_type>();
	} else {
		dst.schedule = std::nullopt;
	}
	if (obj.containsKey("scheduleConstraints")) {
		dst.scheduleConstraints = obj["scheduleConstraints"].as<decltype(dst.scheduleConstraints)::value_type>();
	} else {
		dst.scheduleConstraints = std::nullopt;
	}
	if (obj.containsKey("schedulePreference")) {
		dst.schedulePreference = obj["schedulePreference"].as<decltype(dst.schedulePreference)::value_type>();
	} else {
		dst.schedulePreference = std::nullopt;
	}
	if (obj.containsKey("operatingConstraintsInterrupt")) {
		dst.operatingConstraintsInterrupt = obj["operatingConstraintsInterrupt"].as<decltype(dst.operatingConstraintsInterrupt)::value_type>();
	} else {
		dst.operatingConstraintsInterrupt = std::nullopt;
	}
	if (obj.containsKey("operatingConstraintsDuration")) {
		dst.operatingConstraintsDuration = obj["operatingConstraintsDuration"].as<decltype(dst.operatingConstraintsDuration)::value_type>();
	} else {
		dst.operatingConstraintsDuration = std::nullopt;
	}
	if (obj.containsKey("operatingConstraintsResumeImplication")) {
		dst.operatingConstraintsResumeImplication = obj["operatingConstraintsResumeImplication"].as<decltype(dst.operatingConstraintsResumeImplication)::value_type>();
	} else {
		dst.operatingConstraintsResumeImplication = std::nullopt;
	}
	if (obj.containsKey("powerTimeSlot")) {
		dst.powerTimeSlot = obj["powerTimeSlot"].as<decltype(dst.powerTimeSlot)::value_type>();
	} else {
		dst.powerTimeSlot = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPowerTimeSlotType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.schedule) {
		obj["schedule"] = *src.schedule;
	}
	if (src.valueList) {
		obj["valueList"] = *src.valueList;
	}
	if (src.scheduleConstraints) {
		obj["scheduleConstraints"] = *src.scheduleConstraints;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPowerTimeSlotType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("schedule")) {
		dst.schedule = obj["schedule"].as<decltype(dst.schedule)::value_type>();
	} else {
		dst.schedule = std::nullopt;
	}
	if (obj.containsKey("valueList")) {
		dst.valueList = obj["valueList"].as<decltype(dst.valueList)::value_type>();
	} else {
		dst.valueList = std::nullopt;
	}
	if (obj.containsKey("scheduleConstraints")) {
		dst.scheduleConstraints = obj["scheduleConstraints"].as<decltype(dst.scheduleConstraints)::value_type>();
	} else {
		dst.scheduleConstraints = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPowerTimeSlotValueListType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPowerTimeSlotValueListType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeScheduleInformation) {
		obj["nodeScheduleInformation"] = *src.nodeScheduleInformation;
	}
	if (src.alternatives) {
		obj["alternatives"] = *src.alternatives;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeScheduleInformation")) {
		dst.nodeScheduleInformation = obj["nodeScheduleInformation"].as<decltype(dst.nodeScheduleInformation)::value_type>();
	} else {
		dst.nodeScheduleInformation = std::nullopt;
	}
	if (obj.containsKey("alternatives")) {
		dst.alternatives = obj["alternatives"].as<decltype(dst.alternatives)::value_type>();
	} else {
		dst.alternatives = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsAlternativesRelationElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alternativesId) {
		obj["alternativesId"] = *src.alternativesId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsAlternativesRelationElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alternativesId")) {
		dst.alternativesId = obj["alternativesId"].as<decltype(dst.alternativesId)::value_type>();
	} else {
		dst.alternativesId = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsAlternativesElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.relation) {
		obj["relation"] = *src.relation;
	}
	if (src.powerSequence) {
		obj["powerSequence"] = *src.powerSequence;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsAlternativesElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("relation")) {
		dst.relation = obj["relation"].as<decltype(dst.relation)::value_type>();
	} else {
		dst.relation = std::nullopt;
	}
	if (obj.containsKey("powerSequence")) {
		dst.powerSequence = obj["powerSequence"].as<decltype(dst.powerSequence)::value_type>();
	} else {
		dst.powerSequence = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPowerSequenceElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.state) {
		obj["state"] = *src.state;
	}
	if (src.schedule) {
		obj["schedule"] = *src.schedule;
	}
	if (src.scheduleConstraints) {
		obj["scheduleConstraints"] = *src.scheduleConstraints;
	}
	if (src.schedulePreference) {
		obj["schedulePreference"] = *src.schedulePreference;
	}
	if (src.operatingConstraintsInterrupt) {
		obj["operatingConstraintsInterrupt"] = *src.operatingConstraintsInterrupt;
	}
	if (src.operatingConstraintsDuration) {
		obj["operatingConstraintsDuration"] = *src.operatingConstraintsDuration;
	}
	if (src.operatingConstraintsResumeImplication) {
		obj["operatingConstraintsResumeImplication"] = *src.operatingConstraintsResumeImplication;
	}
	if (src.powerTimeSlot) {
		obj["powerTimeSlot"] = *src.powerTimeSlot;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPowerSequenceElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("state")) {
		dst.state = obj["state"].as<decltype(dst.state)::value_type>();
	} else {
		dst.state = std::nullopt;
	}
	if (obj.containsKey("schedule")) {
		dst.schedule = obj["schedule"].as<decltype(dst.schedule)::value_type>();
	} else {
		dst.schedule = std::nullopt;
	}
	if (obj.containsKey("scheduleConstraints")) {
		dst.scheduleConstraints = obj["scheduleConstraints"].as<decltype(dst.scheduleConstraints)::value_type>();
	} else {
		dst.scheduleConstraints = std::nullopt;
	}
	if (obj.containsKey("schedulePreference")) {
		dst.schedulePreference = obj["schedulePreference"].as<decltype(dst.schedulePreference)::value_type>();
	} else {
		dst.schedulePreference = std::nullopt;
	}
	if (obj.containsKey("operatingConstraintsInterrupt")) {
		dst.operatingConstraintsInterrupt = obj["operatingConstraintsInterrupt"].as<decltype(dst.operatingConstraintsInterrupt)::value_type>();
	} else {
		dst.operatingConstraintsInterrupt = std::nullopt;
	}
	if (obj.containsKey("operatingConstraintsDuration")) {
		dst.operatingConstraintsDuration = obj["operatingConstraintsDuration"].as<decltype(dst.operatingConstraintsDuration)::value_type>();
	} else {
		dst.operatingConstraintsDuration = std::nullopt;
	}
	if (obj.containsKey("operatingConstraintsResumeImplication")) {
		dst.operatingConstraintsResumeImplication = obj["operatingConstraintsResumeImplication"].as<decltype(dst.operatingConstraintsResumeImplication)::value_type>();
	} else {
		dst.operatingConstraintsResumeImplication = std::nullopt;
	}
	if (obj.containsKey("powerTimeSlot")) {
		dst.powerTimeSlot = obj["powerTimeSlot"].as<decltype(dst.powerTimeSlot)::value_type>();
	} else {
		dst.powerTimeSlot = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPowerTimeSlotElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.schedule) {
		obj["schedule"] = *src.schedule;
	}
	if (src.valueList) {
		obj["valueList"] = *src.valueList;
	}
	if (src.scheduleConstraints) {
		obj["scheduleConstraints"] = *src.scheduleConstraints;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPowerTimeSlotElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("schedule")) {
		dst.schedule = obj["schedule"].as<decltype(dst.schedule)::value_type>();
	} else {
		dst.schedule = std::nullopt;
	}
	if (obj.containsKey("valueList")) {
		dst.valueList = obj["valueList"].as<decltype(dst.valueList)::value_type>();
	} else {
		dst.valueList = std::nullopt;
	}
	if (obj.containsKey("scheduleConstraints")) {
		dst.scheduleConstraints = obj["scheduleConstraints"].as<decltype(dst.scheduleConstraints)::value_type>();
	} else {
		dst.scheduleConstraints = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPowerTimeSlotValueListElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.value) {
		obj["value"] = *src.value;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPowerTimeSlotValueListElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("value")) {
		dst.value = obj["value"].as<decltype(dst.value)::value_type>();
	} else {
		dst.value = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.nodeScheduleInformation) {
		obj["nodeScheduleInformation"] = *src.nodeScheduleInformation;
	}
	if (src.alternatives) {
		obj["alternatives"] = *src.alternatives;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("nodeScheduleInformation")) {
		dst.nodeScheduleInformation = obj["nodeScheduleInformation"].as<decltype(dst.nodeScheduleInformation)::value_type>();
	} else {
		dst.nodeScheduleInformation = std::nullopt;
	}
	if (obj.containsKey("alternatives")) {
		dst.alternatives = obj["alternatives"].as<decltype(dst.alternatives)::value_type>();
	} else {
		dst.alternatives = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.alternativesRelation) {
		obj["alternativesRelation"] = *src.alternativesRelation;
	}
	if (src.powerSequenceDescription) {
		obj["powerSequenceDescription"] = *src.powerSequenceDescription;
	}
	if (src.powerTimeSlotSchedule) {
		obj["powerTimeSlotSchedule"] = *src.powerTimeSlotSchedule;
	}
	if (src.powerTimeSlotValue) {
		obj["powerTimeSlotValue"] = *src.powerTimeSlotValue;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("alternativesRelation")) {
		dst.alternativesRelation = obj["alternativesRelation"].as<decltype(dst.alternativesRelation)::value_type>();
	} else {
		dst.alternativesRelation = std::nullopt;
	}
	if (obj.containsKey("powerSequenceDescription")) {
		dst.powerSequenceDescription = obj["powerSequenceDescription"].as<decltype(dst.powerSequenceDescription)::value_type>();
	} else {
		dst.powerSequenceDescription = std::nullopt;
	}
	if (obj.containsKey("powerTimeSlotSchedule")) {
		dst.powerTimeSlotSchedule = obj["powerTimeSlotSchedule"].as<decltype(dst.powerTimeSlotSchedule)::value_type>();
	} else {
		dst.powerTimeSlotSchedule = std::nullopt;
	}
	if (obj.containsKey("powerTimeSlotValue")) {
		dst.powerTimeSlotValue = obj["powerTimeSlotValue"].as<decltype(dst.powerTimeSlotValue)::value_type>();
	} else {
		dst.powerTimeSlotValue = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPriceDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.price) {
		obj["price"] = *src.price;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPriceDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("price")) {
		dst.price = obj["price"].as<decltype(dst.price)::value_type>();
	} else {
		dst.price = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPriceDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.price) {
		obj["price"] = *src.price;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPriceDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("price")) {
		dst.price = obj["price"].as<decltype(dst.price)::value_type>();
	} else {
		dst.price = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPriceDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.price) {
		obj["price"] = *src.price;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPriceDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("price")) {
		dst.price = obj["price"].as<decltype(dst.price)::value_type>();
	} else {
		dst.price = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsConfigurationRequestCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.scheduleConfigurationRequest) {
		obj["scheduleConfigurationRequest"] = *src.scheduleConfigurationRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsConfigurationRequestCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("scheduleConfigurationRequest")) {
		dst.scheduleConfigurationRequest = obj["scheduleConfigurationRequest"].as<decltype(dst.scheduleConfigurationRequest)::value_type>();
	} else {
		dst.scheduleConfigurationRequest = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsConfigurationRequestCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.scheduleConfigurationRequest) {
		obj["scheduleConfigurationRequest"] = *src.scheduleConfigurationRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsConfigurationRequestCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("scheduleConfigurationRequest")) {
		dst.scheduleConfigurationRequest = obj["scheduleConfigurationRequest"].as<decltype(dst.scheduleConfigurationRequest)::value_type>();
	} else {
		dst.scheduleConfigurationRequest = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPriceCalculationRequestCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.priceCalculationRequest) {
		obj["priceCalculationRequest"] = *src.priceCalculationRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPriceCalculationRequestCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("priceCalculationRequest")) {
		dst.priceCalculationRequest = obj["priceCalculationRequest"].as<decltype(dst.priceCalculationRequest)::value_type>();
	} else {
		dst.priceCalculationRequest = std::nullopt;
	}

}
bool convertToJson(const SmartEnergyManagementPsPriceCalculationRequestCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.priceCalculationRequest) {
		obj["priceCalculationRequest"] = *src.priceCalculationRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SmartEnergyManagementPsPriceCalculationRequestCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("priceCalculationRequest")) {
		dst.priceCalculationRequest = obj["priceCalculationRequest"].as<decltype(dst.priceCalculationRequest)::value_type>();
	} else {
		dst.priceCalculationRequest = std::nullopt;
	}

}
bool convertToJson(const StateInformationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.stateInformationId) {
		obj["stateInformationId"] = *src.stateInformationId;
	}
	if (src.stateInformation) {
		obj["stateInformation"] = *src.stateInformation;
	}
	if (src.isActive) {
		obj["isActive"] = *src.isActive;
	}
	if (src.category) {
		obj["category"] = *src.category;
	}
	if (src.timeOfLastChange) {
		obj["timeOfLastChange"] = *src.timeOfLastChange;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, StateInformationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("stateInformationId")) {
		dst.stateInformationId = obj["stateInformationId"].as<decltype(dst.stateInformationId)::value_type>();
	} else {
		dst.stateInformationId = std::nullopt;
	}
	if (obj.containsKey("stateInformation")) {
		dst.stateInformation = obj["stateInformation"].as<decltype(dst.stateInformation)::value_type>();
	} else {
		dst.stateInformation = std::nullopt;
	}
	if (obj.containsKey("isActive")) {
		dst.isActive = obj["isActive"].as<decltype(dst.isActive)::value_type>();
	} else {
		dst.isActive = std::nullopt;
	}
	if (obj.containsKey("category")) {
		dst.category = obj["category"].as<decltype(dst.category)::value_type>();
	} else {
		dst.category = std::nullopt;
	}
	if (obj.containsKey("timeOfLastChange")) {
		dst.timeOfLastChange = obj["timeOfLastChange"].as<decltype(dst.timeOfLastChange)::value_type>();
	} else {
		dst.timeOfLastChange = std::nullopt;
	}

}
bool convertToJson(const StateInformationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.stateInformationId) {
		obj["stateInformationId"] = *src.stateInformationId;
	}
	if (src.stateInformation) {
		obj["stateInformation"] = *src.stateInformation;
	}
	if (src.isActive) {
		obj["isActive"] = *src.isActive;
	}
	if (src.category) {
		obj["category"] = *src.category;
	}
	if (src.timeOfLastChange) {
		obj["timeOfLastChange"] = *src.timeOfLastChange;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, StateInformationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("stateInformationId")) {
		dst.stateInformationId = obj["stateInformationId"].as<decltype(dst.stateInformationId)::value_type>();
	} else {
		dst.stateInformationId = std::nullopt;
	}
	if (obj.containsKey("stateInformation")) {
		dst.stateInformation = obj["stateInformation"].as<decltype(dst.stateInformation)::value_type>();
	} else {
		dst.stateInformation = std::nullopt;
	}
	if (obj.containsKey("isActive")) {
		dst.isActive = obj["isActive"].as<decltype(dst.isActive)::value_type>();
	} else {
		dst.isActive = std::nullopt;
	}
	if (obj.containsKey("category")) {
		dst.category = obj["category"].as<decltype(dst.category)::value_type>();
	} else {
		dst.category = std::nullopt;
	}
	if (obj.containsKey("timeOfLastChange")) {
		dst.timeOfLastChange = obj["timeOfLastChange"].as<decltype(dst.timeOfLastChange)::value_type>();
	} else {
		dst.timeOfLastChange = std::nullopt;
	}

}
bool convertToJson(const StateInformationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.stateInformationData) {
		obj["stateInformationData"] = *src.stateInformationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, StateInformationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("stateInformationData")) {
		dst.stateInformationData = obj["stateInformationData"].as<decltype(dst.stateInformationData)::value_type>();
	} else {
		dst.stateInformationData = std::nullopt;
	}

}
bool convertToJson(const StateInformationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.stateInformationId) {
		obj["stateInformationId"] = *src.stateInformationId;
	}
	if (src.stateInformation) {
		obj["stateInformation"] = *src.stateInformation;
	}
	if (src.isActive) {
		obj["isActive"] = *src.isActive;
	}
	if (src.category) {
		obj["category"] = *src.category;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, StateInformationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("stateInformationId")) {
		dst.stateInformationId = obj["stateInformationId"].as<decltype(dst.stateInformationId)::value_type>();
	} else {
		dst.stateInformationId = std::nullopt;
	}
	if (obj.containsKey("stateInformation")) {
		dst.stateInformation = obj["stateInformation"].as<decltype(dst.stateInformation)::value_type>();
	} else {
		dst.stateInformation = std::nullopt;
	}
	if (obj.containsKey("isActive")) {
		dst.isActive = obj["isActive"].as<decltype(dst.isActive)::value_type>();
	} else {
		dst.isActive = std::nullopt;
	}
	if (obj.containsKey("category")) {
		dst.category = obj["category"].as<decltype(dst.category)::value_type>();
	} else {
		dst.category = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.eventType) {
		obj["eventType"] = *src.eventType;
	}
	if (src.originator) {
		obj["originator"] = *src.originator;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.thresholdPercentage) {
		obj["thresholdPercentage"] = *src.thresholdPercentage;
	}
	if (src.relevantPeriod) {
		obj["relevantPeriod"] = *src.relevantPeriod;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.gridCondition) {
		obj["gridCondition"] = *src.gridCondition;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("eventType")) {
		dst.eventType = obj["eventType"].as<decltype(dst.eventType)::value_type>();
	} else {
		dst.eventType = std::nullopt;
	}
	if (obj.containsKey("originator")) {
		dst.originator = obj["originator"].as<decltype(dst.originator)::value_type>();
	} else {
		dst.originator = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("thresholdPercentage")) {
		dst.thresholdPercentage = obj["thresholdPercentage"].as<decltype(dst.thresholdPercentage)::value_type>();
	} else {
		dst.thresholdPercentage = std::nullopt;
	}
	if (obj.containsKey("relevantPeriod")) {
		dst.relevantPeriod = obj["relevantPeriod"].as<decltype(dst.relevantPeriod)::value_type>();
	} else {
		dst.relevantPeriod = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("gridCondition")) {
		dst.gridCondition = obj["gridCondition"].as<decltype(dst.gridCondition)::value_type>();
	} else {
		dst.gridCondition = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.eventType) {
		obj["eventType"] = *src.eventType;
	}
	if (src.originator) {
		obj["originator"] = *src.originator;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}
	if (src.thresholdPercentage) {
		obj["thresholdPercentage"] = *src.thresholdPercentage;
	}
	if (src.relevantPeriod) {
		obj["relevantPeriod"] = *src.relevantPeriod;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}
	if (src.gridCondition) {
		obj["gridCondition"] = *src.gridCondition;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("eventType")) {
		dst.eventType = obj["eventType"].as<decltype(dst.eventType)::value_type>();
	} else {
		dst.eventType = std::nullopt;
	}
	if (obj.containsKey("originator")) {
		dst.originator = obj["originator"].as<decltype(dst.originator)::value_type>();
	} else {
		dst.originator = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}
	if (obj.containsKey("thresholdPercentage")) {
		dst.thresholdPercentage = obj["thresholdPercentage"].as<decltype(dst.thresholdPercentage)::value_type>();
	} else {
		dst.thresholdPercentage = std::nullopt;
	}
	if (obj.containsKey("relevantPeriod")) {
		dst.relevantPeriod = obj["relevantPeriod"].as<decltype(dst.relevantPeriod)::value_type>();
	} else {
		dst.relevantPeriod = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}
	if (obj.containsKey("gridCondition")) {
		dst.gridCondition = obj["gridCondition"].as<decltype(dst.gridCondition)::value_type>();
	} else {
		dst.gridCondition = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.supplyConditionData) {
		obj["supplyConditionData"] = *src.supplyConditionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("supplyConditionData")) {
		dst.supplyConditionData = obj["supplyConditionData"].as<decltype(dst.supplyConditionData)::value_type>();
	} else {
		dst.supplyConditionData = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}
	if (src.timestampInterval) {
		obj["timestampInterval"] = *src.timestampInterval;
	}
	if (src.eventType) {
		obj["eventType"] = *src.eventType;
	}
	if (src.originator) {
		obj["originator"] = *src.originator;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}
	if (obj.containsKey("timestampInterval")) {
		dst.timestampInterval = obj["timestampInterval"].as<decltype(dst.timestampInterval)::value_type>();
	} else {
		dst.timestampInterval = std::nullopt;
	}
	if (obj.containsKey("eventType")) {
		dst.eventType = obj["eventType"].as<decltype(dst.eventType)::value_type>();
	} else {
		dst.eventType = std::nullopt;
	}
	if (obj.containsKey("originator")) {
		dst.originator = obj["originator"].as<decltype(dst.originator)::value_type>();
	} else {
		dst.originator = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}
	if (src.commodityType) {
		obj["commodityType"] = *src.commodityType;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}
	if (obj.containsKey("commodityType")) {
		dst.commodityType = obj["commodityType"].as<decltype(dst.commodityType)::value_type>();
	} else {
		dst.commodityType = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}
	if (src.commodityType) {
		obj["commodityType"] = *src.commodityType;
	}
	if (src.positiveEnergyDirection) {
		obj["positiveEnergyDirection"] = *src.positiveEnergyDirection;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}
	if (obj.containsKey("commodityType")) {
		dst.commodityType = obj["commodityType"].as<decltype(dst.commodityType)::value_type>();
	} else {
		dst.commodityType = std::nullopt;
	}
	if (obj.containsKey("positiveEnergyDirection")) {
		dst.positiveEnergyDirection = obj["positiveEnergyDirection"].as<decltype(dst.positiveEnergyDirection)::value_type>();
	} else {
		dst.positiveEnergyDirection = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.supplyConditionDescriptionData) {
		obj["supplyConditionDescriptionData"] = *src.supplyConditionDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("supplyConditionDescriptionData")) {
		dst.supplyConditionDescriptionData = obj["supplyConditionDescriptionData"].as<decltype(dst.supplyConditionDescriptionData)::value_type>();
	} else {
		dst.supplyConditionDescriptionData = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionThresholdRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionThresholdRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionThresholdRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionThresholdRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionThresholdRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.supplyConditionThresholdRelationData) {
		obj["supplyConditionThresholdRelationData"] = *src.supplyConditionThresholdRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionThresholdRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("supplyConditionThresholdRelationData")) {
		dst.supplyConditionThresholdRelationData = obj["supplyConditionThresholdRelationData"].as<decltype(dst.supplyConditionThresholdRelationData)::value_type>();
	} else {
		dst.supplyConditionThresholdRelationData = std::nullopt;
	}

}
bool convertToJson(const SupplyConditionThresholdRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.conditionId) {
		obj["conditionId"] = *src.conditionId;
	}
	if (src.thresholdId) {
		obj["thresholdId"] = *src.thresholdId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SupplyConditionThresholdRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("conditionId")) {
		dst.conditionId = obj["conditionId"].as<decltype(dst.conditionId)::value_type>();
	} else {
		dst.conditionId = std::nullopt;
	}
	if (obj.containsKey("thresholdId")) {
		dst.thresholdId = obj["thresholdId"].as<decltype(dst.thresholdId)::value_type>();
	} else {
		dst.thresholdId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementDirectControlRelatedType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementDirectControlRelatedType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const TaskManagementDirectControlRelatedElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementDirectControlRelatedElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const TaskManagementHvacRelatedType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.overrunId) {
		obj["overrunId"] = *src.overrunId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementHvacRelatedType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("overrunId")) {
		dst.overrunId = obj["overrunId"].as<decltype(dst.overrunId)::value_type>();
	} else {
		dst.overrunId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementHvacRelatedElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.overrunId) {
		obj["overrunId"] = *src.overrunId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementHvacRelatedElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("overrunId")) {
		dst.overrunId = obj["overrunId"].as<decltype(dst.overrunId)::value_type>();
	} else {
		dst.overrunId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementLoadControlReleatedType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.eventId) {
		obj["eventId"] = *src.eventId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementLoadControlReleatedType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("eventId")) {
		dst.eventId = obj["eventId"].as<decltype(dst.eventId)::value_type>();
	} else {
		dst.eventId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementLoadControlReleatedElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.eventId) {
		obj["eventId"] = *src.eventId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementLoadControlReleatedElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("eventId")) {
		dst.eventId = obj["eventId"].as<decltype(dst.eventId)::value_type>();
	} else {
		dst.eventId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementPowerSequencesRelatedType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementPowerSequencesRelatedType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementPowerSequencesRelatedElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementPowerSequencesRelatedElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementSmartEnergyManagementPsRelatedType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementSmartEnergyManagementPsRelatedType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementSmartEnergyManagementPsRelatedElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.sequenceId) {
		obj["sequenceId"] = *src.sequenceId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementSmartEnergyManagementPsRelatedElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("sequenceId")) {
		dst.sequenceId = obj["sequenceId"].as<decltype(dst.sequenceId)::value_type>();
	} else {
		dst.sequenceId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.jobState) {
		obj["jobState"] = *src.jobState;
	}
	if (src.elapsedTime) {
		obj["elapsedTime"] = *src.elapsedTime;
	}
	if (src.remainingTime) {
		obj["remainingTime"] = *src.remainingTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("jobState")) {
		dst.jobState = obj["jobState"].as<decltype(dst.jobState)::value_type>();
	} else {
		dst.jobState = std::nullopt;
	}
	if (obj.containsKey("elapsedTime")) {
		dst.elapsedTime = obj["elapsedTime"].as<decltype(dst.elapsedTime)::value_type>();
	} else {
		dst.elapsedTime = std::nullopt;
	}
	if (obj.containsKey("remainingTime")) {
		dst.remainingTime = obj["remainingTime"].as<decltype(dst.remainingTime)::value_type>();
	} else {
		dst.remainingTime = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}
	if (src.jobState) {
		obj["jobState"] = *src.jobState;
	}
	if (src.elapsedTime) {
		obj["elapsedTime"] = *src.elapsedTime;
	}
	if (src.remainingTime) {
		obj["remainingTime"] = *src.remainingTime;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}
	if (obj.containsKey("jobState")) {
		dst.jobState = obj["jobState"].as<decltype(dst.jobState)::value_type>();
	} else {
		dst.jobState = std::nullopt;
	}
	if (obj.containsKey("elapsedTime")) {
		dst.elapsedTime = obj["elapsedTime"].as<decltype(dst.elapsedTime)::value_type>();
	} else {
		dst.elapsedTime = std::nullopt;
	}
	if (obj.containsKey("remainingTime")) {
		dst.remainingTime = obj["remainingTime"].as<decltype(dst.remainingTime)::value_type>();
	} else {
		dst.remainingTime = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.taskManagementJobData) {
		obj["taskManagementJobData"] = *src.taskManagementJobData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("taskManagementJobData")) {
		dst.taskManagementJobData = obj["taskManagementJobData"].as<decltype(dst.taskManagementJobData)::value_type>();
	} else {
		dst.taskManagementJobData = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}
	if (src.jobState) {
		obj["jobState"] = *src.jobState;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}
	if (obj.containsKey("jobState")) {
		dst.jobState = obj["jobState"].as<decltype(dst.jobState)::value_type>();
	} else {
		dst.jobState = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobRelationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}
	if (src.directControlRelated) {
		obj["directControlRelated"] = *src.directControlRelated;
	}
	if (src.hvacRelated) {
		obj["hvacRelated"] = *src.hvacRelated;
	}
	if (src.loadControlReleated) {
		obj["loadControlReleated"] = *src.loadControlReleated;
	}
	if (src.powerSequencesRelated) {
		obj["powerSequencesRelated"] = *src.powerSequencesRelated;
	}
	if (src.smartEnergyManagementPsRelated) {
		obj["smartEnergyManagementPsRelated"] = *src.smartEnergyManagementPsRelated;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobRelationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}
	if (obj.containsKey("directControlRelated")) {
		dst.directControlRelated = obj["directControlRelated"].as<decltype(dst.directControlRelated)::value_type>();
	} else {
		dst.directControlRelated = std::nullopt;
	}
	if (obj.containsKey("hvacRelated")) {
		dst.hvacRelated = obj["hvacRelated"].as<decltype(dst.hvacRelated)::value_type>();
	} else {
		dst.hvacRelated = std::nullopt;
	}
	if (obj.containsKey("loadControlReleated")) {
		dst.loadControlReleated = obj["loadControlReleated"].as<decltype(dst.loadControlReleated)::value_type>();
	} else {
		dst.loadControlReleated = std::nullopt;
	}
	if (obj.containsKey("powerSequencesRelated")) {
		dst.powerSequencesRelated = obj["powerSequencesRelated"].as<decltype(dst.powerSequencesRelated)::value_type>();
	} else {
		dst.powerSequencesRelated = std::nullopt;
	}
	if (obj.containsKey("smartEnergyManagementPsRelated")) {
		dst.smartEnergyManagementPsRelated = obj["smartEnergyManagementPsRelated"].as<decltype(dst.smartEnergyManagementPsRelated)::value_type>();
	} else {
		dst.smartEnergyManagementPsRelated = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobRelationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}
	if (src.directControlRelated) {
		obj["directControlRelated"] = *src.directControlRelated;
	}
	if (src.hvacRelated) {
		obj["hvacRelated"] = *src.hvacRelated;
	}
	if (src.loadControlReleated) {
		obj["loadControlReleated"] = *src.loadControlReleated;
	}
	if (src.powerSequencesRelated) {
		obj["powerSequencesRelated"] = *src.powerSequencesRelated;
	}
	if (src.smartEnergyManagementPsRelated) {
		obj["smartEnergyManagementPsRelated"] = *src.smartEnergyManagementPsRelated;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobRelationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}
	if (obj.containsKey("directControlRelated")) {
		dst.directControlRelated = obj["directControlRelated"].as<decltype(dst.directControlRelated)::value_type>();
	} else {
		dst.directControlRelated = std::nullopt;
	}
	if (obj.containsKey("hvacRelated")) {
		dst.hvacRelated = obj["hvacRelated"].as<decltype(dst.hvacRelated)::value_type>();
	} else {
		dst.hvacRelated = std::nullopt;
	}
	if (obj.containsKey("loadControlReleated")) {
		dst.loadControlReleated = obj["loadControlReleated"].as<decltype(dst.loadControlReleated)::value_type>();
	} else {
		dst.loadControlReleated = std::nullopt;
	}
	if (obj.containsKey("powerSequencesRelated")) {
		dst.powerSequencesRelated = obj["powerSequencesRelated"].as<decltype(dst.powerSequencesRelated)::value_type>();
	} else {
		dst.powerSequencesRelated = std::nullopt;
	}
	if (obj.containsKey("smartEnergyManagementPsRelated")) {
		dst.smartEnergyManagementPsRelated = obj["smartEnergyManagementPsRelated"].as<decltype(dst.smartEnergyManagementPsRelated)::value_type>();
	} else {
		dst.smartEnergyManagementPsRelated = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobRelationListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.taskManagementJobRelationData) {
		obj["taskManagementJobRelationData"] = *src.taskManagementJobRelationData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobRelationListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("taskManagementJobRelationData")) {
		dst.taskManagementJobRelationData = obj["taskManagementJobRelationData"].as<decltype(dst.taskManagementJobRelationData)::value_type>();
	} else {
		dst.taskManagementJobRelationData = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobRelationListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobRelationListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobDescriptionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}
	if (src.jobSource) {
		obj["jobSource"] = *src.jobSource;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobDescriptionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}
	if (obj.containsKey("jobSource")) {
		dst.jobSource = obj["jobSource"].as<decltype(dst.jobSource)::value_type>();
	} else {
		dst.jobSource = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobDescriptionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}
	if (src.jobSource) {
		obj["jobSource"] = *src.jobSource;
	}
	if (src.label) {
		obj["label"] = *src.label;
	}
	if (src.description) {
		obj["description"] = *src.description;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobDescriptionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}
	if (obj.containsKey("jobSource")) {
		dst.jobSource = obj["jobSource"].as<decltype(dst.jobSource)::value_type>();
	} else {
		dst.jobSource = std::nullopt;
	}
	if (obj.containsKey("label")) {
		dst.label = obj["label"].as<decltype(dst.label)::value_type>();
	} else {
		dst.label = std::nullopt;
	}
	if (obj.containsKey("description")) {
		dst.description = obj["description"].as<decltype(dst.description)::value_type>();
	} else {
		dst.description = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobDescriptionListDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.taskManagementJobDescriptionData) {
		obj["taskManagementJobDescriptionData"] = *src.taskManagementJobDescriptionData;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobDescriptionListDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("taskManagementJobDescriptionData")) {
		dst.taskManagementJobDescriptionData = obj["taskManagementJobDescriptionData"].as<decltype(dst.taskManagementJobDescriptionData)::value_type>();
	} else {
		dst.taskManagementJobDescriptionData = std::nullopt;
	}

}
bool convertToJson(const TaskManagementJobDescriptionListDataSelectorsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.jobId) {
		obj["jobId"] = *src.jobId;
	}
	if (src.jobSource) {
		obj["jobSource"] = *src.jobSource;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementJobDescriptionListDataSelectorsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("jobId")) {
		dst.jobId = obj["jobId"].as<decltype(dst.jobId)::value_type>();
	} else {
		dst.jobId = std::nullopt;
	}
	if (obj.containsKey("jobSource")) {
		dst.jobSource = obj["jobSource"].as<decltype(dst.jobSource)::value_type>();
	} else {
		dst.jobSource = std::nullopt;
	}

}
bool convertToJson(const TaskManagementOverviewDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.remoteControllable) {
		obj["remoteControllable"] = *src.remoteControllable;
	}
	if (src.jobsActive) {
		obj["jobsActive"] = *src.jobsActive;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementOverviewDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("remoteControllable")) {
		dst.remoteControllable = obj["remoteControllable"].as<decltype(dst.remoteControllable)::value_type>();
	} else {
		dst.remoteControllable = std::nullopt;
	}
	if (obj.containsKey("jobsActive")) {
		dst.jobsActive = obj["jobsActive"].as<decltype(dst.jobsActive)::value_type>();
	} else {
		dst.jobsActive = std::nullopt;
	}

}
bool convertToJson(const TaskManagementOverviewDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.remoteControllable) {
		obj["remoteControllable"] = *src.remoteControllable;
	}
	if (src.jobsActive) {
		obj["jobsActive"] = *src.jobsActive;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TaskManagementOverviewDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("remoteControllable")) {
		dst.remoteControllable = obj["remoteControllable"].as<decltype(dst.remoteControllable)::value_type>();
	} else {
		dst.remoteControllable = std::nullopt;
	}
	if (obj.containsKey("jobsActive")) {
		dst.jobsActive = obj["jobsActive"].as<decltype(dst.jobsActive)::value_type>();
	} else {
		dst.jobsActive = std::nullopt;
	}

}
bool convertToJson(const TimeInformationDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.utc) {
		obj["utc"] = *src.utc;
	}
	if (src.utcOffset) {
		obj["utcOffset"] = *src.utcOffset;
	}
	if (src.dayOfWeek) {
		obj["dayOfWeek"] = *src.dayOfWeek;
	}
	if (src.calendarWeek) {
		obj["calendarWeek"] = *src.calendarWeek;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeInformationDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("utc")) {
		dst.utc = obj["utc"].as<decltype(dst.utc)::value_type>();
	} else {
		dst.utc = std::nullopt;
	}
	if (obj.containsKey("utcOffset")) {
		dst.utcOffset = obj["utcOffset"].as<decltype(dst.utcOffset)::value_type>();
	} else {
		dst.utcOffset = std::nullopt;
	}
	if (obj.containsKey("dayOfWeek")) {
		dst.dayOfWeek = obj["dayOfWeek"].as<decltype(dst.dayOfWeek)::value_type>();
	} else {
		dst.dayOfWeek = std::nullopt;
	}
	if (obj.containsKey("calendarWeek")) {
		dst.calendarWeek = obj["calendarWeek"].as<decltype(dst.calendarWeek)::value_type>();
	} else {
		dst.calendarWeek = std::nullopt;
	}

}
bool convertToJson(const TimeInformationDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.utc) {
		obj["utc"] = *src.utc;
	}
	if (src.utcOffset) {
		obj["utcOffset"] = *src.utcOffset;
	}
	if (src.dayOfWeek) {
		obj["dayOfWeek"] = *src.dayOfWeek;
	}
	if (src.calendarWeek) {
		obj["calendarWeek"] = *src.calendarWeek;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeInformationDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("utc")) {
		dst.utc = obj["utc"].as<decltype(dst.utc)::value_type>();
	} else {
		dst.utc = std::nullopt;
	}
	if (obj.containsKey("utcOffset")) {
		dst.utcOffset = obj["utcOffset"].as<decltype(dst.utcOffset)::value_type>();
	} else {
		dst.utcOffset = std::nullopt;
	}
	if (obj.containsKey("dayOfWeek")) {
		dst.dayOfWeek = obj["dayOfWeek"].as<decltype(dst.dayOfWeek)::value_type>();
	} else {
		dst.dayOfWeek = std::nullopt;
	}
	if (obj.containsKey("calendarWeek")) {
		dst.calendarWeek = obj["calendarWeek"].as<decltype(dst.calendarWeek)::value_type>();
	} else {
		dst.calendarWeek = std::nullopt;
	}

}
bool convertToJson(const TimeDistributorDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.isTimeDistributor) {
		obj["isTimeDistributor"] = *src.isTimeDistributor;
	}
	if (src.distributorPriority) {
		obj["distributorPriority"] = *src.distributorPriority;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeDistributorDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("isTimeDistributor")) {
		dst.isTimeDistributor = obj["isTimeDistributor"].as<decltype(dst.isTimeDistributor)::value_type>();
	} else {
		dst.isTimeDistributor = std::nullopt;
	}
	if (obj.containsKey("distributorPriority")) {
		dst.distributorPriority = obj["distributorPriority"].as<decltype(dst.distributorPriority)::value_type>();
	} else {
		dst.distributorPriority = std::nullopt;
	}

}
bool convertToJson(const TimeDistributorDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.isTimeDistributor) {
		obj["isTimeDistributor"] = *src.isTimeDistributor;
	}
	if (src.distributorPriority) {
		obj["distributorPriority"] = *src.distributorPriority;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeDistributorDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("isTimeDistributor")) {
		dst.isTimeDistributor = obj["isTimeDistributor"].as<decltype(dst.isTimeDistributor)::value_type>();
	} else {
		dst.isTimeDistributor = std::nullopt;
	}
	if (obj.containsKey("distributorPriority")) {
		dst.distributorPriority = obj["distributorPriority"].as<decltype(dst.distributorPriority)::value_type>();
	} else {
		dst.distributorPriority = std::nullopt;
	}

}
bool convertToJson(const TimePrecisionDataType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.isSynchronised) {
		obj["isSynchronised"] = *src.isSynchronised;
	}
	if (src.lastSyncAt) {
		obj["lastSyncAt"] = *src.lastSyncAt;
	}
	if (src.clockDrift) {
		obj["clockDrift"] = *src.clockDrift;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimePrecisionDataType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("isSynchronised")) {
		dst.isSynchronised = obj["isSynchronised"].as<decltype(dst.isSynchronised)::value_type>();
	} else {
		dst.isSynchronised = std::nullopt;
	}
	if (obj.containsKey("lastSyncAt")) {
		dst.lastSyncAt = obj["lastSyncAt"].as<decltype(dst.lastSyncAt)::value_type>();
	} else {
		dst.lastSyncAt = std::nullopt;
	}
	if (obj.containsKey("clockDrift")) {
		dst.clockDrift = obj["clockDrift"].as<decltype(dst.clockDrift)::value_type>();
	} else {
		dst.clockDrift = std::nullopt;
	}

}
bool convertToJson(const TimePrecisionDataElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.isSynchronised) {
		obj["isSynchronised"] = *src.isSynchronised;
	}
	if (src.lastSyncAt) {
		obj["lastSyncAt"] = *src.lastSyncAt;
	}
	if (src.clockDrift) {
		obj["clockDrift"] = *src.clockDrift;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimePrecisionDataElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("isSynchronised")) {
		dst.isSynchronised = obj["isSynchronised"].as<decltype(dst.isSynchronised)::value_type>();
	} else {
		dst.isSynchronised = std::nullopt;
	}
	if (obj.containsKey("lastSyncAt")) {
		dst.lastSyncAt = obj["lastSyncAt"].as<decltype(dst.lastSyncAt)::value_type>();
	} else {
		dst.lastSyncAt = std::nullopt;
	}
	if (obj.containsKey("clockDrift")) {
		dst.clockDrift = obj["clockDrift"].as<decltype(dst.clockDrift)::value_type>();
	} else {
		dst.clockDrift = std::nullopt;
	}

}
bool convertToJson(const TimeDistributorEnquiryCallType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeDistributorEnquiryCallType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const TimeDistributorEnquiryCallElementsType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();

	return true;
}
void convertFromJson(const JsonVariantConst& src, TimeDistributorEnquiryCallElementsType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();

}
bool convertToJson(const HeaderType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.specificationVersion) {
		obj["specificationVersion"] = *src.specificationVersion;
	}
	if (src.addressSource) {
		obj["addressSource"] = *src.addressSource;
	}
	if (src.addressDestination) {
		obj["addressDestination"] = *src.addressDestination;
	}
	if (src.addressOriginator) {
		obj["addressOriginator"] = *src.addressOriginator;
	}
	if (src.msgCounter) {
		obj["msgCounter"] = *src.msgCounter;
	}
	if (src.msgCounterReference) {
		obj["msgCounterReference"] = *src.msgCounterReference;
	}
	if (src.cmdClassifier) {
		obj["cmdClassifier"] = *src.cmdClassifier;
	}
	if (src.ackRequest) {
		obj["ackRequest"] = *src.ackRequest;
	}
	if (src.timestamp) {
		obj["timestamp"] = *src.timestamp;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, HeaderType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("specificationVersion")) {
		dst.specificationVersion = obj["specificationVersion"].as<decltype(dst.specificationVersion)::value_type>();
	} else {
		dst.specificationVersion = std::nullopt;
	}
	if (obj.containsKey("addressSource")) {
		dst.addressSource = obj["addressSource"].as<decltype(dst.addressSource)::value_type>();
	} else {
		dst.addressSource = std::nullopt;
	}
	if (obj.containsKey("addressDestination")) {
		dst.addressDestination = obj["addressDestination"].as<decltype(dst.addressDestination)::value_type>();
	} else {
		dst.addressDestination = std::nullopt;
	}
	if (obj.containsKey("addressOriginator")) {
		dst.addressOriginator = obj["addressOriginator"].as<decltype(dst.addressOriginator)::value_type>();
	} else {
		dst.addressOriginator = std::nullopt;
	}
	if (obj.containsKey("msgCounter")) {
		dst.msgCounter = obj["msgCounter"].as<decltype(dst.msgCounter)::value_type>();
	} else {
		dst.msgCounter = std::nullopt;
	}
	if (obj.containsKey("msgCounterReference")) {
		dst.msgCounterReference = obj["msgCounterReference"].as<decltype(dst.msgCounterReference)::value_type>();
	} else {
		dst.msgCounterReference = std::nullopt;
	}
	if (obj.containsKey("cmdClassifier")) {
		dst.cmdClassifier = obj["cmdClassifier"].as<decltype(dst.cmdClassifier)::value_type>();
	} else {
		dst.cmdClassifier = std::nullopt;
	}
	if (obj.containsKey("ackRequest")) {
		dst.ackRequest = obj["ackRequest"].as<decltype(dst.ackRequest)::value_type>();
	} else {
		dst.ackRequest = std::nullopt;
	}
	if (obj.containsKey("timestamp")) {
		dst.timestamp = obj["timestamp"].as<decltype(dst.timestamp)::value_type>();
	} else {
		dst.timestamp = std::nullopt;
	}

}
bool convertToJson(const DatagramType &src, JsonVariant& dst) {
	if (!dst.is<JsonObject>()) {
		return false;
	}
	JsonObject obj = dst.as<JsonObject>();
	if (src.header) {
		obj["header"] = *src.header;
	}
	if (src.payload) {
		obj["payload"] = *src.payload;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DatagramType &dst) {
	if (!src.is<JsonObjectConst>()) {
		return;
	}
	JsonObjectConst obj = src.as<JsonObjectConst>();
	if (obj.containsKey("header")) {
		dst.header = obj["header"].as<decltype(dst.header)::value_type>();
	} else {
		dst.header = std::nullopt;
	}
	if (obj.containsKey("payload")) {
		dst.payload = obj["payload"].as<decltype(dst.payload)::value_type>();
	} else {
		dst.payload = std::nullopt;
	}

}
