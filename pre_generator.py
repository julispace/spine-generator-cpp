

import json

import xmlschema
import os



cpp_header_header = """
// This file is generated by pre_generator.py

#pragma once

#include "module.h"
#include "config.h"
#include <string>
#include <vector>
#include <map>
#include <optional>

namespace ArduinoJson {
template <typename T>
struct Converter<std::vector<T> > {
  static void toJson(const std::vector<T>& src, JsonVariant dst) {
    JsonArray array = dst.to<JsonArray>();
    for (T item : src)
      array.add(item);
  }

  static std::vector<T> fromJson(JsonVariantConst src) {
    std::vector<T> dst;
    for (T item : src.as<JsonArrayConst>())
      dst.push_back(item);
    return dst;
  }

  static bool checkJson(JsonVariantConst src) {
    JsonArrayConst array = src;
    bool result = array;
    for (JsonVariantConst item : array)
      result &= item.is<T>();
    return result;
  }
};
}  // namespace ArduinoJson

struct DateTimeStruct { // Added manually
    std::optional<uint16_t> year;
    std::optional<uint8_t> month;
    std::optional<uint8_t> day;
    std::optional<uint8_t> hour;
    std::optional<uint8_t> minute;
    std::optional<uint8_t> second;
    std::optional<uint16_t> millisecond;
    std::optional<int8_t> timezone; // Offset from UTC in hours, 0 if time is UTC, empty if no TZ is given
};


"""

cpp_implementation_header = """
// This file is generated by pre_generator.py
#include "spine_types.h"


"""

unprocessed_elements = 0

class Spine_type:
    #@brief: Type_name: either "define", "using", "enum", "struct" or "class"
    type_name = ""
    depends_on = []
    name = ""
    code = ""
    to_json_code = ""
    from_json_code = ""
    upper_limit = None
    lower_limit = None
    #this is technically required but we dont check it
    regex_restriction = None

    def __init__(self, type_name, name, code):
        self.type_name = type_name
        self.name = name
        self.code = code
        self.depends_on = []

cpp_datatypes : list[Spine_type] = []


def remove_namespace(name):
    if name is not None:
        if "}" in name:
            return name.split("}", 1)[1]  # Entfernt den Namespace-URI
    else:
        return "None"
    return name

def to_cpp_datatype(type_name):
    #type_name = str(type_name.__name__)
    if hasattr(type_name, "__name__"):
        type_name_str = str(type_name.__name__)
    else:
        type_name_str = type_name
    type_mapping = {
        "string": "std::string",
        "str": "std::string",
        "int": "int",
        "integer": "int",
        "float": "float",
        "double": "double",
        "boolean": "bool",
        "bool": "bool",
        "duration": "std::string", # For now we push all these into strings and handle them later
        "datetime10": "std::string",
        "datetime": "std::string",
        "date": "std::string",
        "time": "std::string",
        "unsignedint": "uint32_t",
        "unsignedbyte": "uint8_t",
        "unsignedlong": "uint64_t",
        "hexbinary": "std::string", # this might be better to convert to byte array
    }
    #if type_name not in type_mapping:
    #       print("Unknown datatype:", type_name)
    return type_mapping.get(type_name_str.lower(), type_name)

def remove_duplicate_objects(spine_types: list[Spine_type]):
    seen = set()
    result = []
    for spine_type in spine_types:
        if spine_type.name not in seen:
            seen.add(spine_type.name)
            result.append(spine_type)
    return result

def sort_and_resolve_dependencies(spine_types: list[Spine_type]):
    type_order = {"define": 0, "using": 1, "enum": 2, "struct": 3, "class": 4}

    # Erstelle eine Abhängigkeits-Map
    dependency_map = {datatype_l.name: datatype_l.depends_on for datatype_l in cpp_datatypes}

    # Topologische Sortierung
    sorted_datatypes = []
    visited = set()

    def visit(datatype_v):
        if datatype_v.name in visited:
            return
        visited.add(datatype_v.name)
        for dependency in dependency_map.get(datatype_v.name, []):
            dependent_datatype = next((d for d in cpp_datatypes if d.name == dependency), None)
            if dependent_datatype:
                visit(dependent_datatype)
        sorted_datatypes.append(datatype_v)

    # Sortiere zuerst nach `type_order`, dann nach Abhängigkeiten
    cpp_datatypes.sort(key=lambda x: type_order.get(x.type_name, 5))
    for datatype_l in cpp_datatypes:
        visit(datatype_l)

    return sorted_datatypes

def make_variable_name(name: str):
    forbidden_names = ["switch", "auto", "SAR", "delete"]
    #Cleanup the variable so it can be used in C++
    name = ''.join(char if char.isalnum() else '_' for char in name)
    # Stelle sicher, dass der Name mit einem Buchstaben beginnt
    if not name[0].isalpha() or name[0] in forbidden_names or name in forbidden_names:
        name = 'var_' + name
    return name

def process_complex_type(complex_type):
    global unprocessed_elements
    struct_type_name = remove_namespace(complex_type.name)
    #we dont generate cmdtype and datagramtype. They are added manually
    if struct_type_name == "CmdType" or struct_type_name == "DatagramType" or struct_type_name == "PayloadType":
        return


    new_type = Spine_type("struct", struct_type_name, "")
    if hasattr(complex_type.content, "content_type_label") and complex_type.content.content_type_label == "simple":
        new_type = Spine_type("using", remove_namespace(complex_type.name), "")
        new_type.code = "using " + remove_namespace(complex_type.name) + " = " + to_cpp_datatype(complex_type.base_type.python_type) + ";\n"
        cpp_datatypes.append(new_type)
        return
    elif complex_type.content.model == "sequence":
        sequence_size = len(complex_type.content)
        elements = []
        new_type.code = f"struct {struct_type_name} {{ // complex\n"
        new_type.to_json_code = f"""bool convertToJson(const {struct_type_name} &src, JsonVariant& dst) {{\n\tif (!dst.is<JsonObject>()) {{\n\t\treturn false;\n\t}}\n\tJsonObject obj = dst.as<JsonObject>();\n"""

        new_type.from_json_code = f"""void convertFromJson(const JsonVariantConst& src, {struct_type_name} &dst) {{\n\tif (!src.is<JsonObjectConst>()) {{\n\t\treturn;\n\t}}\n\tJsonObjectConst obj = src.as<JsonObjectConst>();\n"""
        for elem in complex_type.content:
            variable_type = variable_name = ""
            is_vec = False
            if hasattr(elem, "model"):
                if elem.model == "sequence":
                    if len(elem) > 0:
                        for sub_elem in elem:
                            if len(sub_elem) == 1:
                                sub_elem = sub_elem[0]
                            elif len(sub_elem) > 1:
                                print("Sub element too long")
                            is_vec = sub_elem.max_occurs != 1
                            variable_name = make_variable_name(remove_namespace(sub_elem.name))
                            if not hasattr(sub_elem, "type") and hasattr(sub_elem, "local_name"):
                                variable_type = remove_namespace(sub_elem.local_name)
                            else:
                                variable_type = remove_namespace(sub_elem.type.name)
                            element = [variable_type, variable_name, is_vec]
                            elements.append(element)
                    else:
                        print("unprocessed element: " + struct_type_name + " has model type sequence but no type can be determined")
                        unprocessed_elements += 1
                        return
                else:
                    if struct_type_name == "FilterType":
                        #We dont care about the filtertype. Its done manually
                        return
                    print("unprocessed element: " + struct_type_name + " has model type but is not sequence")
                    unprocessed_elements +=1
                    return
            else:
                variable_name = remove_namespace(elem.name)
                variable_type = remove_namespace(elem.type.name)

                if variable_type is None or variable_type == "None":
                    variable_type = remove_namespace( elem.type.base_type.name)
                if variable_type is None or variable_type == "None":
                    print("Variable type is still none")
                    unprocessed_elements += 1
                    return
                element = [variable_type, variable_name, is_vec]
                elements.append(element)
        for variable_type, variable_name, is_vec  in elements:
            if variable_type == to_cpp_datatype(variable_type):
                new_type.depends_on.append(variable_type)
            variable_type = to_cpp_datatype(variable_type)
            variable_name_string = variable_name
            variable_name_cpp = make_variable_name(variable_name)

            # Handle edgecases
            if variable_type == "SpecificationVersionDataType": # This is some weird edgecase
                variable_type = "SpecificationVersionType"

            # Done
            if is_vec:
                variable_type = "std::vector<" + variable_type + ">"
            new_type.code += f"\tstd::optional<{variable_type}> {variable_name_cpp};\n"
            if variable_type == "None" or variable_type is None:
                print("Variable type is None while making complex type")
                unprocessed_elements += 1
                return
            new_type.to_json_code += f"""\tif (src.{variable_name_cpp}) {{\n\t\tobj["{variable_name_string}"] = *src.{variable_name_cpp};\n\t}}\n"""
            new_type.from_json_code += f"""\tif (obj.containsKey("{variable_name_string}")) {{\n\t\tdst.{variable_name_cpp} = obj["{variable_name_string}"].as<decltype(dst.{variable_name_cpp})::value_type>();\n\t}} else {{\n\t\tdst.{variable_name_cpp} = std::nullopt;\n\t}}\n"""
        if len(elements) < 1:
            new_type.to_json_code = f"""bool convertToJson(const {struct_type_name} &src, JsonVariant& dst) {{\n"""
            new_type.from_json_code = f"""void convertFromJson(const JsonVariantConst& src, {struct_type_name} &dst) {{\n"""

        new_type.code += "};\n"
        new_type.code += f"""bool convertToJson(const {struct_type_name} &src, JsonVariant& dst);\n"""
        new_type.code += f"""void convertFromJson(const JsonVariantConst& src, {struct_type_name} &dst);\n\n"""

        new_type.to_json_code += "\n\treturn true;\n}\n"
        new_type.from_json_code += "\n}\n"
        cpp_datatypes.append(new_type)
        #print("type is sequence")
    #print("Generating code for complex type", remove_namespace(complex_type.name))
    # print("Generating code for complex type", remove_namespace(complex_type.name))




def process_schema(xml_schema):
    global unprocessed_elements
    #print("Generating code...")
    for simple_type in xml_schema.simple_types:

        if simple_type.derivation == "restriction":
            #restriction implies it is either a simple like "using Number = int" or an enum
            # Enum
            if simple_type.enumeration is not None:
                enum_type_name = remove_namespace(simple_type.name)
                new_type = Spine_type("enum",enum_type_name, "")
                #create enum and function headers
                new_type.code = "enum class " + enum_type_name + " {\n"
                new_type.to_json_code = f"""bool convertToJson(const {enum_type_name} &src, JsonVariant& dst) {{\n\tString enumName;\n\tswitch(src) {{\n"""
                new_type.from_json_code = f"""void convertFromJson(const JsonVariantConst& src, {enum_type_name} &dst) {{\n"""

                enum_variable_name = ""
                for enumeration in simple_type.enumeration:
                    enum_string_name = str(enumeration)
                    enum_variable_name = make_variable_name(enum_string_name)
                    new_type.code += "\t" + enum_variable_name + ",\n"
                    #switch case for enum->json
                    new_type.to_json_code += f"""\tcase {enum_type_name}::{enum_variable_name}:\n\t\t enumName = "{enum_string_name}";\n\t\tbreak;\n"""
                    #if return for json->enum
                    new_type.from_json_code += f"""\tif (src == "{enum_string_name}") {{\n\t\tdst = {enum_type_name}::{enum_variable_name};\n\t\treturn;\n\t}}\n"""

                #return empty string if enum->json fails (shouldn't happen)
                new_type.to_json_code += "\t} \n\tdst.set(enumName);\n\treturn true;\n}\n"
                #return last enum if json->enum fails
                new_type.from_json_code += f"""\t return;\n}}\n"""
                new_type.code += "};\n"
                new_type.code += f"""bool convertToJson(const {enum_type_name} &src, JsonVariant& dst);\n"""
                new_type.code += f"""void convertFromJson(const JsonVariantConst& src, {enum_type_name} &dst);\n\n"""
                cpp_datatypes.append(new_type)
            # Using
            elif hasattr(simple_type, 'base_type'):
                new_type = Spine_type("using", remove_namespace(simple_type.name), "")

                new_type.code = "using " + remove_namespace(simple_type.name) + " = " + to_cpp_datatype(simple_type.base_type.python_type) + ";\n"
                found_restriction = False
                if simple_type.base_type.max_value is not None:
                    new_type.max_value = simple_type.base_type.max_value
                    pass
                if simple_type.base_type.min_value is not None:
                    found_restriction = True
                    new_type.min_value = simple_type.base_type.min_value
                    found_restriction = True
                if to_cpp_datatype(simple_type.base_type.python_type) == "std::string":
                    found_restriction = True
                if hasattr(simple_type.base_type.python_type, 'name'):
                    if simple_type.base_type.python_type.name == "duration":
                        found_restriction = True
                if not found_restriction:
                    print("Unknown restriction to basetype", simple_type.name)
                cpp_datatypes.append(new_type)
                pass
            else:
                unprocessed_elements += 1
                print("simple type: " + simple_type.name + " has restriction but no enumeration. Not sure what to do with this")
        else:
            # else its a struct
            # TODO: this is making structs in some cases where it should be making a using type (example: messagingtypetype)
            if hasattr(simple_type, 'member_types'):
                struct_type_name = remove_namespace(simple_type.name)

                new_type = Spine_type("struct", struct_type_name, "")
                new_type.code = "struct " + struct_type_name + " { // simple_complex \n"
                new_type.to_json_code = f"""bool convertToJson(const {struct_type_name} &src, JsonVariant& dst) {{\n\tif (!dst.is<JsonObject>()) {{\n\t\treturn false;\n\t}}\n\tJsonObject obj = dst.as<JsonObject>();\n"""

                new_type.from_json_code = f"""void convertFromJson(const JsonVariantConst& src, {struct_type_name} &dst) {{\n\tif (!src.is<JsonObjectConst>()) {{\n\t\treturn;\n\t}}\n\tJsonObjectConst obj = src.as<JsonObjectConst>();\n"""
                for member_type in simple_type.member_types:
                    member_type_name = remove_namespace(member_type.name)
                    if member_type.derivation == "restriction":
                        member_type_name = remove_namespace(member_type.name)
                        member_variable_name = str(member_type.local_name)
                        member_variable_cpp = member_variable_name.lower()
                    else:
                        member_type_name = to_cpp_datatype(member_type.python_type)
                        member_variable_name = member_type.local_name
                        member_variable_cpp = member_variable_name.lower()
                    if member_type_name == "None":
                        print("Member type is None")
                        unprocessed_elements += 1
                        return
                    new_type.code += "\tstd::optional<" + member_type_name + "> " + member_variable_cpp + ";\n"
                    new_type.to_json_code += f"""\tif (src.{member_variable_cpp}) {{\n\t\tobj["{member_variable_name}"] = *src.{member_variable_cpp};\n\t}}\n"""
                    new_type.from_json_code += f"""\tif (obj.containsKey("{member_variable_name}")) {{\n\t\tdst.{member_variable_cpp} = obj["{member_variable_name}"].as<decltype(dst.{member_variable_cpp})::value_type>();\n\t}} else {{\n\t\tdst.{member_variable_cpp} = std::nullopt;\n\t}}\n"""
                if len(simple_type.member_types) < 1:
                    print("Empty complex type: " + struct_type_name)
                new_type.code += "};\n"

                new_type.to_json_code += "\n\treturn true;\n};\n"
                new_type.from_json_code += "};\n"
                cpp_datatypes.append(new_type)
            else:
                print("No restriction to basetype", simple_type.name)
                unprocessed_elements += 1
    for complex_type in xml_schema.complex_types:
        process_complex_type(complex_type)

    for element in xml_schema.elements:
        pass
        #print("Generating code for element", remove_namespace(element))



print("Loading schema...")

schema_path = os.path.join("SPINE", "EEBus_SPINE_TS_NodeManagement.xsd")
# Schema laden
#schema = xmlschema.XMLSchema(schema_path)
#process_schema(schema)

spine_path = "SPINE"

for xsd in os.listdir(spine_path):
    if xsd.endswith(".xsd"):
        print("Processing: " + xsd)
        schema = xmlschema.XMLSchema(os.path.join(spine_path, xsd))
        process_schema(schema)


print("Deduplicating and sorting code...")
print("Elements Before: ", len(cpp_datatypes))
cpp_datatypes = remove_duplicate_objects(cpp_datatypes)
cpp_datatypes = sort_and_resolve_dependencies(cpp_datatypes)
print("Elements After: ", len(cpp_datatypes))
print("Writing code to files...")
with open("spine_types.h", "w")as h, open("spine_types.cpp", "w") as cpp:
    h.write(cpp_header_header)
    cpp.write(cpp_implementation_header)
    #include "config.h"
    # Forward declaration
    #for data in cpp_datatypes:
    #    if data.type_name == "struct":
    #        h.write(f"{data.type_name} {data.name};\n")
    h.write("\n\n\n\n")
    for datatype in cpp_datatypes:
        h.write(datatype.code)
        cpp.write(datatype.to_json_code)
        cpp.write(datatype.from_json_code)

with open("spine_types.h", "r") as h, open("spine_types.cpp", "r") as cpp:
    print(f"Wrote {len(h.readlines())} LOC to header ")
    print(f"Wrote {len(cpp.readlines())} LOC to cpp")

print(f"Unprocessed elements: {unprocessed_elements}")

print("Done!")

